From a160dd994d7fe6b882b51699d896b31ff88a5df9 Mon Sep 17 00:00:00 2001
From: koala <koala@brahmaos.io>
Date: Thu, 15 Nov 2018 10:10:18 +0800
Subject: [PATCH] Modify DocumentsUI to add some function

- Add produce QRCode and scan function
- Add progress bar bug in remote fragment
- use addFile getFile listFile new interface in DocumentsUI

Change-Id: I0c8e38a391f7cd86125987a76725dd594e92cbb0
Signed-off-by: koala <koala@brahmaos.io>
---
 Android.mk                                         |   5 +-
 AndroidManifest.xml                                |  12 +-
 res/drawable-hdpi/ic_scan_white.png                | Bin 0 -> 538 bytes
 res/drawable-mdpi/ic_scan_white.png                | Bin 0 -> 366 bytes
 res/drawable-xhdpi/ic_scan_white.png               | Bin 0 -> 645 bytes
 res/drawable-xxhdpi/ic_scan_white.png              | Bin 0 -> 1120 bytes
 res/drawable/btn_gray_bg.xml                       |   9 +
 res/drawable/btn_scan_bg.xml                       |   9 +
 res/drawable/list_item_bg.xml                      |   9 +
 res/drawable/qrcode.png                            | Bin 0 -> 479 bytes
 res/layout/activity_address_qrcode.xml             |  75 +++
 res/layout/activity_capture.xml                    |  54 ++
 res/layout/dsn_dialog_scan.xml                     |  84 ++++
 res/layout/dsn_drawer_layout.xml                   | 550 +++++++++++++--------
 res/layout/fragment_dsn_directory.xml              |  17 +-
 res/menu/activity.xml                              |   6 +
 res/menu/dsn_files_activity.xml                    |  15 +-
 res/raw/beep.ogg                                   | Bin 0 -> 6401 bytes
 res/values-en-rGB/strings.xml                      |  17 +-
 res/values-zh-rCN/strings.xml                      |   2 +
 res/values/colors.xml                              |   9 +
 res/values/ids.xml                                 |  25 +
 res/values/strings.xml                             |  45 +-
 res/values/styles.xml                              |  17 +-
 src/com/android/documentsui/BaseActivity.java      |  96 +++-
 .../documentsui/DSN/DSNAddressQrcodeActivity.java  | 101 ++++
 .../android/documentsui/DSN/base/BaseActivity.java | 129 +++++
 .../android/documentsui/DSN/conmmon/ReqCode.java   |  10 +
 .../documentsui/DSN/conmmon/SelectionState.java    |  26 +
 .../DSN/dirlist/DSNDirectoryAddonsAdapter.java     |  14 +-
 .../DSN/dirlist/DSNDirectoryFragment.java          | 104 ++--
 .../DSN/dirlist/DSNListeningGestureDetector.java   |   3 -
 .../DSN/dirlist/DSNUserInputHandler.java           |  16 +-
 .../DSN/selection/DSNSelectionManager.java         |  24 +
 .../DSN/ui/common/barcode/AmbientLightManager.java |  82 +++
 .../DSN/ui/common/barcode/BeepManager.java         | 127 +++++
 .../DSN/ui/common/barcode/CaptureActivity.java     | 403 +++++++++++++++
 .../ui/common/barcode/CaptureActivityHandler.java  | 172 +++++++
 .../DSN/ui/common/barcode/Contents.java            | 118 +++++
 .../DSN/ui/common/barcode/DecodeFormatManager.java | 106 ++++
 .../DSN/ui/common/barcode/DecodeHandler.java       | 129 +++++
 .../DSN/ui/common/barcode/DecodeHintManager.java   | 236 +++++++++
 .../DSN/ui/common/barcode/DecodeThread.java        | 113 +++++
 .../DSN/ui/common/barcode/FinishListener.java      |  49 ++
 .../documentsui/DSN/ui/common/barcode/Intents.java | 231 +++++++++
 .../DSN/ui/common/barcode/LocaleManager.java       | 185 +++++++
 .../barcode/ViewfinderResultPointCallback.java     |  35 ++
 .../DSN/ui/common/barcode/ViewfinderView.java      | 193 ++++++++
 .../ui/common/barcode/camera/AutoFocusManager.java | 130 +++++
 .../barcode/camera/CameraConfigurationManager.java | 223 +++++++++
 .../barcode/camera/CameraConfigurationUtils.java   | 455 +++++++++++++++++
 .../ui/common/barcode/camera/CameraManager.java    | 351 +++++++++++++
 .../ui/common/barcode/camera/PreviewCallback.java  |  56 +++
 .../common/barcode/camera/open/CameraFacing.java   |  25 +
 .../ui/common/barcode/camera/open/OpenCamera.java  |  55 +++
 .../barcode/camera/open/OpenCameraInterface.java   |  98 ++++
 .../barcode/result/AddressBookResultHandler.java   | 219 ++++++++
 .../barcode/result/CalendarResultHandler.java      | 188 +++++++
 .../barcode/result/EmailAddressResultHandler.java  |  72 +++
 .../ui/common/barcode/result/GeoResultHandler.java |  69 +++
 .../common/barcode/result/ISBNResultHandler.java   |  74 +++
 .../barcode/result/ProductResultHandler.java       |  85 ++++
 .../ui/common/barcode/result/ResultHandler.java    | 497 +++++++++++++++++++
 .../barcode/result/ResultHandlerFactory.java       |  64 +++
 .../ui/common/barcode/result/SMSResultHandler.java |  86 ++++
 .../ui/common/barcode/result/TelResultHandler.java |  84 ++++
 .../common/barcode/result/TextResultHandler.java   |  78 +++
 .../ui/common/barcode/result/URIResultHandler.java | 104 ++++
 .../android/documentsui/DSN/util/CommonUtil.java   | 169 +++++++
 .../documentsui/DSN/util/PermissionUtil.java       | 138 ++++++
 .../android/documentsui/DSN/util/QRCodeUtil.java   | 165 +++++++
 .../android/documentsui/DSNObjectMetaLoader.java   |  35 --
 .../android/documentsui/DocumentsApplication.java  |  20 -
 .../documentsui/dirlist/DirectoryFragment.java     |  18 +-
 .../dirlist/ListeningGestureDetector.java          |   3 -
 .../documentsui/dirlist/UserInputHandler.java      |   1 -
 .../documentsui/files/DSNFilesActivity.java        |  69 ++-
 .../documentsui/httpnetwork/HttpServer.java        |   6 +-
 .../android/documentsui/httpnetwork/Networks.java  |   4 +-
 .../documentsui/httpnetwork/ObjectMeta.java        |  47 +-
 .../android/documentsui/services/BackupJob.java    |  92 ++--
 .../services/DownloadDocumentsFromDSNJob.java      |  88 ++--
 .../android/documentsui/sidebar/RootsFragment.java |   2 +-
 83 files changed, 7007 insertions(+), 525 deletions(-)
 create mode 100644 res/drawable-hdpi/ic_scan_white.png
 create mode 100644 res/drawable-mdpi/ic_scan_white.png
 create mode 100644 res/drawable-xhdpi/ic_scan_white.png
 create mode 100644 res/drawable-xxhdpi/ic_scan_white.png
 create mode 100644 res/drawable/btn_gray_bg.xml
 create mode 100644 res/drawable/btn_scan_bg.xml
 create mode 100644 res/drawable/list_item_bg.xml
 create mode 100644 res/drawable/qrcode.png
 create mode 100644 res/layout/activity_address_qrcode.xml
 create mode 100644 res/layout/activity_capture.xml
 create mode 100644 res/layout/dsn_dialog_scan.xml
 create mode 100644 res/raw/beep.ogg
 create mode 100644 res/values/ids.xml
 create mode 100644 src/com/android/documentsui/DSN/DSNAddressQrcodeActivity.java
 create mode 100644 src/com/android/documentsui/DSN/base/BaseActivity.java
 create mode 100644 src/com/android/documentsui/DSN/conmmon/ReqCode.java
 create mode 100644 src/com/android/documentsui/DSN/conmmon/SelectionState.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/AmbientLightManager.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/BeepManager.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/CaptureActivity.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/CaptureActivityHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/Contents.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/DecodeFormatManager.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/DecodeHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/DecodeHintManager.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/DecodeThread.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/FinishListener.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/Intents.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/LocaleManager.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/ViewfinderResultPointCallback.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/ViewfinderView.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/camera/AutoFocusManager.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraConfigurationManager.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraConfigurationUtils.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraManager.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/camera/PreviewCallback.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/camera/open/CameraFacing.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/camera/open/OpenCamera.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/camera/open/OpenCameraInterface.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/AddressBookResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/CalendarResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/EmailAddressResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/GeoResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/ISBNResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/ProductResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/ResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/ResultHandlerFactory.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/SMSResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/TelResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/TextResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/ui/common/barcode/result/URIResultHandler.java
 create mode 100644 src/com/android/documentsui/DSN/util/CommonUtil.java
 create mode 100644 src/com/android/documentsui/DSN/util/PermissionUtil.java
 create mode 100644 src/com/android/documentsui/DSN/util/QRCodeUtil.java
 delete mode 100644 src/com/android/documentsui/DSNObjectMetaLoader.java

diff --git a/Android.mk b/Android.mk
index 514ea0c..9294477 100644
--- a/Android.mk
+++ b/Android.mk
@@ -31,7 +31,10 @@ LOCAL_STATIC_JAVA_LIBRARIES += android-support-annotations \
                         reactivex-rxjava \
                         jackson-databind \
                         jackson-core \
-                        jackson
+                        jackson \
+                        google-zxing \
+                        glide-full-4.7 \
+                        gson
 
 LOCAL_STATIC_JAVA_AAR_LIBRARIES = reactivex-rxandroid
 
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index b6210de..e3ebb29 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -15,6 +15,7 @@
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" />
     <uses-permission android:name="android.permission.MANAGE_USERS"/>
+    <uses-permission android:name="android.permission.CAMERA" />
 
     <application
         android:name=".DocumentsApplication"
@@ -105,9 +106,18 @@
         </activity>
         <activity
             android:name=".files.DSNFilesActivity"
-	    android:theme="@style/DNSDocumentsTheme">
+            android:theme="@style/DSNDocumentsTheme">
         </activity>
 
+        <activity
+            android:name=".DSN.DSNAddressQrcodeActivity"
+            android:theme="@style/DSNDocumentsTheme">
+        </activity>
+
+        <activity
+            android:name=".DSN.ui.common.barcode.CaptureActivity"
+            android:theme="@style/DSNDocumentsTheme">
+        </activity>
 
         <activity-alias android:name="ViewDownloadsActivity"
                         android:targetActivity=".files.FilesActivity"
diff --git a/res/drawable-hdpi/ic_scan_white.png b/res/drawable-hdpi/ic_scan_white.png
new file mode 100644
index 0000000000000000000000000000000000000000..fcd975ec4162bc8d02387b1c57311e5499a812a7
GIT binary patch
literal 538
zcmV+#0_FXQP)<h;3K|Lk000e1NJLTq001xm001xu1^@s6R|5Hm0005uNkl<Zc-rll
zO-n*i5QcRjg@py75rk!heT($9i>M$7q(4xr$b~JUP0^xX(Lzuti24BqajC#4i?HlJ
z**h@7S==u#<1z3IJj;1!UhnbVITH$*Fk!-k2@_33qtQr%O|WgljF0@RL+%DhwX$(4
zd<}kF_y7|w8Y|$-L!$`Bq?=y^6{QF@@oB?77;@2>1WyjR--`Z&m<b3)z#R)ykz;-u
zX&VN7=nXpLE`f8!L|MwfIt$jpzJ~wUnPMU>Ay{Cs7q{afXkdzu6xH035IkbBXAsk1
zU>Lk|&0T2&eVPos83V?^KQgcd-uVj|(O{ql+<+=rmJ&^YUXAlsKS*}`)Hwoj^f75O
zxj;_?NtVads1qxQfie$o^)^F2l!6$D(nt%&+YI#(?f5_RsE$ESsTZS~QetcTQMm+N
z8k+A0S6p*dLNL#70=iNrG#E(m-Ggf8r47V28#piqjDcVVDv}2FSgb1cYV&?&S0(QQ
z3(8DV&|u(Dsh5=y41-%m^aNxamQ!(`N5n3dG*6W}w8jie{VKD3rTi1GIjjdQw`0b0
zjpdMAQ}iFfbSt*fMUSzU8kuv^$S6xICoX7+YvmbD@+#bJMLzE%KjX4q@9=A+2@@tv
cm}oYB0g7`VSlJ}9f&c&j07*qoM6N<$f-dvpKL7v#

literal 0
HcmV?d00001

diff --git a/res/drawable-mdpi/ic_scan_white.png b/res/drawable-mdpi/ic_scan_white.png
new file mode 100644
index 0000000000000000000000000000000000000000..d7c18b692591720c6b1d0d5eb2cc8dd079096ccf
GIT binary patch
literal 366
zcmV-!0g?WRP)<h;3K|Lk000e1NJLTq001BW001Be1^@s6b9#F80003sNkl<Zc-muN
z7zLwXu!H~q|H}ih0T3HPu^te!Vo}Ei#QI3;Kzd{-u~-a<=K=8<EI1O2`b->ZrvNcO
zsg^SV@iHJj4a7}A90jrzio=0e5Ql>!kko<nbV405jZ_C1Lp7FAAqrcdW+{-O$rGx{
zi3$z~fSP4PiY6~AI=~-lmhF&ofIC!^0~H+L2Q|x@6iu8!90<zWRB!+n)GXE^Q}WFP
z;ypCNbBJ+3Ewlur1+Ez~(ZCMGK|stw1+zGzX0el^$qAZu+^FCHSeAAqMUyjBlLr+X
z04vs=hm-?gQQ%1h2asN@0~KpQHC0i;0o72mG)U3Jh}0TtMr)9O8Xdw|^oU?-kigmk
zv&nI}FsLPiqnVX}MST(uwUdBYh>{?b!qO;ZBeGE{J=&}v1%n;{0Fa&4e<w_zC;$Ke
M07*qoM6N<$g1t71o&W#<

literal 0
HcmV?d00001

diff --git a/res/drawable-xhdpi/ic_scan_white.png b/res/drawable-xhdpi/ic_scan_white.png
new file mode 100644
index 0000000000000000000000000000000000000000..13ccb61b5ea7a24be9a58d06f6c78e912c024d75
GIT binary patch
literal 645
zcmV;00($+4P)<h;3K|Lk000e1NJLTq002M$002M;1^@s6s%dfF0006^Nkl<Zc-rln
z-%FEG9LD`|6@v<i1riQS!$j~x7<kb|;*BB0E161Y1zjWt4eKHdlw@9bqcy1r2L8rh
zC5;G11O^pZ|I>O7oZ#@X&2#2^&d%8Lz~^$`=X)OBz3<-dz6}i&MNt$*Q4~d)s!%92
zf*vperog=tjDZ$|x~<@DnR=687<5$g@NuvU{%W!*0@J8_0ptzpz5|`E4?k|u;D5e>
zCXL!xDyaPv+;VmJ!6FU(2A{#F66}Kk1CJ#5P^R7&a9SjU8@3N0ygWq{55VOrd<Cz9
zXMqs1woQivhNB+bh-U*mb=fpqP>eo$@+69YA4*?In`W;RqqIkl;|-;+r>+8c=}`b#
zrLX6%0$5}K41fXDT>!7^J%DA!XwIVm-Y9*gY#Ln$TQc!hj{@ihd*Hoznc|>=qC)+C
z4ajNEVT~brz8yvY-z%8V_`*pT0UXqD0Q+GC5Csp#^A$X)5mK_}C~smE73w3gO^%<o
zLAytNiJ#~@U>#huX*93gVV67#Kz&JjVbdtB7_E8~z^apBZ6JUZ2EYIq00XGE02URa
zj7I^iIr+y5#b*?wyw1XdgTpt2uS#E!Y?}24UN<K_2;hF8r?^eCCOK_U4X44yDjfV0
zcpT_uPiGJ5yvBVcc64%OR$7ig!oXuhex_8tob*(C_yc-frJs;{K_=6gUt+~Zqjsdo
z{*TU*)R5~-@FsX`(4<&;YSz4|9UIimRC`}A2JW1(C^>F2o|0p@i8B@@#Z?&Nkb<Hp
filQirqAJoqBgxH{$_4+e00000NkvXXu0mjf-2)pa

literal 0
HcmV?d00001

diff --git a/res/drawable-xxhdpi/ic_scan_white.png b/res/drawable-xxhdpi/ic_scan_white.png
new file mode 100644
index 0000000000000000000000000000000000000000..2cf1361c13b1bff873fc79724247ab000cf6d30f
GIT binary patch
literal 1120
zcmV-m1fTnfP)<h;3K|Lk000e1NJLTq003YB003YJ1^@s6;+S_h000ChNkl<Zc-rk;
zYfBYT6!oS(H0@yzEy6VV5SBe5Eusvq2p_!(Dx!jf@<U)n56s9S?L%6TK_x{mdSVYs
zd!aYYwDLdM+O_>M%;>#$#@m^>Yr*<-VP@^U&N(x4&b~V-i697qAP9mW2!bF8f*=Tj
zAP9o+F9rt(Ltqhj2s{TigEt~%9k{>)4XeS1DDHa|JPqyv^ZlCm>EIUd2{_<_Z^5N8
zY8ay$I$dhG4z2|!`X%`}U=!HwGH_uZxL;;c3_8+v77cj7&){*nrXP}j&7+_P)Wlse
z8ZaI_>7kZ>@C2A@YVv1;H-`z}mnKw}gsuqq39JPtxzIFMXXDoh?<v}PRIAgBtO3(Z
zG@u&%Z6jI&YSG`ffn{L%2&@2$y;yf~jcjnEUUQ`Ting6P(jRETt?`IS>rG4kG#x>9
zBSw;*1&;O6OT+|SPOBYeLaS+ls~kp3X#ifOkAOdH;#*>hz*O*-&3b>v__v10pKZ5o
z45%_ipgicFTg1r&v^XFilgZ#gn_18(-x?+eTm-(hh<gFf3(yz6e29It#CRXfFhN{_
zjRDW(Ar>G53c(MS7$3^Z2MwSB31L7H4WI!ufCkV28bAYR01YtBfW_dOfEys^%I%gI
zAIZ_H3F7i}>%lrYG6Q6Q-F8c>F{fh?vQ?*OryiuQN(vD4fPXL80fxagS$a)eC(Df4
zCm$UX)_|41Emt83f*^eVFq);co>FRZm;B2X%}I7V47e~%;Zh<~a#9x$1A3WkNA|?S
zfHo%Dk+0%mzy>Wt>C<UP{>z2zf0e|;fN@fCBK474bD8Meq;;&4lW}}aBM5>Z{>K;c
z3f-z*8Q>TTHOA$p2`dHP>0!ltITr|E@`nzc!W!#3Q-sX~A6q_1o`Q1%lzelKUG@Ff
zDo(zZ7Y4|H0*4a(JQKv_+WbMIEl9_9GMH?(U?k>T8bAYR01co4G=K)s02)98MlZ&E
z8bAXa#pUR6oF|>G3^ibx?*Ev#-6H*bz<U;PVcj(h1t9q$-G~d@l&7bgAW*7?&s)Sv
z-=K@&<Nz2j6})WI3#rza0R|zPZAvu0Nw1&)7_h^k|6PemB2#SsrZmKT+VUmEM@dgn
z%?BJ}dTB(b6pLtCC%@Z>?bUuehxNHo9%0L}5-;}K<r;cmR1x95E42aD9fvBwZX*wz
zbggU{p#^0)!sdBh+A316m*ql}jN&WcmniNV)((kwG01bE-c2LH(Kca*Ce5qj-Jd#h
zl4D#(j(Vu2Uz49{`uZsi{LX5tNVh@Dh&vWb#hF&{)p*>vb&6jeVi{Vl*X%OzcKu^q
zER9=3+Ucsp<p5|@4QWY!1cc8Aw}YpmY~Ee(#n-fykbsw>xNnor;N3xLyG9TMK@bE%
m5ClOG1VIo4K@bFyu=oSHHa*+}&SjVY0000<MNUMnLSTZd^7F9(

literal 0
HcmV?d00001

diff --git a/res/drawable/btn_gray_bg.xml b/res/drawable/btn_gray_bg.xml
new file mode 100644
index 0000000..471607a
--- /dev/null
+++ b/res/drawable/btn_gray_bg.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <corners android:topLeftRadius="@dimen/block_corner"
+        android:topRightRadius="@dimen/block_corner"
+        android:bottomLeftRadius="@dimen/block_corner"
+        android:bottomRightRadius="@dimen/block_corner"/>
+    <solid android:color="#f2f1f1"/>
+</shape>
\ No newline at end of file
diff --git a/res/drawable/btn_scan_bg.xml b/res/drawable/btn_scan_bg.xml
new file mode 100644
index 0000000..b1b2184
--- /dev/null
+++ b/res/drawable/btn_scan_bg.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <corners android:topLeftRadius="@dimen/block_corner"
+        android:topRightRadius="@dimen/block_corner"
+        android:bottomLeftRadius="@dimen/block_corner"
+        android:bottomRightRadius="@dimen/block_corner"/>
+    <solid android:color="@color/viewfinder_btn_bg"/>
+</shape>
\ No newline at end of file
diff --git a/res/drawable/list_item_bg.xml b/res/drawable/list_item_bg.xml
new file mode 100644
index 0000000..ef243d8
--- /dev/null
+++ b/res/drawable/list_item_bg.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ripple xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="#cfcfcf">
+    <item>
+        <shape android:shape="rectangle">
+            <solid android:color="#FFFFFF" />
+        </shape>
+    </item>
+</ripple>
\ No newline at end of file
diff --git a/res/drawable/qrcode.png b/res/drawable/qrcode.png
new file mode 100644
index 0000000000000000000000000000000000000000..6514d1b4ee5822bd6edfbe95fc6533aae51f16e9
GIT binary patch
literal 479
zcmV<50U-W~P)<h;3K|Lk000e1NJLTq002M$002M;1^@s6s%dfF0004|Nkl<ZcwX&W
zJ5Izf5S^C`us7IKP(isBCqdiMIN=6%5-AnhlTgx8atOo)5FJt^8_{p%WHwpH(c3nj
ziTyJ3=I2FS*Fh5ey!ZR6s=oeT-L~!Cd;ghW8v+7A3!n>-15%I=Nic^f5JGqtkvENn
z0Js&AhauT177#*s6_F3+J`N&sHzXSigVq@Hta-6>?g-#z4gf^tXpA{2_hA8)1YiIG
zT0kTdqzjM(NP>(441>z}%RGRI5Hmrh!mI_dE{0eRYvSKXnJN8%kt$WoV%4BZ=@=mb
zkV8vs%$L-zp#{(aI2&BYa8&EVTam+74x&8=0nj416}en8!DN%6#Xj`JM2G;Snhnwd
zmO_9oFs&9K2PENuYqi9zwKo8sH0}oA*BE1mWSgcrc<=AeJuiwP#PWcvjK^aKcg~#v
zJf2$@Lij1mau?IF>Kh`l%@Y7x09}9_KoVpW(1k(g-1;v{E*S<104;znKn_^_ZSmET
zU=HPQ3_JiA{b3@eU;TWpmRQ$yyT0$gwHt}`1GIXhas*(eo**rNE<g?-30@Kf{s2ad
VvVjtFs=NRI002ovPDHLkV1htN!vFvP

literal 0
HcmV?d00001

diff --git a/res/layout/activity_address_qrcode.xml b/res/layout/activity_address_qrcode.xml
new file mode 100644
index 0000000..0aaddf4
--- /dev/null
+++ b/res/layout/activity_address_qrcode.xml
@@ -0,0 +1,75 @@
+<?xml version="1.0" encoding="utf-8"?>
+<android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/drawer_layout"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:fitsSystemWindows="true">
+
+    <android.support.design.widget.CoordinatorLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+        <android.support.v7.widget.Toolbar
+            android:id="@+id/toolbar"
+            android:layout_width="match_parent"
+            android:layout_height="?android:attr/actionBarSize"
+            android:background="?android:attr/colorPrimary"
+            android:elevation="8dp"
+            android:theme="?actionBarTheme"
+            app:titleTextAppearance="@style/ToolbarTitleText"
+            app:title="@string/title_address_qrcode"
+            app:popupTheme="@style/popup_theme"/>
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:background="@color/white"
+            android:layout_marginTop="@dimen/height_toolbar"
+            android:orientation="horizontal">
+
+            <LinearLayout
+                android:layout_width="0dp"
+                android:layout_weight="1.5"
+                android:layout_height="match_parent" />
+            <LinearLayout
+                android:layout_width="0dp"
+                android:layout_weight="7"
+                android:layout_height="match_parent"
+                android:orientation="vertical">
+                <TextView
+                    android:id="@+id/tv_account_address"
+                    android:layout_marginTop="@dimen/space_largest"
+                    android:textSize="@dimen/font_size_body"
+                    android:textColor="@color/color_secondary_text"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content" />
+                <LinearLayout
+                    android:layout_width="match_parent"
+                    android:layout_height="1dp"
+                    android:orientation="vertical"
+                    android:layout_marginTop="@dimen/space_larger"
+                    android:background="@color/divider"/>
+                <ImageView
+                    android:layout_marginTop="@dimen/space_larger"
+                    android:id="@+id/iv_address_code"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:background="@color/gray_border"/>
+
+                <Button
+                    android:id="@+id/btn_copy_address"
+                    style="@style/ButtonGraySingle"
+                    android:layout_marginTop="@dimen/space_larger"
+                    android:text="@string/action_copy_address"/>
+            </LinearLayout>
+
+            <LinearLayout
+                android:layout_width="0dp"
+                android:layout_weight="1.5"
+                android:layout_height="match_parent" />
+        </LinearLayout>
+
+    </android.support.design.widget.CoordinatorLayout>
+</android.support.v4.widget.DrawerLayout>
+
diff --git a/res/layout/activity_capture.xml b/res/layout/activity_capture.xml
new file mode 100644
index 0000000..0d856a4
--- /dev/null
+++ b/res/layout/activity_capture.xml
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="utf-8"?>
+<android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+    <android.support.design.widget.AppBarLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        app:elevation="0dp"
+        android:theme="@style/AppTheme.AppBarOverlay">
+        <android.support.v7.widget.Toolbar
+            android:id="@+id/toolbar"
+            android:layout_width="match_parent"
+            android:layout_height="?attr/actionBarSize"
+            app:title="@string/title_capture_code"
+            app:titleTextAppearance="@style/ToolbarTitleText"
+            android:background="@color/black"/>
+    </android.support.design.widget.AppBarLayout>
+
+    <FrameLayout
+        android:layout_marginTop="@dimen/height_toolbar"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+        <SurfaceView android:id="@+id/preview_view"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"/>
+        <com.android.documentsui.DSN.ui.common.barcode.ViewfinderView
+            android:id="@+id/viewfinder_view"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"/>
+        <Button
+            android:id="@+id/set_torch_btn"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textSize="@dimen/font_size_body"
+            android:textColor="@color/white"
+            android:paddingStart="@dimen/space_normal"
+            android:paddingEnd="@dimen/space_normal"
+            android:paddingTop="@dimen/space_small"
+            android:paddingBottom="@dimen/space_small"
+            android:background="@drawable/btn_scan_bg"
+            android:visibility="gone"
+            android:text="打开闪光灯"/>
+        <TextView android:id="@+id/status_view"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="bottom|center_horizontal"
+            android:background="@android:color/transparent"
+            android:textColor="@color/white"/>
+    </FrameLayout>
+</android.support.design.widget.CoordinatorLayout>
diff --git a/res/layout/dsn_dialog_scan.xml b/res/layout/dsn_dialog_scan.xml
new file mode 100644
index 0000000..7269fb1
--- /dev/null
+++ b/res/layout/dsn_dialog_scan.xml
@@ -0,0 +1,84 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:paddingTop="@dimen/space_small"
+    android:paddingBottom="@dimen/space_small"
+    android:paddingStart="@dimen/space_normal"
+    android:paddingEnd="@dimen/space_normal"
+    android:gravity="center_vertical"
+    android:orientation="vertical">
+    <RelativeLayout
+        android:layout_width="wrap_content"
+        android:layout_centerVertical="true"
+        android:layout_height="wrap_content">
+        <TextView
+            android:id="@+id/tv_name_title"
+            android:textAlignment="center"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textColor="@color/colorSubTitle"
+            android:text="File name:"
+            android:textSize="@dimen/font_size_subheading"/>
+        <TextView
+            android:id="@+id/tv_name_content"
+            android:textAlignment="center"
+            android:layout_alignParentRight="true"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="6dp"
+            android:layout_marginTop="@dimen/space_unit"
+            android:textSize="14sp"
+            android:text="xxxx"
+            android:textColor="@color/colorSubContent"/>
+    </RelativeLayout>
+    <RelativeLayout
+        android:layout_width="wrap_content"
+        android:layout_centerVertical="true"
+        android:layout_height="wrap_content">
+        <TextView
+            android:id="@+id/tv_size_title"
+            android:textAlignment="center"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textColor="@color/colorSubTitle"
+            android:text="File Size:"
+            android:textSize="@dimen/font_size_subheading"/>
+        <TextView
+            android:id="@+id/tv_size_content"
+            android:textAlignment="center"
+            android:layout_alignParentRight="true"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="6dp"
+            android:layout_marginTop="@dimen/space_unit"
+            android:textSize="14sp"
+            android:text="xxxx"
+            android:textColor="@color/colorSubContent"/>
+      </RelativeLayout>
+    <RelativeLayout
+        android:layout_width="wrap_content"
+        android:layout_centerVertical="true"
+        android:layout_height="wrap_content">
+        <TextView
+            android:id="@+id/tv_type_title"
+            android:textAlignment="center"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textColor="@color/colorSubTitle"
+            android:text="File MIME-Type:"
+            android:textSize="@dimen/font_size_subheading"/>
+        <TextView
+            android:id="@+id/tv_type_content"
+            android:textAlignment="center"
+            android:layout_alignParentRight="true"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="6dp"
+            android:layout_marginTop="@dimen/space_unit"
+            android:textSize="14sp"
+            android:text="xxxx"
+            android:textColor="@color/colorSubContent"/>
+    </RelativeLayout>
+</LinearLayout>
diff --git a/res/layout/dsn_drawer_layout.xml b/res/layout/dsn_drawer_layout.xml
index 68022f8..f03b29a 100644
--- a/res/layout/dsn_drawer_layout.xml
+++ b/res/layout/dsn_drawer_layout.xml
@@ -24,233 +24,347 @@
     android:id="@+id/coordinator_layout">
 
     <LinearLayout
-            android:layout_width="match_parent"
-            android:layout_height="match_parent"
-            android:background="@color/colorBackgroundGray"
-            android:orientation="vertical">
-
-	    <android.support.v7.widget.Toolbar
-		android:id="@+id/toolbar"
-		android:layout_width="match_parent"
-		android:layout_height="?android:attr/actionBarSize"
-		android:background="?android:attr/colorPrimary"
-		android:elevation="8dp"
-		android:theme="?actionBarTheme"
-		app:popupTheme="@style/popup_theme">
-
-		<com.android.documentsui.DropdownBreadcrumb
-		    android:id="@+id/dropdown_breadcrumb"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:layout_marginStart="4dp"
-		    android:popupTheme="?actionBarPopupTheme"
-		    android:background="@android:color/transparent"
-		    android:overlapAnchor="true" />
-
-	    </android.support.v7.widget.Toolbar>
-
-	    <LinearLayout
-		android:layout_width="match_parent"
-		android:layout_height="88dp"
-		android:background="@color/colorBackgroundWhite"
-		android:paddingStart="@dimen/space_normal"
-		android:paddingEnd="@dimen/space_normal"
-		android:gravity="center_vertical"
-		android:orientation="vertical">
-
-		<TextView
-		    android:id="@+id/tv_hashkey_title"
-		    android:layout_width="match_parent"
-		    android:layout_height="wrap_content"
-		    android:textSize="@dimen/font_subtitle"
-		    android:text="@string/dsn_hashkey_title"
-		    android:textColor="@color/colorSubTitle"
-		    />
-
-		<TextView
-		    android:id="@+id/tv_hashkey_content"
-		    android:layout_marginTop="4dp"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:textSize="@dimen/font_subcontent"
-		    android:textColor="@color/colorSubContent"
-		    android:text="QmVNVJPoUc4t7VRBcQFh2mDxsjDdZMidZi4pSHR2jzF6qvTextView" />
-	    </LinearLayout>
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:background="@color/colorBackgroundGray"
+        android:orientation="vertical">
 
-	    <RelativeLayout
-		android:layout_width="match_parent"
-		android:layout_height="48dp"
-		android:layout_marginTop="16dp"
-		android:background="@color/colorBackgroundWhite"
-		android:gravity="center_vertical"
-		android:paddingEnd="@dimen/space_normal"
-		android:paddingStart="@dimen/space_normal">
-
-		<TextView
-		    android:id="@+id/tv_mimetype_title"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:text="@string/dsn_mimetype_title"
-		    android:textSize="@dimen/font_subtitle"
-		    android:textColor="@color/colorSubTitle"
-		    />
-
-		<TextView
-		    android:id="@+id/tv_mimetype_content"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:layout_alignParentEnd="true"
-		    android:layout_alignParentTop="true"
-		    android:textSize="@dimen/font_subcontent"
-		    android:text="img"
-		    android:textColor="@color/colorSubContent"
-		    />
-	    </RelativeLayout>
-
-	    <RelativeLayout
-		android:layout_width="match_parent"
-		android:layout_height="48dp"
-		android:layout_marginTop="1dp"
-		android:gravity="center_vertical"
-		android:background="@color/colorBackgroundWhite"
-		android:paddingEnd="@dimen/space_normal"
-		android:paddingStart="@dimen/space_normal">
+        <android.support.v7.widget.Toolbar
+            android:id="@+id/toolbar"
+            android:layout_width="match_parent"
+            android:layout_height="?android:attr/actionBarSize"
+            android:background="?android:attr/colorPrimary"
+            android:elevation="8dp"
+            android:theme="?actionBarTheme"
+            app:popupTheme="@style/popup_theme">
+            <com.android.documentsui.DropdownBreadcrumb
+                android:id="@+id/dropdown_breadcrumb"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginStart="4dp"
+                android:popupTheme="?actionBarPopupTheme"
+                android:background="@android:color/transparent"
+                android:overlapAnchor="true" />
+        </android.support.v7.widget.Toolbar>
 
-		<TextView
-		    android:id="@+id/tv_size_title"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:text="@string/dsn_size_title"
-		    android:textSize="@dimen/font_subtitle"
-		    android:textColor="@color/colorSubTitle"
-		 />
 
-		<TextView
-		    android:id="@+id/tv_size_content"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:layout_alignParentEnd="true"
-		    android:layout_alignParentTop="true"
-		    android:textSize="@dimen/font_subcontent"
-		    android:text="100KB"
-		    android:textColor="@color/colorSubContent"
-		    />
-	    </RelativeLayout>
+    <LinearLayout
+        android:id="@+id/layout_file_hashcode_qrcode"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:background="@drawable/list_item_bg"
+        android:paddingStart="@dimen/space_normal"
+        android:paddingEnd="@dimen/space_normal"
+        android:focusable="true"
+        android:clickable="true"
+        android:orientation="vertical">
+            <RelativeLayout
+                android:layout_height="38dp"
+                android:layout_width="fill_parent"
+                android:layout_marginTop="10dip">
+                <TextView
+                    android:textSize="@dimen/font_subtitle"
+                    android:textColor="@color/colorSubTitle"
+                    android:id="@+id/tv_hashkey_title"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/dsn_hashkey_title"
+                    android:layout_centerVertical="true" />
+                <ImageView
+                    android:layout_width="@dimen/icon_small_size"
+                    android:layout_height="@dimen/icon_small_size"
+                    android:src="@drawable/qrcode"
+                    android:id="@+id/iv_qrcode"
+                    android:layout_centerVertical="true"
+                    android:layout_alignParentEnd="true" />
+            </RelativeLayout>
+                <TextView
+                    android:id="@+id/tv_hashkey_content"
+                    android:layout_width="wrap_content"
+                    android:layout_height="30dp"
+                    android:maxLines="1"
+                    android:ellipsize="end"
+                    android:textSize="@dimen/font_subcontent"
+                    android:textColor="@color/colorSubContent"/>
+    </LinearLayout>
 
-	    <RelativeLayout
-		android:layout_width="match_parent"
-		android:layout_height="48dp"
-		android:layout_marginTop="1dp"
-		android:gravity="center_vertical"
-		android:background="@color/colorBackgroundWhite"
-		android:paddingEnd="@dimen/space_normal"
-		android:paddingStart="@dimen/space_normal">
+        <FrameLayout
+            android:background="@color/colorBackgroundWhite"
+            android:layout_width="fill_parent"
+            android:layout_height="48.0dip">
+            <RelativeLayout
+                android:id="@+id/layout_file_hashcode_qrcode"
+                android:background="@drawable/list_item_bg"
+                android:focusable="true"
+                android:clickable="true"
+                android:layout_width="fill_parent"
+                android:layout_height="48.0dip"
+                android:gravity="center_vertical"
+                android:paddingStart="@dimen/space_normal"
+                android:paddingEnd="@dimen/space_normal">
+            <TextView
+                android:id="@+id/tv_blockcount_tilte"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/dsn_blockcount_title"
+                android:textSize="@dimen/font_subtitle"
+                android:textColor="@color/colorSubTitle"/>
+            <TextView
+                android:id="@+id/tv_blockcount_content"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_alignParentEnd="true"
+                android:layout_alignParentTop="true"
+                android:textSize="@dimen/font_subcontent"
+                android:text="23"
+                android:textColor="@color/colorSubContent"/>
+            </RelativeLayout>
+            <LinearLayout
+                android:background="@color/colorBackgroundWhite"
+                android:layout_width="fill_parent"
+                android:layout_height="1.0dip"
+                android:paddingStart="@dimen/space_normal"
+                android:paddingEnd="@dimen/space_normal">
+                <View
+                    android:background="@color/colorBackgroundGray"
+                    android:layout_width="fill_parent"
+                    android:layout_height="1.0dip" />
+            </LinearLayout>
+        </FrameLayout>
 
-		<TextView
-		    android:id="@+id/tv_name_title"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:text="@string/dsn_name_content"
-		    android:textSize="@dimen/font_subtitle"
-		    android:textColor="@color/colorSubTitle"
-		    />
+        <RelativeLayout
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_marginTop="16dp"
+            android:background="@color/colorBackgroundWhite"
+            android:gravity="center_vertical"
+            android:paddingEnd="@dimen/space_normal"
+            android:paddingStart="@dimen/space_normal">
+            <TextView
+                android:id="@+id/tv_mimetype_title"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/dsn_mimetype_title"
+                android:textSize="@dimen/font_subtitle"
+                android:textColor="@color/colorSubTitle"/>
+            <TextView
+                android:id="@+id/tv_mimetype_content"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_alignParentEnd="true"
+                android:layout_alignParentTop="true"
+                android:textSize="@dimen/font_subcontent"
+                android:textColor="@color/colorSubContent"/>
+        </RelativeLayout>
 
-		<TextView
-		    android:id="@+id/tv_name_content"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:layout_alignParentEnd="true"
-		    android:textSize="@dimen/font_subcontent"
-		    android:layout_alignParentTop="true"
-		    android:text="zzz.jpg"
-		    android:textColor="@color/colorSubContent"
-		    />
-	    </RelativeLayout>
-	    <RelativeLayout
-		android:layout_width="match_parent"
-		android:layout_height="48dp"
-		android:layout_marginTop="1dp"
-		android:gravity="center_vertical"
-		android:background="@color/colorBackgroundWhite"
-		android:paddingEnd="@dimen/space_normal"
-		android:paddingStart="@dimen/space_normal">
+        <FrameLayout
+            android:background="@color/colorBackgroundWhite"
+            android:layout_width="fill_parent"
+            android:layout_height="48.0dip">
+            <RelativeLayout
+                android:layout_width="match_parent"
+                android:layout_height="48dp"
+                android:layout_marginTop="1dp"
+                android:gravity="center_vertical"
+                android:background="@color/colorBackgroundWhite"
+                android:paddingEnd="@dimen/space_normal"
+                android:paddingStart="@dimen/space_normal">
+                <TextView
+                    android:id="@+id/tv_size_title"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/dsn_size_title"
+                    android:textSize="@dimen/font_subtitle"
+                    android:textColor="@color/colorSubTitle"/>
+                <TextView
+                    android:id="@+id/tv_size_content"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_alignParentEnd="true"
+                    android:layout_alignParentTop="true"
+                    android:textSize="@dimen/font_subcontent"
+                    android:textColor="@color/colorSubContent"/>
+            </RelativeLayout>
+            <LinearLayout
+                android:background="@color/colorBackgroundWhite"
+                android:layout_width="fill_parent"
+                android:layout_height="1.0dip"
+                android:paddingStart="@dimen/space_normal"
+                android:paddingEnd="@dimen/space_normal">
+                <View
+                    android:background="@color/colorBackgroundGray"
+                    android:layout_width="fill_parent"
+                    android:layout_height="1.0dip" />
+            </LinearLayout>
+        </FrameLayout>
 
-		<TextView
-		    android:id="@+id/tv_createtime_title"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:text="@string/dsn_createtime_title"
-		    android:textSize="@dimen/font_subtitle"
-		    android:textColor="@color/colorSubTitle"
-		    />
+        <FrameLayout
+            android:background="@color/colorBackgroundWhite"
+            android:layout_width="fill_parent"
+            android:layout_height="48.0dip">
+            <RelativeLayout
+                android:layout_width="match_parent"
+                android:layout_height="48dp"
+                android:layout_marginTop="1dp"
+                android:gravity="center_vertical"
+                android:background="@color/colorBackgroundWhite"
+                android:paddingEnd="@dimen/space_normal"
+                android:paddingStart="@dimen/space_normal">
+                <TextView
+                    android:id="@+id/tv_name_title"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/dsn_name_content"
+                    android:textSize="@dimen/font_subtitle"
+                    android:textColor="@color/colorSubTitle"/>
+                <TextView
+                    android:id="@+id/tv_name_content"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_alignParentEnd="true"
+                    android:textSize="@dimen/font_subcontent"
+                    android:layout_alignParentTop="true"
+                    android:text="zzz.jpg"
+                    android:textColor="@color/colorSubContent"/>
+            </RelativeLayout>
+            <LinearLayout
+                android:background="@color/colorBackgroundWhite"
+                android:layout_width="fill_parent"
+                android:layout_height="1.0dip"
+                android:paddingStart="@dimen/space_normal"
+                android:paddingEnd="@dimen/space_normal">
+                <View
+                    android:background="@color/colorBackgroundGray"
+                    android:layout_width="fill_parent"
+                    android:layout_height="1.0dip" />
+            </LinearLayout>
+        </FrameLayout>
 
-		<TextView
-		    android:id="@+id/tv_createtime_content"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:layout_alignParentEnd="true"
-		    android:layout_alignParentTop="true"
-		    android:textSize="@dimen/font_subcontent"
-		    android:text="2018-09-10"
-		    android:textColor="@color/colorSubContent"
-		    />
-	    </RelativeLayout>
-	    <RelativeLayout
-		android:layout_width="match_parent"
-		android:layout_height="48dp"
-		android:layout_marginTop="1dp"
-		android:gravity="center_vertical"
-		android:background="@color/colorBackgroundWhite"
-		android:paddingEnd="@dimen/space_normal"
-		android:paddingStart="@dimen/space_normal">
-		<TextView
-		    android:id="@+id/tv_synctime_title"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:text="@string/dsn_synctime_title"
-		    android:textSize="@dimen/font_subtitle"
-		    android:textColor="@color/colorSubTitle"
-		    />
-		<TextView
-		    android:id="@+id/tv_synctime_content"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:layout_alignParentEnd="true"
-		    android:layout_alignParentTop="true"
-		    android:textSize="@dimen/font_subcontent"
-		    android:text="2018-09-10"
-		    android:textColor="@color/colorSubContent"
-		    />
-	    </RelativeLayout>
+        <FrameLayout
+            android:background="@color/colorBackgroundWhite"
+            android:layout_width="fill_parent"
+            android:layout_height="48.0dip">
+            <RelativeLayout
+                android:layout_width="match_parent"
+                android:layout_height="48dp"
+                android:layout_marginTop="1dp"
+                android:gravity="center_vertical"
+                android:background="@color/colorBackgroundWhite"
+                android:paddingEnd="@dimen/space_normal"
+                android:paddingStart="@dimen/space_normal">
+                <TextView
+                    android:id="@+id/tv_createtime_title"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/dsn_createtime_title"
+                    android:textSize="@dimen/font_subtitle"
+                    android:textColor="@color/colorSubTitle"/>
+                <TextView
+                    android:id="@+id/tv_createtime_content"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_alignParentEnd="true"
+                    android:layout_alignParentTop="true"
+                    android:textSize="@dimen/font_subcontent"
+                    android:text="2018-09-10"
+                    android:textColor="@color/colorSubContent"/>
+            </RelativeLayout>
+            <LinearLayout
+                android:background="@color/colorBackgroundWhite"
+                android:layout_width="fill_parent"
+                android:layout_height="1.0dip"
+                android:paddingStart="@dimen/space_normal"
+                android:paddingEnd="@dimen/space_normal">
+                <View
+                    android:background="@color/colorBackgroundGray"
+                    android:layout_width="fill_parent"
+                    android:layout_height="1.0dip" />
+            </LinearLayout>
+        </FrameLayout>
 
-	    <RelativeLayout
-		android:layout_width="match_parent"
-		android:layout_height="48dp"
-		android:layout_marginTop="16dp"
-		android:gravity="center_vertical"
-		android:background="@color/colorBackgroundWhite"
-		android:paddingEnd="@dimen/space_normal"
-		android:paddingStart="@dimen/space_normal">
+        <FrameLayout
+            android:background="@color/colorBackgroundWhite"
+            android:layout_width="fill_parent"
+            android:layout_height="48.0dip">
+            <RelativeLayout
+                android:layout_width="match_parent"
+                android:layout_height="48dp"
+                android:layout_marginTop="1dp"
+                android:gravity="center_vertical"
+                android:background="@color/colorBackgroundWhite"
+                android:paddingEnd="@dimen/space_normal"
+                android:paddingStart="@dimen/space_normal">
+                <TextView
+                    android:id="@+id/tv_synctime_title"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/dsn_synctime_title"
+                    android:textSize="@dimen/font_subtitle"
+                    android:textColor="@color/colorSubTitle"/>
+                <TextView
+                    android:id="@+id/tv_synctime_content"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_alignParentEnd="true"
+                    android:layout_alignParentTop="true"
+                    android:textSize="@dimen/font_subcontent"
+                    android:text="2018-09-10"
+                    android:textColor="@color/colorSubContent"/>
+            </RelativeLayout>
+            <LinearLayout
+                android:background="@color/colorBackgroundWhite"
+                android:layout_width="fill_parent"
+                android:layout_height="1.0dip"
+                android:paddingStart="@dimen/space_normal"
+                android:paddingEnd="@dimen/space_normal">
+                <View
+                    android:background="@color/colorBackgroundGray"
+                    android:layout_width="fill_parent"
+                    android:layout_height="1.0dip" />
+            </LinearLayout>
+        </FrameLayout>
 
-		<TextView
-		    android:id="@+id/tv_blockcount_tilte"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:text="@string/dsn_blockcount_title"
-		    android:textSize="@dimen/font_subtitle"
-		    android:textColor="@color/colorSubTitle"
-		    />
+        <FrameLayout
+            android:background="@color/colorBackgroundWhite"
+            android:layout_width="fill_parent"
+            android:layout_height="48.0dip">
+            <RelativeLayout
+                android:layout_width="match_parent"
+                android:layout_height="48dp"
+                android:layout_marginTop="1dp"
+                android:gravity="center_vertical"
+                android:background="@color/colorBackgroundWhite"
+                android:paddingEnd="@dimen/space_normal"
+                android:paddingStart="@dimen/space_normal">
+                <TextView
+                    android:id="@+id/dsn_encrypt_title"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="@string/dsn_encrypt_title"
+                    android:textSize="@dimen/font_subtitle"
+                    android:textColor="@color/colorSubTitle"/>
+                <TextView
+                    android:id="@+id/tv_encrypt_content"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_alignParentEnd="true"
+                    android:layout_alignParentTop="true"
+                    android:textSize="@dimen/font_subcontent"
+                    android:text="Yes"
+                    android:textColor="@color/colorSubContent"/>
+            </RelativeLayout>
+            <LinearLayout
+                android:background="@color/colorBackgroundWhite"
+                android:layout_width="fill_parent"
+                android:layout_height="1.0dip"
+                android:paddingStart="@dimen/space_normal"
+                android:paddingEnd="@dimen/space_normal">
+                <View
+                    android:background="@color/colorBackgroundGray"
+                    android:layout_width="fill_parent"
+                    android:layout_height="1.0dip" />
+            </LinearLayout>
+        </FrameLayout>
 
-		<TextView
-		    android:id="@+id/tv_blockcount_content"
-		    android:layout_width="wrap_content"
-		    android:layout_height="wrap_content"
-		    android:layout_alignParentEnd="true"
-		    android:layout_alignParentTop="true"
-		    android:textSize="@dimen/font_subcontent"
-		    android:text="23"
-		    android:textColor="@color/colorSubContent"
-		    />
-	    </RelativeLayout>
- 	</LinearLayout>
+    </LinearLayout>
 </android.support.design.widget.CoordinatorLayout>
diff --git a/res/layout/fragment_dsn_directory.xml b/res/layout/fragment_dsn_directory.xml
index d3d40e5..24f1cd7 100644
--- a/res/layout/fragment_dsn_directory.xml
+++ b/res/layout/fragment_dsn_directory.xml
@@ -27,7 +27,7 @@
         android:layout_height="match_parent"
         android:background="@color/directory_background"
         android:outlineProvider="bounds"
-	android:visibility = "invisible"
+        android:visibility = "invisible"
         android:elevation="4dp"
         android:orientation="vertical">
 
@@ -57,11 +57,12 @@
 
     </com.android.documentsui.dirlist.AnimationView>
     <com.android.documentsui.widget.AVLoadingIndicatorView
-	android:id="@+id/avi"
-	android:layout_width="wrap_content"
-	android:layout_height="wrap_content"
-        android:gravity="center"
-        android:layout_gravity="center"
-	app:indicatorColor="#3C78C2"
-	style="@style/AVLoadingIndicatorView"/>
+    android:id="@+id/avi"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:gravity="center"
+    android:layout_gravity="center"
+    app:indicatorColor="#3C78C2"
+    android:visibility = "visible"
+    style="@style/AVLoadingIndicatorView"/>
 </FrameLayout>
diff --git a/res/menu/activity.xml b/res/menu/activity.xml
index ce51e75..8645491 100644
--- a/res/menu/activity.xml
+++ b/res/menu/activity.xml
@@ -49,6 +49,12 @@
             android:title="@string/menu_list"
             android:icon="@drawable/ic_menu_view_list"
             android:showAsAction="always" />
+
+        <item
+            android:id="@+id/option_menu_scan"
+            android:title="@string/menu_grid"
+            android:icon="@drawable/ic_scan_white"
+            android:showAsAction="always" />
         <item
             android:id="@+id/option_menu_new_window"
             android:title="@string/menu_new_window"
diff --git a/res/menu/dsn_files_activity.xml b/res/menu/dsn_files_activity.xml
index 1b5e2f7..5102240 100644
--- a/res/menu/dsn_files_activity.xml
+++ b/res/menu/dsn_files_activity.xml
@@ -26,17 +26,22 @@
 <!-- This group is being hidden when searching is in full bar mode-->
     <group android:id="@+id/group_hide_when_searching">
         <item
-            android:id="@+id/option_menu_delete"
-            android:title="Delete"
-            android:icon="@drawable/ic_debug_menu"
+            android:id="@+id/option_menu_preview"
+            android:title="Preview"
+            android:icon="@drawable/ic_menu_view_grid"
             android:visible="false"
-            android:showAsAction="never"
-            />
+            android:showAsAction="never" />
         <item
             android:id="@+id/option_menu_download"
             android:title="Download"
             android:icon="@drawable/ic_menu_view_grid"
             android:visible="false"
             android:showAsAction="never" />
+        <item
+            android:id="@+id/option_menu_delete"
+            android:title="Delete"
+            android:icon="@drawable/ic_debug_menu"
+            android:visible="false"
+            android:showAsAction="never"/>
     </group>
 </menu>
diff --git a/res/raw/beep.ogg b/res/raw/beep.ogg
new file mode 100644
index 0000000000000000000000000000000000000000..14199476a89093b575f6ef388febe417b5cd003b
GIT binary patch
literal 6401
zcmb7Id010N*Pk205(EqoRuRJ@5(Fd=lu+y&Srj551j3F&fGPqigt!*HtO5!mghdDx
zEUN{@B`R7mD2oe3APu0XY_eFa;)-vz@=b#6(|&(^@B7_n?%Z?F%$#%2ne&@DbGK~Y
z?gKF3>or1gvXGE8-;~dYKC*Xr0xOy=VIa<pk_P~DTM+5<DzZf~@~=xWQquBoHIsEq
zT^Ig-os?OWV+WfzZ25*5zT21MM`Tf0#9(VHD_b&|ye^bz$_i&kMG|-KA_he7*<raQ
zVf!jJF*cgzC;bGHL=PgnD96On$qxYv0HB8M+U;m>9uojO0F{mFiVoemG5_>Xa{VU4
zp-c%i(YUGiU}g)XUf!tFJ#-)P*hEUC1^`%qk`zi4Mjd~>F|V&PrRuF~)+M3Rv#hu}
z>FWz01<e{1Ja+tb{j|P<a-b}LKB6fYq!Add2I+rRq?!^|HmSCRb&pi1$L=O~5mQy{
zXQ~Ul9C4&-FS=PnHJ3rR7zkp&ydnRD{c6KUVjA8N3i-2=+ChZh0-2FgrbP0hyhXE!
z0F_woc9L-ayk1YAUe9a22dXQ*)mHXdTZkC8J~r!_zAj>4rav<@bYGl!Z=AR&ZqQFk
z_{9ZYjvM}Gk(y3KK&25i--wiNNXnnE%g3f=G-5!c#3hxc*%NlT&s=j?M(2NbplEwm
zY5l3vnT85QX%~RNE|P0>fA;kL-0cVQrFCgtbZPB>TWCA(m;oB}Wmml3V%d~nEHCx&
z9RTN)#xU+mFyF+cbg>;aB|3K{y5Hsc-sOiZ`EwHBw8M+0Ztmja&{g2@K;8C%h|;6(
z;Z5-n{TIcDkSvWCXox}icSSo<1)IEZsasGeR=Y~UNoi3N?2uXYj9A)R`nHFvQaV}L
zKqwQnW%-t^YH27bV+*O%yjY>m1dlBw-8<D$d8)UREp$^Vty!cFsFle#HS|NC&NNS@
zQzsnui|#L#Z+I90#|HM6PSv*%AeF@}Tg7kjU6dyk$`&?k<q6xUV{k;)qq3M5Tqvae
z9m#vygOl)}-meu-8a^~QZ{b7Qo#iRSq+B@`!JyWlKtJ(>N<k(04yjr{CwC*gA=Qha
zv#KUBMQS+_fHeHyqu3xro0Vx$$4gK&tFO+_HoIqfvD^B-xuj~mEwrC)zKwTMB46sK
zo7;;0B69ds73{NA*O(gqK+x(M7~rIuMMS|#B}V3LkkgUkBcmh%qM|ZI@$VBiXZ%2Q
zdEej4gV%a6m>1(&8q7@py>WrXoZ&0!p+lUJ!K9JFoNZbeQGrGOD2t{;OMnDUQaEy1
z$H`s1R8L3T;sk$1&Zc-m*Gav*Cyh5>F!ty-?|DPn@|M!4?gGQbM<cXPgCo+6@>v@y
zvW*fkqr`io9$t<LzLFGpIca46Z)K44cjQ3W7*ca5T>puj+;O{HBe#6xz<d)aavDxm
zJa0JtzmQY8BfG97yDl?(Iy2Wat0+3F^i0d?*n4MZul>jJ7jhtAU~yp>yZi$=0<xYH
z1kVL?kGG39uJ41ZL!yh;-zNY7L7viP$x>qM&9D$NY{d)<rtf;@f4amHXhFvoN>^HC
z`;WSZ?v}LYAKG!;QR(1p2|M>-&vC;$@h|W;nFp2>8etFQoN~^LhfZ?=c(`_Ir|LO%
z8%*=6JsHn<KlXd?<gvN-^yM{#n0x#meOa6NYlT$!dYo~Of9a7oonNcF1TF@9;N6T@
zR1Q=H&IrIO7}Vr3TuD>B1Qk*ZFG6Tg%VpoAPV!Rw-5Pl8ek$oCL-Lv+bbHS86;es%
zX>eP^=)v1O4MGJA;xRy_>$QWM$l1G};{DFOkF&lnG1N`u?xXI)6gzt}J^cA`eZEn_
z{S?tJ@YUAam+5UA_t2L){J~vR<S{6Y^Ja2_FUN)Nj~kv}FS-O@<DMjj2Jee|I3E=}
zn6pVL${&j2c=(Isd^mBT>MnyCO#dPmabc8y5ocRr)RRHyK8}l+8|ux83N8#C*&7u&
z?=kqE!z@aNtz%a>q1wAf)>S}7+hD7I)I+UZPu3nDo=@K{{i;5uZJ%$bh{=I^hX*90
z{P|Ik^RO^(#6R@m2V3vN&^~5VU?MZnFY4iZXy6BqH!~@?FiO%oA2*_v@o*q%EHN}x
zBH1tSL(=eI;p6~k?4!HrGBl7Q;v|iH;A}s|3H|6Y_&$kQloY{_+V(Mhq~TNN>*Ht6
z%%1s8@uu1RTg^+ZzkS@ghRYfL824oR<JJ?eCq8$cj2XT~p1sU|+<Mmh=3AS?Q2_^Q
zqlar}f4}zpTI-tGYvjkR=Lk&kATxMvhPW_&Li6y%P|}#)#=jJW4<(K4KODZlV(@a#
z*oUNhv9lXjeE-9n?rS-}ed<j3WIw$xS2(AHg8?Op4XY|8g6;)Fkf{#B@ChnpSp$X=
zTn}ng9O<eNc<brv$Zj`WO|>T7&4Q)mI90;!rjn|-MUEtkbhV%*HSL=8=qA2j%ub5|
zJUyn0tL;Rxs2$kp-Xzu~%Neje=~Fzoy1|A4>*@ML6~?bbxSj7jUrmUZ<Z+ek&6cNe
z>1O0YE=#GQ-H(yYul9|IIX|fxA*|wRZZ<m)8{){5+7aDUiE`ee@&WiQelS3xD5_}#
z6h$I+bW`1+DEk>xIKthcLzAA>1Vxb=I-n?vjsPb&iy|(|g48j@>Tc;M3YM?p=h2VD
z&ka6Ky)v*<xu!i}QTcKH2W^RR?agMka73K#hexbND!(XZ=lLnkhzI=1ff(V9x`CY@
z=O-Vry4O!>NA|SHFLi_lYC4g~mj`ynk*D;&Dklv<Q5FM_V1rb-SQpwcFa&)y2t_q?
zl*S0#x=JFpSPbYzbg%Cyis@;YFAdIvP*;Lk9=60w4#E~Eg>9N?hjyBrK_{=Em)Ksy
zW|(#IQuF8?C2TzX9xv64PCo@HHxf6WPH#$Q(CH0)2wO!7Y-4-50eY2^MTcev(6)H<
z`){4SZKEEZH-4b*B7&&gE8+A}nBvP8iyRoh5{@rZ%;7vymn24mF!JZ6eK-&f9->4E
zXZS;sh{7D?M8S1FoFnB7#6<*1I1ew!g;IAtfr!w`2rqeb?d7M|HA-D`?lM52t_M)X
z*ns6@)jQ0arC%inK)8~loI$#hBg_i9j;^GY0E7t;Koq1|d+oSG2Sk`@65E4fn&4*1
zYJe4_GU(FR|ErSjs{ijw1I+l3fzgGq+rKKTa*0Sz&uGMgTQDh)fH7+S+_?G|t4ZxN
z2E(nUa3gt|$jxWao0vj3*P5DvpkwC~JmD<xHG_}CU<}%6(WxEr0!C?23>i|UH8t81
zjpTtKC$|Q^cEoYp!5{|g0<CG8&u1JXcZS5gY$+aKHS(umcCwzY8PQ}r{g^!`=`7^K
z?AxoUBOvB1RetOc0v;=?06cE3usJ``&rUZ)>Lz1=(lW`NJhlo1urr+u#YppESJGEr
zTHaS)6_;VX$Xm(vf)JJTgFO1(#jz5nEl>Q)Bh^UcNm@xYFzGg3%vQLt^(&?J7sdFq
zUp0gNbp#xSGmwszR8?sbDH2MeS4x@H5CGUS3b({CY<Z+_U|Nnz$bKLVe3&W|g+Z~T
zjS@#^+#$9TGZaZ3JiZbsRj<~al*TO-k~1<3G=rCD$iQqCFG-y+$rw|sJOs!q;23}w
zo?PXWrhxxZAh>$<5<KlVMrOD=o6BY4#58a6a$s(0^-PAA(Yf(ahiszGXo}@ad%Pn)
z1>Zgn6kP>vxOEP%Ggdtw#g?CD$V(4waKT&(K$jd|wNG!;(Jpz{%sUEhZZLxaU<e50
zfgl{?>`dwE8+(nY8Cp9s)TB+43X5IL`Xz@%ELM8z!zLOoHcL)@5`Ho7WsxSucEM=D
zVu1p0i-pzjNi;KO*e4z=)2=LQ4Cd%_E}UH^xZ>1-aAZ``o1CS$^BWnDbCm0Avxm2!
zwqT)UU9;v~*}Cp9gi^8F1ywqI50(F^Y@5am`iT*>c?QKJmqxZ$|Mo@jO-{glwM!1=
znO$a+ycMiWlgONXTEPD2id|kbyW3giUvfPnV<;CaC5Cr8t^mr*G)G$s<^YH_2eG{i
ze6-@~a)7HM0wG%^01ZZ0AsC=u30!enBfaN}I7lKwJmV*mZC|ea4Wh+!tSFH|4Mxi^
zdCM06gr+XA59DNs*6%aIC>*O#1)7Aa>W+Fl=6-A)_eTxiyN9wi3Ql>@Xs$G`%%j=h
zY}rizS=+;j-&{NJs3-2)jZ4SNi;J&xtd4(G^6FFTtEGF%&*q9>$Sj;?m)zn`@dp|;
z$nU~#e4f9rPC29Oe5Q?{ViM?Z*V9^P{5yH%M4_K<%hqY0k8YTwBS<LFcuq9OC>=Ld
zy6bS!vB`R&>3YyWDR7cSZ>fMa_g0)h^(;Ysj>v|3<l9Ize5=g2O|6fU(PpAu!sf$E
z4KI=|D2dF!-13Oke(Ku?fJ(2xCB-vL77)#w(=GvUQJDgF+O>wrG5DgsAUD&FRU3_n
z6<}hKJ=<<!O~E5d9zYULnAzN@)@O{~Cn1%D$c$@Yb~kihQBt_43Gi56WEu55vj_ux
zLB`$asY+D>ZA5L98;{qlbxF1XK~v6XrUHhbpyD{!;jLJu#y!n#l%<Oe6f6}yofY@o
z7(D|7OBH1Gf<H8C;fPMhRH<<?*zmob`JKd$1G0)r89&|hRkl0&uYn!zWj|_gu_>R8
z0;%#T$$JzF`#6f>w2zyfr8tlKs7DAwBGVkL5gFqH_Q#O(PF&<dk1ETpmtc=W4_Bz-
z#w!qZxN^yw$zZa~6ackKuS~x*J{{74r%rc$#@w=#JI;!up)<f96kCMV3i~u)2jt)n
z5%drkLx7znDr-z5eh(3bVn6b+lr$9V5A8;lp_@@tq#P(91n?Gs>SU~IrNtch?BD?i
zvbc>QKf6Ye11?`LB6?j925Ft`h~RxV(vkm3whe@B!<5dCW~)U7@j%7~Z|;wR^@1Sl
z+|@23%+lu@@!8Sdir9{hDzoRN*{Mb}QWh7J?8G$9E;}=BXAZoao#S~$M1lYZ_80*a
z3{5`le%_E~8T0;d-L)*c_-DUO?5Y5HCVjC9TDfjpPbqvmIp_R?otlwJ)7Hbdgn-AG
z)4qF6^1bkp%_l<p6fw!FCPM}E9B0<ieOf22_g!44yW%EQ_xDeqz6%p}efP^Vty>F9
z<>~v7FF&_Fu0(r@LvAar?jAEg@6a>;;E#JM4F|=Zdw@!F-cIEZ1UfBEuCy7h8J1`u
zq6xRl2?YU5=7^EN(;Y{<4I}IXPi8H+0{k(?z=Vd(aQEQemPPo+&&`nD9XSC;313`)
zQO;Oa)+Bf@GBh1B0AW;zne@)xAqY4_xP%#8lIHGz#hkFNKhqHTLqAM)Hk*A)6WK6)
z#7;KHnUGp}bqk8A^2Y3+^v<rdPS5peW@J}Z)TjD9Zp2(o7zZ62v3o2v|443-`yHW`
zK5KiOe-Ce!ay}2UQgfQwhPPtzjcjxDb-M6F!S$~;V@+;{7~lSa>Z^zMe=^juCW8LA
z+2zTIYWPX_gh&tK)E^hYr99Ostv73M#Bt!IXyf?i3IbTG!M8VBW7P<FOV<MhDI<4h
zgBsf|!Btj%l(v&-+bi*sxj;>2$=v&8K$Er~qVPK~B-pluw&n9GL|I({%}S8Lj_Qss
z4_j7=lSG#qAclk(s%~|g8CeR|D2<mWzCc+epU0QCH2`pb%4%hR?_;&hFua~|1JO?5
za^Yzua21DlZCZWn7T;91l>KW8UMJ}8QShX018upX7WWoCnZZ?+S5zeAQ8$phEa}OU
z7zN>41}ajw@LFRnt9Y7mw_1FascFCJg3rwP`?aheMk1VmPHD>_izc9L>Z$Vu*J=Lr
z_G-_lnM3WjGKpJ*Y$L2v!k5;yv3S8=Ka$!#H$FGMzQbnpb0>?a^V{;1_%S6_HA<Fi
zZ)fkSM2}EQ!BWiU93wEf4@jV>4F4m9=mpIM=V|Q{`h}Ntyn1@k=ef|V3_1;T>kfgJ
zuSO7TucpE+MF8rN@3it@h{cA0=H%;T=qykhoyI1HVQ_N=R2tZYoP~dy+))g%P!3bM
zp=^a)!u7+v{TW|oBLTrh_HbKRbI^E4U|_T9$Il%IcY~<^S|X_}?@=@YlG@{ELR`Gp
z?w}@jR8r1jykxw-J-wRFjfv0B_r|64es&aW5JwZPo{PbyR4Uq;Dic<ED$AyfZcIBJ
zHj#b0LV46~ohm{<Krp?xk<it$XSr;pC+$(j56cp-YJvV=e&^mkpb>AJIoU3pu2-XZ
zzgQY>l@hrw9^2{}!EFvO%y#<_&MnjCTI~JOswz_;>#Vng{CVXF03sbU+u+-;2=pSh
zTh<b^pB0uy|70iqDXW4P)W|qU!m81u*Iu%4VFzBA?10Z4B{WiIw+2w(jv?YPm`d|0
zR7D_5(*y{Lry+Uz0Hxpoa!F1fT~h~8pN~Yb_0yK87Dd&kE#!Mw0<=&ZHsgL%6ZCc|
z%DZ&%c{Q4Cz422-H3C|Is9rg1R~&;^Y}b#@a(ag6_+ado5#%QYBz#7Zmz}>CFU4tj
z<w>IBSa<R`A=ayMDAUXCZ50s8;RP;0a0E3a2!DQtJgGYRWkW>yKDE?|p1MOSAm8}n
zi@NUwD7S%ZZF=7BoMHwTKT-b6_3V=dDC_!3Z>DyDL;3R5a~9{j1jbtanc90rZga6&
z<;d)nT7h78J_lCYZN}dlouf3yzH|R@eX9zQ_-=0K`G~4v<Mjut0r+KFY$A|j$Q=5{
z0|h&1lqCV^4OKJnU|~W<l0e|at^&{R_rbrmG|cxp#bAwWrIsXpC|Lz)SNGpM3Ty_V
zLPdXUe05{~-Mg~{ZS$x*Lr;qpyzsV+TdK|{6JlGHH^k`bzB~No0yiyVHD{zJe8chY
zD+wF!r(~{ad-V2&saRY<UU*t~k<pHf8Zj#0%VpVl9W)`6)#ixH_T<ftWsgQeFglRH
z7zQLTjyz2#KcHV;+W#-cn&)TQ(CKqWC;15)Hb>Htn(>I@6T1}Ez1vj`obs2sV{PvE
zvod0@x1n!sGTiAu-C5>z47|G-2;>ZncbLfn{5J_H`$;5~r_AIZmRg}t^Z=!H<P9kJ
znCi3o({%gV?^O-J0$!#1v&?~9`xQ4=p1r9U;BmXDnzfm-(xLW;IWU~4jn{9~n210S
zwmqE)X1^(-ZL2^Z)MMR`?%WO9O;Uy1uWHLuPIr+74$d>_C@RW1*8KgKy87vce*xdu
z)8}$V=hffY_=m_0%Pc`(*d*nfsI+q5{9ISPHj7$Hp(d=od8EgLsv;^rcr^X^zKP=9
z;`*S`5beano5(2XXwQw;m+R+OJ?N*77W<Lq^{p6jDuA}k?Tz;r((s`NR;`49SAzMi
Q!3(l<w0I|Y!;u01144^n5dZ)H

literal 0
HcmV?d00001

diff --git a/res/values-en-rGB/strings.xml b/res/values-en-rGB/strings.xml
index 819ac77..cc9827f 100644
--- a/res/values-en-rGB/strings.xml
+++ b/res/values-en-rGB/strings.xml
@@ -215,12 +215,13 @@
     <string name="continue_in_background" msgid="1974214559047793331">"Continue in background"</string>
     <string name="inspector_debug_section" msgid="3447621501565766900">"Debug info (dev only)"</string>
 
-
-    <string name="dsn_hashkey_title" msgid="3447621501565766956">"Object Hash-Key"</string>
-    <string name="dsn_mimetype_title" msgid="3447621501565766957">"File MIME-TYPE"</string>
-    <string name="dsn_size_title" msgid="3447621501565766958">"File Size"</string>
-    <string name="dsn_name_content" msgid="3447621501565766959">"Original File Name"</string>
-    <string name="dsn_createtime_title" msgid="3447621501565766960">"File CreateTime"</string>
-    <string name="dsn_synctime_title" msgid="3447621501565766961">"File SyncTime"</string>
-    <string name="dsn_blockcount_title" msgid="3447621501565766962">"Block Count"</string>
+    <string name="dsn_hashkey_title" msgid="3447621501565766956">"CID"</string>
+    <string name="dsn_mimetype_title" msgid="3447621501565766957">"MIME-TYPE"</string>
+    <string name="dsn_size_title" msgid="3447621501565766958">"Size"</string>
+    <string name="dsn_name_content" msgid="3447621501565766959">"Original Name"</string>
+    <string name="dsn_createtime_title" msgid="3447621501565766960">"Create Time"</string>
+    <string name="dsn_synctime_title" msgid="3447621501565766961">"Sync Time"</string>
+    <string name="dsn_blockcount_title" msgid="3447621501565766962">"Links"</string>
+    <string name="dsn_qrcode_title" msgid="3447621501565766963">"File HashCode"</string>
+    <string name="dsn_encrypt_title" msgid="3447621501565766963">"File Encrypt"</string>
 </resources>
diff --git a/res/values-zh-rCN/strings.xml b/res/values-zh-rCN/strings.xml
index 1298be8..d69f875 100644
--- a/res/values-zh-rCN/strings.xml
+++ b/res/values-zh-rCN/strings.xml
@@ -222,4 +222,6 @@
     <string name="dsn_createtime_title" msgid="3447621501565766960">"文件创建时间"</string>
     <string name="dsn_synctime_title" msgid="3447621501565766961">"文件同步时间"</string>
     <string name="dsn_blockcount_title" msgid="3447621501565766962">"分开的区块数目"</string>
+    <string name="dsn_qrcode_title" msgid="3447621501565766963">"文件Hash二维码"</string>
+    <string name="dsn_encrypt_title" msgid="3447621501565766964">"文件加密"</string>
 </resources>
diff --git a/res/values/colors.xml b/res/values/colors.xml
index 4092887..150ee9a 100644
--- a/res/values/colors.xml
+++ b/res/values/colors.xml
@@ -89,4 +89,13 @@
     <color name="colorBackgroundWhite">#FFFFFF</color>
     <color name="colorSubTitle">#666</color>
     <color name="colorSubContent">#999</color>
+    <color name="gray_btn_text">#bbbbbb</color>
+    <color name="gray_border">#c6c6c6</color>
+    <color name="color_secondary_text">#72000000</color>
+    <color name="viewfinder_mask">#60000000</color>
+    <color name="result_view">#b0000000</color>
+    <color name="possible_result_points">#c0ffbd21</color>  <!-- Android standard ICS color -->
+    <color name="colorAccent">#74a7f5</color>
+    <color name="black">#000000</color>
+    <color name="viewfinder_btn_bg">#20000000</color>
 </resources>
diff --git a/res/values/ids.xml b/res/values/ids.xml
new file mode 100644
index 0000000..4c0ccb4
--- /dev/null
+++ b/res/values/ids.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2008 ZXing authors
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ -->
+<resources>
+  <item type="id" name="decode"/>
+  <item type="id" name="decode_failed"/>
+  <item type="id" name="decode_succeeded"/>
+  <item type="id" name="launch_product_query"/>
+  <item type="id" name="quit"/>
+  <item type="id" name="restart_preview"/>
+  <item type="id" name="return_scan_result"/>
+</resources>
diff --git a/res/values/strings.xml b/res/values/strings.xml
index bfd40c4..efaa40a 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -422,5 +422,48 @@
 
     <!-- Title of inspector's debug info section. [CHAR LIMIT=48] -->
     <string name="inspector_debug_section">Debug info (dev only)</string>
-
+    <!-- strings about address code -->
+    <string name="title_address_qrcode">CID Code</string>
+    <string name="action_copy_address">Copy Address</string>
+    <string name="tip_success_copy">Success copy content to clipboard!</string>
+    <string name="button_product_search">Product search</string>
+    <string name="button_web_search">Web search</string>
+    <string name="button_custom_product_search">Custom search</string>
+    <string name="result_product">Found product</string>
+    <string name="button_open_browser">Open browser</string>
+    <string name="button_share_by_email">Share via email</string>
+    <string name="button_share_by_sms">Share via SMS</string>
+    <string name="button_search_book_contents">Search contents</string>
+    <string name="button_add_contact">Add contact</string>
+    <string name="result_address_book">Found contact info</string>
+    <string name="msg_default_mms_subject">Hi</string>
+    <string name="app_name">DSN File</string>
+    <string name="button_sms">Send SMS</string>
+    <string name="button_mms">Send MMS</string>
+    <string name="result_sms">Found SMS address</string>
+    <string name="confirm">Confirm</string>
+    <string name="msg_intent_failed">Sorry, the requested application could not be launched. The barcode contents may be invalid.</string>
+    <string name="button_add_calendar">Add to calendar</string>
+    <string name="result_calendar">Found calendar event</string>
+    <string name="button_dial">Dial number</string>
+    <string name="result_tel">Found phone number</string>
+    <string name="button_email">Send email</string>
+    <string name="button_book_search">Book Search</string>
+    <string name="result_isbn">Found book</string>
+    <string name="button_show_map">Show map</string>
+    <string name="tip_camera_permission">You have not authorized the camera yet. Please go to the settings page.</string>
+    <string name="tip_external_storage_permission">You have not authorized the external storage yet. Please go to the settings page.</string>
+    <string name="result_text">Found plain text</string>
+    <string name="button_get_directions">Get directions</string>
+    <string name="result_geo">Found geographic coordinates</string>
+    <string name="action_go_settings">Go Settings</string>
+    <string name="cancel">Cancel</string>
+    <string name="result_email_address">Found email address</string>
+    <string name="result_uri">Found URL</string>
+    <string name="title_capture_code">Scan</string>
+    <string name="close_slash">Close Flash</string>
+    <string name="open_slash">Open Flash</string>
+    <string name="msg_camera_framework_bug">Sorry, the Android camera encountered a problem. You may need to restart the device.</string>
+    <string name="button_ok">OK</string>
+    <string name="tip_scan_code_failed">Scan code failed!</string>
 </resources>
diff --git a/res/values/styles.xml b/res/values/styles.xml
index 59bc507..65b8e2c 100644
--- a/res/values/styles.xml
+++ b/res/values/styles.xml
@@ -45,7 +45,7 @@
 
         <item name="android:windowSoftInputMode">stateUnspecified|adjustUnspecified</item>
     </style>
-    <style name="DNSDocumentsTheme" parent="@style/Theme.AppCompat.Light.NoActionBar">
+    <style name="DSNDocumentsTheme" parent="@style/Theme.AppCompat.Light.NoActionBar">
         <item name="actionBarWidgetTheme">@null</item>
         <item name="actionBarTheme">@style/ActionBarTheme</item>
         <item name="actionBarPopupTheme">@style/ActionBarPopupTheme</item>
@@ -85,6 +85,17 @@
         <item name="android:textColor">@android:color/black</item>
     </style>
 
-
-
+    <style name="AppTheme.PopupOverlay" parent="ThemeOverlay.AppCompat.Light" />
+    <style name="AppTheme.AppBarOverlay" parent="ThemeOverlay.AppCompat.Dark.ActionBar" />
+    <style name="ToolbarTitleText" parent="@style/TextAppearance.Widget.AppCompat.Toolbar.Title"></style>
+    <!-- single gray button -->
+    <style name="ButtonGraySingle">
+        <item name="android:layout_width">match_parent</item>
+        <item name="android:layout_height">40dp</item>
+        <item name="android:stateListAnimator">@null</item>
+        <item name="android:textSize">@dimen/font_size_body</item>
+        <item name="android:textColor">@color/gray_btn_text</item>
+        <item name="android:textAllCaps">false</item>
+        <item name="android:background">@drawable/btn_gray_bg</item>
+    </style>
 </resources>
diff --git a/src/com/android/documentsui/BaseActivity.java b/src/com/android/documentsui/BaseActivity.java
index 64db20c..29277b1 100644
--- a/src/com/android/documentsui/BaseActivity.java
+++ b/src/com/android/documentsui/BaseActivity.java
@@ -40,6 +40,12 @@ import android.view.Menu;
 import android.view.MenuItem;
 import android.view.View;
 import android.widget.Toolbar;
+import android.widget.Toast;
+import android.widget.TextView;
+import android.support.v4.app.ActivityCompat;
+import android.Manifest;
+import android.text.format.Formatter;
+
 
 import com.android.documentsui.AbstractActionHandler.CommonAddons;
 import com.android.documentsui.Injector.Injected;
@@ -65,6 +71,9 @@ import com.android.documentsui.sidebar.RootsFragment;
 import com.android.documentsui.sorting.SortController;
 import com.android.documentsui.sorting.SortModel;
 import android.widget.LinearLayout;
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.view.LayoutInflater;
 
 
 import java.util.ArrayList;
@@ -72,6 +81,16 @@ import java.util.Date;
 import java.util.List;
 
 import javax.annotation.Nullable;
+import com.android.documentsui.DSN.util.PermissionUtil;
+import com.android.documentsui.DSN.ui.common.barcode.CaptureActivity;
+import com.android.documentsui.DSN.conmmon.ReqCode;
+import com.android.documentsui.DSN.ui.common.barcode.Intents;
+import com.android.documentsui.httpnetwork.ObjectMeta;
+import com.android.documentsui.DSN.util.CommonUtil;
+import com.android.documentsui.services.DownloadDocumentsFromDSNJob;
+
+import com.google.gson.JsonObject;
+
 
 public abstract class BaseActivity
         extends Activity implements CommonAddons, NavigationViewManager.Environment {
@@ -354,13 +373,20 @@ public abstract class BaseActivity
                 setViewMode(State.MODE_LIST);
                 return true;
 
+            case R.id.option_menu_scan:
+                if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
+                        != PackageManager.PERMISSION_GRANTED) {
+                    requestCameraScanPermission();
+                } else {
+                    scanAddressCode();
+                }
+                return true;
+
             case R.id.option_menu_advanced:
                 onDisplayAdvancedDevices();
                 return true;
 
             case R.id.option_menu_select_all:
-                //mLinearLayout.setVisibility(View.GONE);
-                //breadcrumb.setVisibility(View.GONE);
                 getInjector().actions.selectAllFiles();
                 return true;
 
@@ -373,6 +399,16 @@ public abstract class BaseActivity
         }
     }
 
+    // Request camera permission
+    public void requestCameraScanPermission() {
+        PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
+    }
+    private void scanAddressCode() {
+        Intent intent = new Intent(this, CaptureActivity.class);
+        intent.putExtra(Intents.Scan.PROMPT_MESSAGE, "");
+        startActivityForResult(intent, ReqCode.SCAN_QR_CODE);
+    }
+
     protected final @Nullable DirectoryFragment getDirectoryFragment() {
         return DirectoryFragment.get(getFragmentManager());
     }
@@ -606,6 +642,62 @@ public abstract class BaseActivity
 
     @Override
     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (requestCode == ReqCode.SCAN_QR_CODE) {
+            if (resultCode == RESULT_OK) {
+                if (data != null) {
+                    String qrCode = data.getStringExtra(Intents.Scan.RESULT);
+                    if (qrCode != null && qrCode.length() > 0) {
+                        String type = null;
+                        String name = null;
+                        String size = null;
+                        String hashKey = null;
+                        if(CommonUtil.isGoodJson(qrCode)){
+                            JsonObject jsonObj = CommonUtil.stringToJson(qrCode);
+                            int no = jsonObj.get("object_size").getAsInt();
+                            type = jsonObj.get("mime_type").getAsString();
+                            name = jsonObj.get("object_name").getAsString();
+                            hashKey = jsonObj.get("object_key").getAsString();
+                            size = Formatter.formatFileSize(getApplicationContext(), no);
+                          }else{
+                            type = "Unknown";
+                            name = "Unknown";
+                            size = "Unknown";
+                        }
+                        ObjectMeta mObjectMeta = new ObjectMeta();
+                        mObjectMeta.setObjectName(name);
+                        mObjectMeta.setObjectKey(hashKey);
+                        View view = LayoutInflater.from(BaseActivity.this).inflate(R.layout.dsn_dialog_scan, null);
+                        TextView tv_name_content = (TextView)view.findViewById(R.id.tv_name_content);
+                        TextView tv_size_content = (TextView)view.findViewById(R.id.tv_size_content);
+                        TextView tv_type_content = (TextView)view.findViewById(R.id.tv_type_content);
+
+                        AlertDialog.Builder dialog = new AlertDialog.Builder(this);
+                        tv_name_content.setText(name);
+                        tv_size_content.setText(size);
+                        tv_type_content.setText(type);
+                        dialog.setView(view);
+                        //dialog.setIcon(R.drawable.dsn_dialog_lable);
+                        dialog.setTitle("Download File from DSN");
+                        dialog.setNegativeButton("cancle", new DialogInterface.OnClickListener() {
+                           @Override
+                           public void onClick(DialogInterface dialog, int which) {
+                                dialog.dismiss();
+                            }})
+                           .setPositiveButton("ok", new DialogInterface.OnClickListener() {
+                           @Override
+                           public void onClick(DialogInterface dialog, int which) {
+                                DownloadDocumentsFromDSNJob mDownloadDocumentsFromDSNJob= new DownloadDocumentsFromDSNJob(getApplicationContext(),mObjectMeta);
+                                Thread mThreadJob = new Thread(mDownloadDocumentsFromDSNJob);
+                                mThreadJob.start();
+                                dialog.dismiss(); } }).create();
+                        dialog.show();
+
+                    } else {
+                        Toast.makeText(this, R.string.tip_scan_code_failed, Toast.LENGTH_LONG).show();
+                    }
+                }
+            }
+        }
         mInjector.actions.onActivityResult(requestCode, resultCode, data);
     }
 
diff --git a/src/com/android/documentsui/DSN/DSNAddressQrcodeActivity.java b/src/com/android/documentsui/DSN/DSNAddressQrcodeActivity.java
new file mode 100644
index 0000000..08be060
--- /dev/null
+++ b/src/com/android/documentsui/DSN/DSNAddressQrcodeActivity.java
@@ -0,0 +1,101 @@
+package com.android.documentsui.DSN;
+
+import android.content.ClipData;
+import android.content.ClipboardManager;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.support.v7.app.ActionBar;
+
+import android.os.Bundle;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+import com.android.documentsui.R;
+import com.bumptech.glide.Glide;
+import android.util.Log;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+
+import android.graphics.drawable.*;
+
+import com.android.documentsui.httpnetwork.ObjectMeta;
+import com.android.documentsui.DSN.util.QRCodeUtil;
+import com.android.documentsui.DSN.util.CommonUtil;
+
+
+public class DSNAddressQrcodeActivity extends AppCompatActivity {
+
+    ImageView ivAddressCode;
+    TextView tvAccountAddress;
+    Button btnCopyAddress;
+    private ObjectMeta mObjectMeta;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_address_qrcode);
+        tvAccountAddress = (TextView)findViewById(R.id.tv_account_address);
+        btnCopyAddress = (Button)findViewById(R.id.btn_copy_address);
+        ivAddressCode = (ImageView) findViewById(R.id.iv_address_code);
+        //ButterKnife.bind(this);
+       showNavBackBtn();
+       mObjectMeta = (ObjectMeta) getIntent().getSerializableExtra("DSNObjectMeta");
+       if (mObjectMeta == null) {
+            finish();
+        }
+        initView();
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case android.R.id.home:
+                finish();
+                break;
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+        return true;
+    }
+    protected void showNavBackBtn() {
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        if (toolbar != null) {
+            setSupportActionBar(toolbar);
+            ActionBar ab = getSupportActionBar();
+            if (ab != null) {
+                ab.setDisplayHomeAsUpEnabled(true);
+                ab.setDisplayShowHomeEnabled(true);
+            }
+        }
+    }
+    private void initView() {
+      tvAccountAddress.setText(mObjectMeta.getObjectKey());
+
+        btnCopyAddress.setOnClickListener(v -> {
+            ClipboardManager cm = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
+            ClipData clipData = ClipData.newPlainText("text",mObjectMeta.getObjectKey());
+            if (cm != null) {
+                cm.setPrimaryClip(clipData);
+                Toast.makeText(this, R.string.tip_success_copy, Toast.LENGTH_LONG).show();
+            }
+        });
+
+        new Thread(() -> {
+            Bitmap bitmap = QRCodeUtil.createQRImage(mObjectMeta.toJsonString(), 200, 200, null);
+            if (bitmap != null) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        Glide.with(DSNAddressQrcodeActivity.this)
+                                .load(bitmap)
+                                .into(ivAddressCode);
+                    }
+                });
+            }
+        }).start();
+    }
+}
diff --git a/src/com/android/documentsui/DSN/base/BaseActivity.java b/src/com/android/documentsui/DSN/base/BaseActivity.java
new file mode 100644
index 0000000..b601196
--- /dev/null
+++ b/src/com/android/documentsui/DSN/base/BaseActivity.java
@@ -0,0 +1,129 @@
+package com.android.documentsui.DSN.base;
+
+import android.Manifest;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.LocaleList;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.app.ActivityCompat;
+import android.support.v7.app.ActionBar;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import java.util.Locale;
+
+import com.android.documentsui.R;
+import com.android.documentsui.DSN.util.PermissionUtil;
+
+
+/**
+ * Activity Base
+ */
+public abstract class BaseActivity extends AppCompatActivity {
+
+    protected abstract String tag();
+
+    @Override
+    protected void attachBaseContext(Context newBase) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            Configuration config = newBase.getResources().getConfiguration();
+
+            Locale newLocale = Locale.ENGLISH;
+/*
+           if (BrahmaConfig.getInstance().getLanguageLocale()
+                    .equals(BrahmaConst.LANGUAGE_CHINESE)) {
+                newLocale = Locale.CHINESE;
+            }
+*/
+            config.setLocale(newLocale);
+            newBase = newBase.createConfigurationContext(config);
+        }
+        super.attachBaseContext(newBase);
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+       // BLog.d(tag(), "onCreate");
+        super.onCreate(savedInstanceState);
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        //ButterKnife.bind(this);
+    }
+
+    @Override
+    protected void onPostCreate(@Nullable Bundle savedInstanceState) {
+        super.onPostCreate(savedInstanceState);
+
+    }
+
+    @Override
+    protected void onDestroy() {
+        //BLog.d(tag(), "onDestroy");
+        super.onDestroy();
+    }
+
+    protected void showShortToast(String message) {
+        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
+    }
+
+    protected void showShortToast(int res) {
+        showShortToast(getString(res));
+    }
+
+    protected void showLongToast(String message) {
+        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
+    }
+
+    protected void showLongToast(int res) {
+        showLongToast(getString(res));
+    }
+
+    // Request camera permission
+    public void requestCameraScanPermission() {
+        PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
+    }
+
+    // Request write external storage
+    public void requestExternalStorage() {
+        PermissionUtil.requestMultiPermissions(this, PermissionUtil.EXTERNAL_STORAGE_PERMISSIONS, PermissionUtil.CODE_EXTERNAL_STORAGE);
+    }
+
+    public void handleCameraScanPermission() {}
+
+    public void handleExternalStoragePermission() {}
+
+    /**
+     * Callback received when a permissions request has been completed.
+     */
+    @Override
+    public void onRequestPermissionsResult(final int requestCode, @NonNull String[] permissions,
+                                           @NonNull int[] grantResults) {
+        if (requestCode == PermissionUtil.CODE_CAMERA_SCAN) {
+            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
+                    == PackageManager.PERMISSION_GRANTED) {
+                handleCameraScanPermission();
+            } else {
+                PermissionUtil.openSettingActivity(this, getString(R.string.tip_camera_permission));
+            }
+        } else if (requestCode == PermissionUtil.CODE_EXTERNAL_STORAGE) {
+            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)
+                    == PackageManager.PERMISSION_GRANTED) {
+                handleExternalStoragePermission();
+            } else {
+                PermissionUtil.openSettingActivity(this, getString(R.string.tip_external_storage_permission));
+            }
+        }
+    }
+
+
+
+}
diff --git a/src/com/android/documentsui/DSN/conmmon/ReqCode.java b/src/com/android/documentsui/DSN/conmmon/ReqCode.java
new file mode 100644
index 0000000..bfa83ca
--- /dev/null
+++ b/src/com/android/documentsui/DSN/conmmon/ReqCode.java
@@ -0,0 +1,10 @@
+package com.android.documentsui.DSN.conmmon;
+
+/**
+ *  Request code for communication ​​between Activity
+ */
+public class ReqCode {
+    public static final int SCAN_QR_CODE = 101;
+    public static final int CHOOSE_TRANSFER_CONTACT = 102;
+    public static final int CONFIRM_MNEMONIC = 103;
+}
diff --git a/src/com/android/documentsui/DSN/conmmon/SelectionState.java b/src/com/android/documentsui/DSN/conmmon/SelectionState.java
new file mode 100644
index 0000000..b2a0b7d
--- /dev/null
+++ b/src/com/android/documentsui/DSN/conmmon/SelectionState.java
@@ -0,0 +1,26 @@
+package com.android.documentsui.DSN.conmmon;
+
+public enum SelectionState {
+    HASSELETCTION("SELECTIONITEM"),
+    HASNOITEMSELECTION("NOSELECTIONIEM");
+
+    private String typeName;
+
+    SelectionState(String typeName) {
+        this.typeName = typeName;
+    }
+
+
+    public static SelectionState fromTypeName(String typeName) {
+        for (SelectionState type : SelectionState.values()) {
+            if (type.getTypeName().equals(typeName)) {
+                return type;
+            }
+        }
+        return null;
+    }
+
+    public String getTypeName() {
+        return this.typeName;
+    }
+}
diff --git a/src/com/android/documentsui/DSN/dirlist/DSNDirectoryAddonsAdapter.java b/src/com/android/documentsui/DSN/dirlist/DSNDirectoryAddonsAdapter.java
index a31aedf..01c8cc5 100644
--- a/src/com/android/documentsui/DSN/dirlist/DSNDirectoryAddonsAdapter.java
+++ b/src/com/android/documentsui/DSN/dirlist/DSNDirectoryAddonsAdapter.java
@@ -126,19 +126,19 @@ public class DSNDirectoryAddonsAdapter extends RecyclerView.Adapter<RecyclerView
             if (Meta == null) {
                 return ;
             }
-            holder.tvDSNShoreName.setText(Meta.getobjectname());
-            holder.tvDSNDate.setText(Meta.getobjectsynctime());
-            if (Meta.getobjectsize() > -1) {
+            holder.tvDSNShoreName.setText(Meta.getObjectName());
+            holder.tvDSNDate.setText(Meta.getObjectSyncTime());
+            if (Meta.getObjectSize() > -1) {
                 holder.tvDSNSize.setVisibility(View.VISIBLE);
-                holder.tvDSNSize.setText(Formatter.formatFileSize(mContext, Meta.getobjectsize()));
+                holder.tvDSNSize.setText(Formatter.formatFileSize(mContext, Meta.getObjectSize()));
             } else {
                 holder.tvDSNSize.setVisibility(View.INVISIBLE);
             }
-            if(Meta.getmimetype().contains("text")){
+            if(Meta.getMimeType().contains("text")){
                 holder.ivDSNIcon.setImageResource(R.drawable.ic_lable_txt);
-            }else if(Meta.getmimetype().contains("jpeg")){
+            }else if(Meta.getMimeType().contains("jpeg")){
                 holder.ivDSNIcon.setImageResource(R.drawable.ic_lable_jpg);
-            }else if(Meta.getmimetype().contains("zip")){
+            }else if(Meta.getMimeType().contains("zip")){
                 holder.ivDSNIcon.setImageResource(R.drawable.ic_lable_zip);
             }
 
diff --git a/src/com/android/documentsui/DSN/dirlist/DSNDirectoryFragment.java b/src/com/android/documentsui/DSN/dirlist/DSNDirectoryFragment.java
index fe721e7..063e493 100644
--- a/src/com/android/documentsui/DSN/dirlist/DSNDirectoryFragment.java
+++ b/src/com/android/documentsui/DSN/dirlist/DSNDirectoryFragment.java
@@ -46,6 +46,7 @@ import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.Toast;
 import android.widget.TextView;
+import android.os.Message;
 
 
 import com.android.documentsui.AbstractActionHandler;
@@ -111,7 +112,6 @@ import java.util.ArrayList;
 
 import javax.annotation.Nullable;
 import com.android.documentsui.DSNObjectMeta;
-import com.android.documentsui.DSNObjectMetaLoader;
 import com.android.documentsui.httpnetwork.HttpServer;
 import com.android.documentsui.httpnetwork.*;
 
@@ -136,9 +136,19 @@ import rx.Observer;
 import rx.android.schedulers.AndroidSchedulers;
 import rx.schedulers.Schedulers;
 
+import static android.content.Context.DSNMANAGER_SERVICE;
+import brahmaos.app.DSNManager;
+import brahmaos.app.AddFileCallbackListener;
+import brahmaos.app.ListFileCallbackListener;
+import brahmaos.app.DSNMateObjectData;
+import brahmaos.app.GetFileCallbackListener;
+
+
+import android.os.RemoteException;
 
-public class DSNDirectoryFragment extends Fragment implements SwipeRefreshLayout.OnRefreshListener {
 
+public class DSNDirectoryFragment extends Fragment implements SwipeRefreshLayout.OnRefreshListener {
+    private static final String TAG = "DSNDirectoryFragment";
     protected BaseActivity mActivity;
     protected View mProgressBar;
     protected RecyclerView mRecView;
@@ -154,9 +164,11 @@ public class DSNDirectoryFragment extends Fragment implements SwipeRefreshLayout
     protected IconHelper mIconHelper;
     private DSNDirectoryAddonsAdapter mDSNDirectoryAddonsAdapter;
     private MenuItem mMenuItem;
-    private String ACOUNT_ID ;
     private AVLoadingIndicatorView avi;
     private AnimationView mAnimationView;
+    private Handler mHandler;
+    private List<ObjectMeta> objecMetaList;
+
 
     protected DSNUserInputHandler mInputHandler;
 
@@ -238,14 +250,30 @@ public class DSNDirectoryFragment extends Fragment implements SwipeRefreshLayout
         // Make the recycler and the empty views responsive to drop events when allowed.
         //mRecView.setOnDragListener(mDragHoverListener);
         setHasOptionsMenu(true);
-        ACOUNT_ID = DocumentsApplication.getAccountStr(getContext());
         return view;
+
+
     }
 
     @Override
     public void onStart() {
         super.onStart();
         mDSNDirectoryAddonsAdapter.clearDNSModels();
+        mHandler = new Handler(){
+            public void handleMessage(Message msg) {
+                switch (msg.what) {
+                    case 1:
+                        if(objecMetaList.size() == 0)
+                            avi.hide();
+                        else{
+                            for(ObjectMeta objectMeta: objecMetaList)
+                                mDSNDirectoryAddonsAdapter.addDNSModelsObjectMeta(objectMeta);
+                            mAnimationView.setVisibility(View.VISIBLE);
+                            mDSNDirectoryAddonsAdapter.notifyDataSetChanged();
+                        }
+                        break;
+                    default: break; } }; };
+
         onStartNetworkRequest();
 
     }
@@ -282,40 +310,40 @@ public class DSNDirectoryFragment extends Fragment implements SwipeRefreshLayout
         }
     }
 
-    private void onStartNetworkRequest(){
-        Networks.getInstance().gethttpIpfsApi()
-                    .getDataFromIpfsCloud(ACOUNT_ID)
-                    .subscribeOn(Schedulers.io())
-                    .observeOn(AndroidSchedulers.mainThread())
-                    .subscribe(new Observer<ApiRespResult>() {
-                        @Override
-                        public void onCompleted() {
-                        }
-                        @Override
-                        public void onError(Throwable throwable) {
-                            throwable.printStackTrace();
-                        }
-                        @Override
-                        public void onNext(ApiRespResult apr) {
-                            if (apr.getResult() == 0 && apr.getData().containsKey(ApiConst.PARAM_QUOTES)) {
-                                ObjectMapper objectMapper = new ObjectMapper();
-                                try {
-                                    List<ObjectMeta> objectlist = objectMapper.readValue(objectMapper.writeValueAsString(apr.getData().get(ApiConst.PARAM_QUOTES)), new TypeReference<List<ObjectMeta>>() {});
-                                    ObjectMeta tmpobj = objectlist.get(0);
-                                    for(ObjectMeta objectMeta: objectlist)
-                                       mDSNDirectoryAddonsAdapter.addDNSModelsObjectMeta(objectMeta);
-
-                                } catch (IOException e1) {
-                                    e1.printStackTrace();
-                                }
-                                 mAnimationView.setVisibility(View.VISIBLE);
-                                 mDSNDirectoryAddonsAdapter.notifyDataSetChanged();
-                            } else {
-                            }
-
-                       }
-
-           });
+    private void onStartNetworkRequest() {
+        DSNManager mManager = (DSNManager) mActivity.getSystemService(DSNMANAGER_SERVICE);
+        mManager.listFile(null,0,20, new ListFileCallbackListener(){
+                @Override
+                public void onCompleted(String status){
+                    Log.d(TAG, "listFile" + ":" + "onCompleted");
+                }
+                @Override
+                public void onError(String status){
+                    Log.d(TAG, "listFile" + ":" + "onError");
+                }
+                @Override
+                public void onNext(DSNMateObjectData mateObjectData){
+                    if (mateObjectData.getResult() == 0 && mateObjectData.getData().containsKey(ApiConst.PARAM_QUOTES)) {
+                         ObjectMapper objectMapper = new ObjectMapper();
+                         Log.d(TAG,"listFile" + ":" + "onNext");
+                         try {
+                            objecMetaList = objectMapper.readValue(objectMapper.writeValueAsString(mateObjectData.getData().get(ApiConst.PARAM_QUOTES)), new TypeReference<List<ObjectMeta>>() {});
+                            Message msg = new Message();
+                            msg.what = 1;
+                            mHandler.sendMessage(msg);
+                         } catch (IOException e) {
+                             e.printStackTrace();
+                         }
+                     } else {
+
+                     }
+                }
+                @Override
+                public void onCallbackComplete(boolean result){
+                    Log.d(TAG, "listFile" + ":" + "onCallbackComplete");
+                }
+
+            });
 
     }
     private boolean handleMenuItemClick(MenuItem item) {
diff --git a/src/com/android/documentsui/DSN/dirlist/DSNListeningGestureDetector.java b/src/com/android/documentsui/DSN/dirlist/DSNListeningGestureDetector.java
index 1b2e7bf..af85380 100644
--- a/src/com/android/documentsui/DSN/dirlist/DSNListeningGestureDetector.java
+++ b/src/com/android/documentsui/DSN/dirlist/DSNListeningGestureDetector.java
@@ -65,7 +65,6 @@ final class DSNListeningGestureDetector extends GestureDetector implements OnIte
     @Override
     public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) {
         boolean handled = false;
-        Log.d("XULU_LOG",TAG+"/onInterceptTouchEvent/");
 
         try (InputEvent event = MotionInputEvent.obtain(e, rv)) {
             if (event.isMouseEvent()) {
@@ -90,14 +89,12 @@ final class DSNListeningGestureDetector extends GestureDetector implements OnIte
         // Forward all events to UserInputHandler.
         // This is necessary since UserInputHandler needs to always see the first DOWN event. Or
         // else all future UP events will be tossed.
-        Log.d("XULU_LOG",TAG+"/onInterceptTouchEvent/"+ String.valueOf(e.getAction() & MotionEvent.ACTION_MASK));
         handled |= onTouchEvent(e);
         return handled;
     }
 
     @Override
     public void onTouchEvent(RecyclerView rv, MotionEvent e) {
-            Log.d("XULU_LOG",TAG+"/onTouchEvent/");
         try (InputEvent event = MotionInputEvent.obtain(e, rv)) {
 
              mTouchDelegate.onTouchEvent(rv, event);
diff --git a/src/com/android/documentsui/DSN/dirlist/DSNUserInputHandler.java b/src/com/android/documentsui/DSN/dirlist/DSNUserInputHandler.java
index baa5bb0..5dfbfb3 100644
--- a/src/com/android/documentsui/DSN/dirlist/DSNUserInputHandler.java
+++ b/src/com/android/documentsui/DSN/dirlist/DSNUserInputHandler.java
@@ -47,6 +47,8 @@ import java.util.function.Predicate;
 
 import javax.annotation.Nullable;
 import com.android.documentsui.DSN.DSNActionModeController;
+import com.android.documentsui.DSN.selection.DSNSelectionManager;
+
 import com.android.documentsui.BaseActivity;
 
 
@@ -59,6 +61,7 @@ public final class DSNUserInputHandler extends GestureDetector.SimpleOnGestureLi
     private static final String TAG = "DSNUserInputHandler";
 
     private ActionHandler mActions;
+    //private final DSNSelectionManager mSelectionMgr = null;
     private final SelectionManager mSelectionMgr = null;
     //private final Predicate<DocumentDetails> mSelectable;
 
@@ -197,7 +200,6 @@ public final class DSNUserInputHandler extends GestureDetector.SimpleOnGestureLi
             mPosition = (child != null)
                     ? mRecView.getChildAdapterPosition(child)
                     : RecyclerView.NO_POSITION;
-            Log.d("XULU_LOG","onSingleTapUp:" +mPosition);
             if(mPosition < 0)
                 return true;
             Intent intent = new Intent(mDSNDirectoryAddonsAdapter.getCurrentFragment().getActivity(),DSNFilesActivity.class);
@@ -225,8 +227,9 @@ public final class DSNUserInputHandler extends GestureDetector.SimpleOnGestureLi
                     ? mRecView.getChildAdapterPosition(child)
                     : RecyclerView.NO_POSITION;
             boolean handled = true;
-           // if (!mSelectionMgr.getSelection().contains(doc.getModelId())) {
-            selectDocument(mPosition);
+            //first  press
+         //   if (!mSelectionMgr.getSelection().contains(mPosition)) {
+                selectDocument(mPosition);
                 // If we cannot select it, we didn't apply anchoring - therefore should not
                 // start gesture selection
 
@@ -234,19 +237,18 @@ public final class DSNUserInputHandler extends GestureDetector.SimpleOnGestureLi
                    // mGestureSelectHandler.accept(event);
                  //   handled = true;
                 //}
-            //} else {
+           // } else {
+
                 // We only initiate drag and drop on long press for touch to allow regular
                 // touch-based scrolling
                 //mTouchDragListener.accept(event);
               //  handled = true;
-            //}
+         //   }
 
             if (handled) {
                 mPerformHapticFeedback.run();
             }
 
-
-
         }
     }
 
diff --git a/src/com/android/documentsui/DSN/selection/DSNSelectionManager.java b/src/com/android/documentsui/DSN/selection/DSNSelectionManager.java
index 5cb550c..068a7c2 100644
--- a/src/com/android/documentsui/DSN/selection/DSNSelectionManager.java
+++ b/src/com/android/documentsui/DSN/selection/DSNSelectionManager.java
@@ -24,11 +24,13 @@ import android.support.v7.widget.RecyclerView;
 import android.util.Log;
 
 import com.android.documentsui.dirlist.DocumentsAdapter;
+import com.android.documentsui.httpnetwork.ObjectMeta;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.HashMap;
 
 import javax.annotation.Nullable;
 
@@ -47,9 +49,31 @@ public final class DSNSelectionManager {
 
     static final String TAG = "DSNSelectionManager";
 
+    HashMap<Integer, ObjectMeta> DSNModeSelection = new HashMap<>();
+
     private boolean mSingleSelect;
 
     private RecyclerView.AdapterDataObserver mAdapterObserver;
 
+    public void addDSNModeSelectionitem(int position, ObjectMeta objectMeta){
+
+        DSNModeSelection.put(position, objectMeta);
+    }
+
+    public void subDSNModeSelectionitem(int position){
+
+        DSNModeSelection.remove(position);
+    }
+
+    public void clearDSNModeSelectionitem() {
+
+    }
+
+    public void isDSNModeSelectionitemEmpty() {
+
+    }
 
+    public boolean iscontainsDSNModeItem(int position) {
+        return DSNModeSelection.containsKey(position);
+    }
 }
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/AmbientLightManager.java b/src/com/android/documentsui/DSN/ui/common/barcode/AmbientLightManager.java
new file mode 100644
index 0000000..0213c60
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/AmbientLightManager.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2012 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.content.Context;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+
+import com.android.documentsui.DSN.ui.common.barcode.camera.CameraManager;
+
+
+/**
+ * Detects ambient light and switches on the front light when very dark, and off again when sufficiently light.
+ *
+ * @author Sean Owen
+ * @author Nikolaus Huber
+ */
+final class AmbientLightManager implements SensorEventListener {
+
+    private static final float TOO_DARK_LUX = 45.0f;
+    private static final float BRIGHT_ENOUGH_LUX = 45.0f;
+
+    private final Context context;
+    private CameraManager cameraManager;
+    private Sensor lightSensor;
+
+    AmbientLightManager(Context context) {
+        this.context = context;
+    }
+
+    void start(CameraManager cameraManager) {
+        this.cameraManager = cameraManager;
+        SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
+        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
+        if (lightSensor != null) {
+            sensorManager.registerListener(this, lightSensor, SensorManager.SENSOR_DELAY_NORMAL);
+        }
+    }
+
+    void stop() {
+        if (lightSensor != null) {
+            SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
+            sensorManager.unregisterListener(this);
+            cameraManager = null;
+            lightSensor = null;
+        }
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent sensorEvent) {
+        /*float ambientLightLux = sensorEvent.values[0];
+        if (cameraManager != null) {
+            if (ambientLightLux <= TOO_DARK_LUX) {
+                cameraManager.setTorch(true);
+            } else if (ambientLightLux >= BRIGHT_ENOUGH_LUX) {
+                cameraManager.setTorch(false);
+            }
+        }*/
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+        // do nothing
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/BeepManager.java b/src/com/android/documentsui/DSN/ui/common/barcode/BeepManager.java
new file mode 100644
index 0000000..d72dec9
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/BeepManager.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.AssetFileDescriptor;
+import android.media.AudioManager;
+import android.media.MediaPlayer;
+import android.os.Build;
+import android.os.Vibrator;
+import android.util.Log;
+
+import java.io.Closeable;
+import java.io.IOException;
+
+import com.android.documentsui.R;
+
+/**
+ * Manages beeps and vibrations for {@link CaptureActivity}.
+ */
+final class BeepManager implements MediaPlayer.OnErrorListener, Closeable {
+
+    private static final String TAG = BeepManager.class.getSimpleName();
+
+    private static final float BEEP_VOLUME = 0.10f;
+    private static final long VIBRATE_DURATION = 200L;
+
+    private final Activity activity;
+    private MediaPlayer mediaPlayer;
+    private boolean playBeep;
+    private boolean vibrate;
+
+    BeepManager(Activity activity) {
+        this.activity = activity;
+        this.mediaPlayer = null;
+        updatePrefs();
+    }
+
+    synchronized void updatePrefs() {
+        playBeep = shouldBeep(activity);
+        vibrate = false;
+        if (playBeep && mediaPlayer == null) {
+            // The volume on STREAM_SYSTEM is not adjustable, and users found it too loud,
+            // so we now play on the music stream.
+            activity.setVolumeControlStream(AudioManager.STREAM_MUSIC);
+            mediaPlayer = buildMediaPlayer(activity);
+        }
+    }
+
+    synchronized void playBeepSoundAndVibrate() {
+        if (playBeep && mediaPlayer != null) {
+            mediaPlayer.start();
+        }
+        if (vibrate) {
+            Vibrator vibrator = (Vibrator) activity.getSystemService(Context.VIBRATOR_SERVICE);
+            vibrator.vibrate(VIBRATE_DURATION);
+        }
+    }
+
+    private static boolean shouldBeep(Context activity) {
+        boolean shouldPlayBeep = true;
+        // See if sound settings overrides this
+        AudioManager audioService = (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);
+        if (audioService.getRingerMode() != AudioManager.RINGER_MODE_NORMAL) {
+            shouldPlayBeep = false;
+        }
+        return shouldPlayBeep;
+    }
+
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private MediaPlayer buildMediaPlayer(Context activity) {
+        MediaPlayer mediaPlayer = new MediaPlayer();
+        try {
+            try (AssetFileDescriptor file = activity.getResources().openRawResourceFd(R.raw.beep)) {
+                mediaPlayer.setDataSource(file.getFileDescriptor(), file.getStartOffset(), file.getLength());
+            }
+            mediaPlayer.setOnErrorListener(this);
+            mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
+            mediaPlayer.setLooping(false);
+            mediaPlayer.setVolume(BEEP_VOLUME, BEEP_VOLUME);
+            mediaPlayer.prepare();
+            return mediaPlayer;
+        } catch (IOException ioe) {
+            Log.w(TAG, ioe);
+            mediaPlayer.release();
+            return null;
+        }
+    }
+
+    @Override
+    public synchronized boolean onError(MediaPlayer mp, int what, int extra) {
+        if (what == MediaPlayer.MEDIA_ERROR_SERVER_DIED) {
+            // we are finished, so put up an appropriate error toast if required and finish
+            activity.finish();
+        } else {
+            // possibly media player error, so release and recreate
+            close();
+            updatePrefs();
+        }
+        return true;
+    }
+
+    @Override
+    public synchronized void close() {
+        if (mediaPlayer != null) {
+            mediaPlayer.release();
+            mediaPlayer = null;
+        }
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/CaptureActivity.java b/src/com/android/documentsui/DSN/ui/common/barcode/CaptureActivity.java
new file mode 100644
index 0000000..2bbce9f
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/CaptureActivity.java
@@ -0,0 +1,403 @@
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.support.v7.app.AlertDialog;
+import android.view.KeyEvent;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.Button;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.Result;
+import com.google.zxing.ResultMetadataType;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Map;
+import android.support.v7.widget.Toolbar;
+import android.support.v7.app.ActionBar;
+
+import com.android.documentsui.R;
+import com.android.documentsui.DSN.ui.common.barcode.camera.CameraManager;
+import com.android.documentsui.DSN.ui.common.barcode.result.ResultHandler;
+import com.android.documentsui.DSN.ui.common.barcode.result.ResultHandlerFactory;
+//import com.android.documentsui.DSN.util.BLog;
+import com.android.documentsui.DSN.util.CommonUtil;
+import com.android.documentsui.DSN.base.BaseActivity;
+import com.android.documentsui.DSN.ui.common.barcode.BeepManager;
+
+/**
+ *
+ *  - Intents.Scan.WIDTH
+ *  - Intents.Scan.HEIGHT
+ */
+public class CaptureActivity extends BaseActivity implements SurfaceHolder.Callback {
+
+    @Override
+    protected String tag() {
+        return CaptureActivity.class.getName();
+    }
+
+    private static final long DEFAULT_INTENT_RESULT_DURATION_MS = 100L;
+    private CameraManager cameraManager;
+    private boolean hasSurface;
+    private BeepManager beepManager;
+    private AmbientLightManager ambientLightManager;
+    private ViewfinderView viewfinderView;
+    private TextView statusView;
+    private Button setTorchBtn;
+    private CaptureActivityHandler handler;
+    private Collection<BarcodeFormat> decodeFormats;
+    private Map<DecodeHintType,?> decodeHints;
+    private String characterSet;
+    private Result lastResult;
+    private Result savedResultToShow;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        Window window = getWindow();
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
+            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
+            window.setStatusBarColor(Color.BLACK);
+        }
+        setContentView(R.layout.activity_capture);
+
+        hasSurface = false;
+        beepManager = new BeepManager(this);
+        ambientLightManager = new AmbientLightManager(this);
+        showNavBackBtn();
+    }
+
+    ViewfinderView getViewfinderView() {
+        return viewfinderView;
+    }
+
+    public Handler getHandler() {
+        return handler;
+    }
+
+    CameraManager getCameraManager() {
+        return cameraManager;
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        // CameraManager must be initialized here, not in onCreate(). This is necessary because we don't
+        // want to open the camera driver and measure the screen size if we're going to show the help on
+        // first launch. That led to bugs where the scanning rectangle was the wrong size and partially
+        // off screen.
+        cameraManager = new CameraManager(getApplication());
+
+        viewfinderView = (ViewfinderView) findViewById(R.id.viewfinder_view);
+        viewfinderView.setCameraManager(cameraManager);
+        statusView = (TextView) findViewById(R.id.status_view);
+        setTorchBtn = (Button) findViewById(R.id.set_torch_btn);
+
+        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+        int windowHeight = CommonUtil.getScreenHeight(this);
+        int windowWidth = CommonUtil.getScreenWidth(this);
+        int scanHeight = CameraManager.findDesiredDimensionInRange(windowHeight, CameraManager.MIN_FRAME_HEIGHT, CameraManager.MAX_FRAME_HEIGHT);
+        int topOffset = (windowHeight - scanHeight) / 3;
+        int measureWidth = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
+        int measureHeight = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
+        setTorchBtn.measure(measureWidth, measureHeight);
+        int buttonWidth = setTorchBtn.getMeasuredWidth();
+        layoutParams.setMargins((windowWidth - buttonWidth) / 2, scanHeight + topOffset + CommonUtil.dip2px(this, getResources().getDimension(R.dimen.space_normal)), 0, 0);
+        setTorchBtn.setLayoutParams(layoutParams);
+        if (cameraManager.getTorch()) {
+            setTorchBtn.setText(getString(R.string.close_slash));
+        } else {
+            setTorchBtn.setText(getString(R.string.open_slash));
+        }
+        setTorchBtn.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (cameraManager.getTorch()) {
+                    cameraManager.setTorch(false);
+                    setTorchBtn.setText(getString(R.string.open_slash));
+                } else {
+                    cameraManager.setTorch(true);
+                    setTorchBtn.setText(getString(R.string.close_slash));
+                }
+            }
+        });
+
+        handler = null;
+        beepManager.updatePrefs();
+        ambientLightManager.start(cameraManager);
+
+        Intent intent = getIntent();
+        decodeFormats = DecodeFormatManager.parseDecodeFormats(intent);
+        decodeHints = DecodeHintManager.parseDecodeHints(intent);
+        if (intent.hasExtra(Intents.Scan.WIDTH) && intent.hasExtra(Intents.Scan.HEIGHT)) {
+            int width = intent.getIntExtra(Intents.Scan.WIDTH, 0);
+            int height = intent.getIntExtra(Intents.Scan.HEIGHT, 0);
+            if (width > 0 && height > 0) {
+                cameraManager.setManualFramingRect(width, height);
+            }
+        }
+
+        if (intent.hasExtra(Intents.Scan.CAMERA_ID)) {
+            int cameraId = intent.getIntExtra(Intents.Scan.CAMERA_ID, -1);
+            if (cameraId >= 0) {
+                cameraManager.setManualCameraId(cameraId);
+            }
+        }
+
+        String customPromptMessage = intent.getStringExtra(Intents.Scan.PROMPT_MESSAGE);
+        if (customPromptMessage != null) {
+            statusView.setText(customPromptMessage);
+        }
+
+        characterSet = intent.getStringExtra(Intents.Scan.CHARACTER_SET);
+
+        SurfaceView surfaceView = (SurfaceView) findViewById(R.id.preview_view);
+        SurfaceHolder surfaceHolder = surfaceView.getHolder();
+        if (hasSurface) {
+            // The activity was paused but not stopped, so the surface still exists. Therefore
+            // surfaceCreated() won't be called, so init the camera here.
+            initCamera(surfaceHolder);
+        } else {
+            // Install the callback and wait for surfaceCreated() to init the camera.
+            surfaceHolder.addCallback(this);
+        }
+    }
+
+    @Override
+    protected void onPause() {
+        if (handler != null) {
+            handler.quitSynchronously();
+            handler = null;
+        }
+
+        ambientLightManager.stop();
+        beepManager.close();
+        cameraManager.closeDriver();
+
+        if (!hasSurface) {
+            SurfaceView surfaceView = (SurfaceView) findViewById(R.id.preview_view);
+            SurfaceHolder surfaceHolder = surfaceView.getHolder();
+            surfaceHolder.removeCallback(this);
+        }
+        super.onPause();
+    }
+
+    /**
+     * A valid barcode has been found, so give an indication of success and show the results.
+     *
+     * @param rawResult The contents of the barcode.
+     * @param scaleFactor amount by which thumbnail was scaled
+     * @param barcode   A greyscale bitmap of the camera data which was decoded.
+     */
+    public void handleDecode(Result rawResult, Bitmap barcode, float scaleFactor) {
+        lastResult = rawResult;
+        ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler(this, rawResult);
+
+        boolean fromLiveScan = barcode != null;
+        if (fromLiveScan) {
+            // Then not from history, so beep/vibrate and we have an image to draw on
+            beepManager.playBeepSoundAndVibrate();
+        }
+
+        handleDecodeExternally(rawResult, resultHandler, barcode);
+    }
+
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        if (holder == null) {
+           // BLog.e(tag(), "*** WARNING *** surfaceCreated() gave us a null surface!");
+        }
+
+        if (!hasSurface) {
+            hasSurface = true;
+            initCamera(holder);
+        }
+    }
+
+    // Briefly show the contents of the barcode, then handle the result outside Barcode Scanner.
+    private void handleDecodeExternally(Result rawResult, ResultHandler resultHandler, Bitmap barcode) {
+
+        if (barcode != null) {
+            viewfinderView.drawResultBitmap(barcode);
+        }
+
+        long resultDurationMS;
+        if (getIntent() == null) {
+            resultDurationMS = DEFAULT_INTENT_RESULT_DURATION_MS;
+        } else {
+            resultDurationMS = getIntent().getLongExtra(Intents.Scan.RESULT_DISPLAY_DURATION_MS,
+                    DEFAULT_INTENT_RESULT_DURATION_MS);
+        }
+
+        // Hand back whatever action they requested - this can be changed to Intents.Scan.ACTION when
+        // the deprecated intent is retired.
+        Intent intent = new Intent(getIntent().getAction());
+        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+        intent.putExtra(Intents.Scan.RESULT, rawResult.toString());
+        intent.putExtra(Intents.Scan.RESULT_FORMAT, rawResult.getBarcodeFormat().toString());
+        byte[] rawBytes = rawResult.getRawBytes();
+        if (rawBytes != null && rawBytes.length > 0) {
+            intent.putExtra(Intents.Scan.RESULT_BYTES, rawBytes);
+        }
+
+        Map<ResultMetadataType,?> metadata = rawResult.getResultMetadata();
+        if (metadata != null) {
+            if (metadata.containsKey(ResultMetadataType.UPC_EAN_EXTENSION)) {
+                intent.putExtra(Intents.Scan.RESULT_UPC_EAN_EXTENSION,
+                        metadata.get(ResultMetadataType.UPC_EAN_EXTENSION).toString());
+            }
+            Number orientation = (Number) metadata.get(ResultMetadataType.ORIENTATION);
+            if (orientation != null) {
+                intent.putExtra(Intents.Scan.RESULT_ORIENTATION, orientation.intValue());
+            }
+            String ecLevel = (String) metadata.get(ResultMetadataType.ERROR_CORRECTION_LEVEL);
+            if (ecLevel != null) {
+                intent.putExtra(Intents.Scan.RESULT_ERROR_CORRECTION_LEVEL, ecLevel);
+            }
+
+            @SuppressWarnings("unchecked")
+            Iterable<byte[]> byteSegments = (Iterable<byte[]>) metadata.get(ResultMetadataType.BYTE_SEGMENTS);
+            if (byteSegments != null) {
+                int i = 0;
+                for (byte[] byteSegment : byteSegments) {
+                    intent.putExtra(Intents.Scan.RESULT_BYTE_SEGMENTS_PREFIX + i, byteSegment);
+                    i++;
+                }
+            }
+        }
+        sendReplyMessage(R.id.return_scan_result, intent, resultDurationMS);
+    }
+
+    private void sendReplyMessage(int id, Object arg, long delayMS) {
+        if (handler != null) {
+            Message message = Message.obtain(handler, id, arg);
+            if (delayMS > 0L) {
+                handler.sendMessageDelayed(message, delayMS);
+            } else {
+                handler.sendMessage(message);
+            }
+        }
+    }
+
+    private void decodeOrStoreSavedBitmap(Bitmap bitmap, Result result) {
+        // Bitmap isn't used yet -- will be used soon
+        if (handler == null) {
+            savedResultToShow = result;
+        } else {
+            if (result != null) {
+                savedResultToShow = result;
+            }
+            if (savedResultToShow != null) {
+                Message message = Message.obtain(handler, R.id.decode_succeeded, savedResultToShow);
+                handler.sendMessage(message);
+            }
+            savedResultToShow = null;
+        }
+    }
+
+    private void initCamera(SurfaceHolder surfaceHolder) {
+        if (surfaceHolder == null) {
+            throw new IllegalStateException("No SurfaceHolder provided");
+        }
+
+        if (cameraManager.isOpen()) {
+            //BLog.w(tag(), "initCamera() while already open -- late SurfaceView callback?");
+            return;
+        }
+        try {
+            cameraManager.openDriver(surfaceHolder);
+            // Creating the handler starts the preview, which can also throw a RuntimeException.
+            if (handler == null) {
+                handler = new CaptureActivityHandler(this, decodeFormats, decodeHints, characterSet, cameraManager);
+            }
+            decodeOrStoreSavedBitmap(null, null);
+        } catch (IOException ioe) {
+            //BLog.w(tag(), ioe.getMessage());
+            ioe.printStackTrace();
+            displayFrameworkBugMessageAndExit();
+        } catch (RuntimeException e) {
+            // Barcode Scanner has seen crashes in the wild of this variety:
+            // java.?lang.?RuntimeException: Fail to connect to camera service
+            //BLog.w(tag(), "Unexpected error initializing camera = " + e.getMessage());
+            displayFrameworkBugMessageAndExit();
+        }
+    }
+
+    private void displayFrameworkBugMessageAndExit() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(getString(R.string.app_name));
+        builder.setMessage(getString(R.string.msg_camera_framework_bug));
+        builder.setPositiveButton(R.string.button_ok, new FinishListener(this));
+        builder.setOnCancelListener(new FinishListener(this));
+        builder.show();
+    }
+
+    @Override
+    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
+
+    }
+
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        hasSurface = false;
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_BACK:
+                setResult(RESULT_CANCELED);
+                finish();
+                return true;
+
+            case KeyEvent.KEYCODE_FOCUS:
+            case KeyEvent.KEYCODE_CAMERA:
+                // Handle these events so they don't launch the Camera app
+                return true;
+
+            // Use volume up/down to turn on light
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+                cameraManager.setTorch(false);
+                return true;
+
+            case KeyEvent.KEYCODE_VOLUME_UP:
+                cameraManager.setTorch(true);
+                return true;
+        }
+        return super.onKeyDown(keyCode, event);
+    }
+
+    public void drawViewfinder() {
+        viewfinderView.drawViewfinder();
+    }
+    // show navigation back action icon
+    protected void showNavBackBtn() {
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        if (toolbar != null) {
+            setSupportActionBar(toolbar);
+            ActionBar ab = getSupportActionBar();
+            if (ab != null) {
+                ab.setDisplayHomeAsUpEnabled(true);
+                ab.setDisplayShowHomeEnabled(true);
+            }
+        }
+    }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/CaptureActivityHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/CaptureActivityHandler.java
new file mode 100644
index 0000000..e89e249
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/CaptureActivityHandler.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.provider.Browser;
+import android.util.Log;
+
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.Result;
+
+import java.util.Collection;
+import java.util.Map;
+
+import com.android.documentsui.R;
+import com.android.documentsui.DSN.ui.common.barcode.camera.CameraManager;
+
+
+/**
+ * This class handles all the messaging which comprises the state machine for capture.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class CaptureActivityHandler extends Handler {
+
+    private static final String TAG = CaptureActivityHandler.class.getSimpleName();
+
+    private final CaptureActivity activity;
+    private final DecodeThread decodeThread;
+    private State state;
+    private final CameraManager cameraManager;
+
+    private enum State {
+        PREVIEW,
+        SUCCESS,
+        DONE
+    }
+
+    CaptureActivityHandler(CaptureActivity activity,
+                           Collection<BarcodeFormat> decodeFormats,
+                           Map<DecodeHintType, ?> baseHints,
+                           String characterSet,
+                           CameraManager cameraManager) {
+        this.activity = activity;
+        decodeThread = new DecodeThread(activity, decodeFormats, baseHints, characterSet,
+                new ViewfinderResultPointCallback(activity.getViewfinderView()));
+        decodeThread.start();
+        state = State.SUCCESS;
+
+        // Start ourselves capturing previews and decoding.
+        this.cameraManager = cameraManager;
+        cameraManager.startPreview();
+        restartPreviewAndDecode();
+    }
+
+    @Override
+    public void handleMessage(Message message) {
+        switch (message.what) {
+            case R.id.restart_preview:
+                restartPreviewAndDecode();
+                break;
+
+            case R.id.decode_succeeded:
+                state = State.SUCCESS;
+                Bundle bundle = message.getData();
+                Bitmap barcode = null;
+                float scaleFactor = 1.0f;
+                if (bundle != null) {
+                    byte[] compressedBitmap = bundle.getByteArray(DecodeThread.BARCODE_BITMAP);
+                    if (compressedBitmap != null) {
+                        barcode = BitmapFactory.decodeByteArray(compressedBitmap, 0, compressedBitmap.length, null);
+                        // Mutable copy:
+                        barcode = barcode.copy(Bitmap.Config.ARGB_8888, true);
+                    }
+                    scaleFactor = bundle.getFloat(DecodeThread.BARCODE_SCALED_FACTOR);
+                }
+                activity.handleDecode((Result) message.obj, barcode, scaleFactor);
+                break;
+
+            case R.id.decode_failed:
+                // We're decoding as fast as possible, so when one decode fails, start another.
+                state = State.PREVIEW;
+                cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
+                break;
+
+            case R.id.return_scan_result:
+                activity.setResult(Activity.RESULT_OK, (Intent) message.obj);
+                activity.finish();
+                break;
+
+            case R.id.launch_product_query:
+                String url = (String) message.obj;
+
+                Intent intent = new Intent(Intent.ACTION_VIEW);
+                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+                intent.setData(Uri.parse(url));
+
+                ResolveInfo resolveInfo =
+                        activity.getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
+                String browserPackageName = null;
+                if (resolveInfo != null && resolveInfo.activityInfo != null) {
+                    browserPackageName = resolveInfo.activityInfo.packageName;
+                    Log.d(TAG, "Using browser in package " + browserPackageName);
+                }
+
+                // Needed for default Android browser / Chrome only apparently
+                if ("com.android.browser".equals(browserPackageName) || "com.android.chrome".equals(browserPackageName)) {
+                    intent.setPackage(browserPackageName);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    intent.putExtra(Browser.EXTRA_APPLICATION_ID, browserPackageName);
+                }
+
+                try {
+                    activity.startActivity(intent);
+                } catch (ActivityNotFoundException ignored) {
+                    Log.w(TAG, "Can't find anything to handle VIEW of URI " + url);
+                }
+                break;
+        }
+    }
+
+    public void quitSynchronously() {
+        state = State.DONE;
+        cameraManager.stopPreview();
+        Message quit = Message.obtain(decodeThread.getHandler(), R.id.quit);
+        quit.sendToTarget();
+        try {
+            // Wait at most half a second; should be enough time, and onPause() will timeout quickly
+            decodeThread.join(500L);
+        } catch (InterruptedException e) {
+            // continue
+        }
+
+        // Be absolutely sure we don't send any queued up messages
+        removeMessages(R.id.decode_succeeded);
+        removeMessages(R.id.decode_failed);
+    }
+
+    private void restartPreviewAndDecode() {
+        if (state == State.SUCCESS) {
+            state = State.PREVIEW;
+            cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
+            activity.drawViewfinder();
+        }
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/Contents.java b/src/com/android/documentsui/DSN/ui/common/barcode/Contents.java
new file mode 100644
index 0000000..6cf0766
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/Contents.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.provider.ContactsContract;
+
+/**
+ * The set of constants to use when sending Barcode Scanner an Intent which requests a barcode
+ * to be encoded.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class Contents {
+  private Contents() {
+  }
+
+  /**
+   * Contains type constants used when sending Intents.
+   */
+  public static final class Type {
+    /**
+     * Plain text. Use Intent.putExtra(DATA, string). This can be used for URLs too, but string
+     * must include "http://" or "https://".
+     */
+    public static final String TEXT = "TEXT_TYPE";
+
+    /**
+     * An email type. Use Intent.putExtra(DATA, string) where string is the email address.
+     */
+    public static final String EMAIL = "EMAIL_TYPE";
+
+    /**
+     * Use Intent.putExtra(DATA, string) where string is the phone number to call.
+     */
+    public static final String PHONE = "PHONE_TYPE";
+
+    /**
+     * An SMS type. Use Intent.putExtra(DATA, string) where string is the number to SMS.
+     */
+    public static final String SMS = "SMS_TYPE";
+
+    /**
+     * A contact. Send a request to encode it as follows:
+     * {@code
+     * import android.provider.Contacts;
+     *
+     * Intent intent = new Intent(Intents.Encode.ACTION);
+     * intent.putExtra(Intents.Encode.TYPE, CONTACT);
+     * Bundle bundle = new Bundle();
+     * bundle.putString(ContactsContract.Intents.Insert.NAME, "Jenny");
+     * bundle.putString(ContactsContract.Intents.Insert.PHONE, "8675309");
+     * bundle.putString(ContactsContract.Intents.Insert.EMAIL, "jenny@the80s.com");
+     * bundle.putString(ContactsContract.Intents.Insert.POSTAL, "123 Fake St. San Francisco, CA 94102");
+     * intent.putExtra(Intents.Encode.DATA, bundle);
+     * }
+     */
+    public static final String CONTACT = "CONTACT_TYPE";
+
+    /**
+     * A geographic location. Use as follows:
+     * Bundle bundle = new Bundle();
+     * bundle.putFloat("LAT", latitude);
+     * bundle.putFloat("LONG", longitude);
+     * intent.putExtra(Intents.Encode.DATA, bundle);
+     */
+    public static final String LOCATION = "LOCATION_TYPE";
+
+    private Type() {
+    }
+  }
+
+  public static final String URL_KEY = "URL_KEY";
+
+  public static final String NOTE_KEY = "NOTE_KEY";
+
+  /**
+   * When using Type.CONTACT, these arrays provide the keys for adding or retrieving multiple
+   * phone numbers and addresses.
+   */
+  public static final String[] PHONE_KEYS = {
+      ContactsContract.Intents.Insert.PHONE,
+      ContactsContract.Intents.Insert.SECONDARY_PHONE,
+      ContactsContract.Intents.Insert.TERTIARY_PHONE
+  };
+
+  public static final String[] PHONE_TYPE_KEYS = {
+      ContactsContract.Intents.Insert.PHONE_TYPE,
+      ContactsContract.Intents.Insert.SECONDARY_PHONE_TYPE,
+      ContactsContract.Intents.Insert.TERTIARY_PHONE_TYPE
+  };
+
+  public static final String[] EMAIL_KEYS = {
+      ContactsContract.Intents.Insert.EMAIL,
+      ContactsContract.Intents.Insert.SECONDARY_EMAIL,
+      ContactsContract.Intents.Insert.TERTIARY_EMAIL
+  };
+
+  public static final String[] EMAIL_TYPE_KEYS = {
+      ContactsContract.Intents.Insert.EMAIL_TYPE,
+      ContactsContract.Intents.Insert.SECONDARY_EMAIL_TYPE,
+      ContactsContract.Intents.Insert.TERTIARY_EMAIL_TYPE
+  };
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/DecodeFormatManager.java b/src/com/android/documentsui/DSN/ui/common/barcode/DecodeFormatManager.java
new file mode 100644
index 0000000..2a69a96
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/DecodeFormatManager.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.content.Intent;
+import android.net.Uri;
+
+import com.google.zxing.BarcodeFormat;
+
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+final class DecodeFormatManager {
+
+  private static final Pattern COMMA_PATTERN = Pattern.compile(",");
+
+  static final Set<BarcodeFormat> PRODUCT_FORMATS;
+  static final Set<BarcodeFormat> INDUSTRIAL_FORMATS;
+  private static final Set<BarcodeFormat> ONE_D_FORMATS;
+  static final Set<BarcodeFormat> QR_CODE_FORMATS = EnumSet.of(BarcodeFormat.QR_CODE);
+  static final Set<BarcodeFormat> DATA_MATRIX_FORMATS = EnumSet.of(BarcodeFormat.DATA_MATRIX);
+  static final Set<BarcodeFormat> AZTEC_FORMATS = EnumSet.of(BarcodeFormat.AZTEC);
+  static final Set<BarcodeFormat> PDF417_FORMATS = EnumSet.of(BarcodeFormat.PDF_417);
+  static {
+    PRODUCT_FORMATS = EnumSet.of(BarcodeFormat.UPC_A,
+                                 BarcodeFormat.UPC_E,
+                                 BarcodeFormat.EAN_13,
+                                 BarcodeFormat.EAN_8,
+                                 BarcodeFormat.RSS_14,
+                                 BarcodeFormat.RSS_EXPANDED);
+    INDUSTRIAL_FORMATS = EnumSet.of(BarcodeFormat.CODE_39,
+                                    BarcodeFormat.CODE_93,
+                                    BarcodeFormat.CODE_128,
+                                    BarcodeFormat.ITF,
+                                    BarcodeFormat.CODABAR);
+    ONE_D_FORMATS = EnumSet.copyOf(PRODUCT_FORMATS);
+    ONE_D_FORMATS.addAll(INDUSTRIAL_FORMATS);
+  }
+  private static final Map<String,Set<BarcodeFormat>> FORMATS_FOR_MODE;
+  static {
+    FORMATS_FOR_MODE = new HashMap<>();
+    FORMATS_FOR_MODE.put(Intents.Scan.ONE_D_MODE, ONE_D_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.PRODUCT_MODE, PRODUCT_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.QR_CODE_MODE, QR_CODE_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.DATA_MATRIX_MODE, DATA_MATRIX_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.AZTEC_MODE, AZTEC_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.PDF417_MODE, PDF417_FORMATS);
+  }
+
+  private DecodeFormatManager() {}
+
+  static Set<BarcodeFormat> parseDecodeFormats(Intent intent) {
+    Iterable<String> scanFormats = null;
+    CharSequence scanFormatsString = intent.getStringExtra(Intents.Scan.FORMATS);
+    if (scanFormatsString != null) {
+      scanFormats = Arrays.asList(COMMA_PATTERN.split(scanFormatsString));
+    }
+    return parseDecodeFormats(scanFormats, intent.getStringExtra(Intents.Scan.MODE));
+  }
+
+  static Set<BarcodeFormat> parseDecodeFormats(Uri inputUri) {
+    List<String> formats = inputUri.getQueryParameters(Intents.Scan.FORMATS);
+    if (formats != null && formats.size() == 1 && formats.get(0) != null) {
+      formats = Arrays.asList(COMMA_PATTERN.split(formats.get(0)));
+    }
+    return parseDecodeFormats(formats, inputUri.getQueryParameter(Intents.Scan.MODE));
+  }
+
+  private static Set<BarcodeFormat> parseDecodeFormats(Iterable<String> scanFormats, String decodeMode) {
+    if (scanFormats != null) {
+      Set<BarcodeFormat> formats = EnumSet.noneOf(BarcodeFormat.class);
+      try {
+        for (String format : scanFormats) {
+          formats.add(BarcodeFormat.valueOf(format));
+        }
+        return formats;
+      } catch (IllegalArgumentException iae) {
+        // ignore it then
+      }
+    }
+    if (decodeMode != null) {
+      return FORMATS_FOR_MODE.get(decodeMode);
+    }
+    return null;
+  }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/DecodeHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/DecodeHandler.java
new file mode 100644
index 0000000..2f12303
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/DecodeHandler.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.graphics.Bitmap;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.util.Log;
+
+import com.google.zxing.BinaryBitmap;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.MultiFormatReader;
+import com.google.zxing.PlanarYUVLuminanceSource;
+import com.google.zxing.ReaderException;
+import com.google.zxing.Result;
+import com.google.zxing.common.HybridBinarizer;
+
+import java.io.ByteArrayOutputStream;
+import java.util.Map;
+
+import com.android.documentsui.R;
+
+final class DecodeHandler extends Handler {
+
+    private static final String TAG = DecodeHandler.class.getSimpleName();
+
+    private final CaptureActivity activity;
+    private final MultiFormatReader multiFormatReader;
+    private boolean running = true;
+
+    DecodeHandler(CaptureActivity activity, Map<DecodeHintType, Object> hints) {
+        multiFormatReader = new MultiFormatReader();
+        multiFormatReader.setHints(hints);
+        this.activity = activity;
+    }
+
+    @Override
+    public void handleMessage(Message message) {
+        if (!running) {
+            return;
+        }
+        switch (message.what) {
+            case R.id.decode:
+                decode((byte[]) message.obj, message.arg1, message.arg2);
+                break;
+
+            case R.id.quit:
+                running = false;
+                Looper.myLooper().quit();
+                break;
+        }
+    }
+
+    /**
+     * Decode the data within the viewfinder rectangle, and time how long it took. For efficiency,
+     * reuse the same reader objects from one decode to the next.
+     *
+     * @param data   The YUV preview frame.
+     * @param width  The width of the preview frame.
+     * @param height The height of the preview frame.
+     */
+    private void decode(byte[] data, int width, int height) {
+        long start = System.currentTimeMillis();
+        Result rawResult = null;
+
+        // 构造基于平面的YUV亮度源，即包含二维码区域的数据源
+        PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);
+        if (source != null) {
+            // 构造二值图像比特流，使用HybridBinarizer算法解析数据源
+            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));
+            try {
+                // 采用MultiFormatReader解析图像，可以解析多种数据格式
+                rawResult = multiFormatReader.decodeWithState(bitmap);
+            } catch (ReaderException re) {
+                // continue
+            } finally {
+                multiFormatReader.reset();
+            }
+        }
+
+        // Hanlder处理解析失败或成功的结果
+        Handler handler = activity.getHandler();
+        if (rawResult != null) {
+            // Don't log the barcode contents for security.
+            long end = System.currentTimeMillis();
+            Log.d(TAG, "Found barcode in " + (end - start) + " ms");
+            if (handler != null) {
+                Message message = Message.obtain(handler, R.id.decode_succeeded, rawResult);
+                Bundle bundle = new Bundle();
+                bundleThumbnail(source, bundle);
+                message.setData(bundle);
+                message.sendToTarget();
+            }
+        } else {
+            if (handler != null) {
+                Message message = Message.obtain(handler, R.id.decode_failed);
+                message.sendToTarget();
+            }
+        }
+    }
+
+    private static void bundleThumbnail(PlanarYUVLuminanceSource source, Bundle bundle) {
+        int[] pixels = source.renderThumbnail();
+        int width = source.getThumbnailWidth();
+        int height = source.getThumbnailHeight();
+        Bitmap bitmap = Bitmap.createBitmap(pixels, 0, width, width, height, Bitmap.Config.ARGB_8888);
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        bitmap.compress(Bitmap.CompressFormat.JPEG, 50, out);
+        bundle.putByteArray(DecodeThread.BARCODE_BITMAP, out.toByteArray());
+        bundle.putFloat(DecodeThread.BARCODE_SCALED_FACTOR, (float) width / source.getWidth());
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/DecodeHintManager.java b/src/com/android/documentsui/DSN/ui/common/barcode/DecodeHintManager.java
new file mode 100644
index 0000000..7161074
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/DecodeHintManager.java
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2013 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.google.zxing.DecodeHintType;
+
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Pattern;
+
+/**
+ * @author Lachezar Dobrev
+ */
+final class DecodeHintManager {
+  
+  private static final String TAG = DecodeHintManager.class.getSimpleName();
+
+  // This pattern is used in decoding integer arrays.
+  private static final Pattern COMMA = Pattern.compile(",");
+
+  private DecodeHintManager() {}
+
+  /**
+   * <p>Split a query string into a list of name-value pairs.</p>
+   * 
+   * <p>This is an alternative to the {@link Uri#getQueryParameterNames()} and
+   * {@link Uri#getQueryParameters(String)}, which are quirky and not suitable
+   * for exist-only Uri parameters.</p>
+   * 
+   * <p>This method ignores multiple parameters with the same name and returns the
+   * first one only. This is technically incorrect, but should be acceptable due
+   * to the method of processing Hints: no multiple values for a hint.</p>
+   * 
+   * @param query query to split
+   * @return name-value pairs
+   */
+  private static Map<String,String> splitQuery(String query) {
+    Map<String,String> map = new HashMap<>();
+    int pos = 0;
+    while (pos < query.length()) {
+      if (query.charAt(pos) == '&') {
+        // Skip consecutive ampersand separators.
+        pos ++;
+        continue;
+      }
+      int amp = query.indexOf('&', pos);
+      int equ = query.indexOf('=', pos);
+      if (amp < 0) {
+        // This is the last element in the query, no more ampersand elements.
+        String name;
+        String text;
+        if (equ < 0) {
+          // No equal sign
+          name = query.substring(pos);
+          name = name.replace('+', ' '); // Preemptively decode +
+          name = Uri.decode(name);
+          text = "";
+        } else {
+          // Split name and text.
+          name = query.substring(pos, equ);
+          name = name.replace('+', ' '); // Preemptively decode +
+          name = Uri.decode(name);
+          text = query.substring(equ + 1);
+          text = text.replace('+', ' '); // Preemptively decode +
+          text = Uri.decode(text);
+        }
+        if (!map.containsKey(name)) {
+          map.put(name, text);
+        }
+        break;
+      }
+      if (equ < 0 || equ > amp) {
+        // No equal sign until the &: this is a simple parameter with no value.
+        String name = query.substring(pos, amp);
+        name = name.replace('+', ' '); // Preemptively decode +
+        name = Uri.decode(name);
+        if (!map.containsKey(name)) {
+          map.put(name, "");
+        }
+        pos = amp + 1;
+        continue;
+      }
+      String name = query.substring(pos, equ);
+      name = name.replace('+', ' '); // Preemptively decode +
+      name = Uri.decode(name);
+      String text = query.substring(equ + 1, amp);
+      text = text.replace('+', ' '); // Preemptively decode +
+      text = Uri.decode(text);
+      if (!map.containsKey(name)) {
+        map.put(name, text);
+      }
+      pos = amp + 1;
+    }
+    return map;
+  }
+
+  static Map<DecodeHintType,?> parseDecodeHints(Uri inputUri) {
+    String query = inputUri.getEncodedQuery();
+    if (query == null || query.isEmpty()) {
+      return null;
+    }
+
+    // Extract parameters
+    Map<String, String> parameters = splitQuery(query);
+
+    Map<DecodeHintType, Object> hints = new EnumMap<>(DecodeHintType.class);
+
+    for (DecodeHintType hintType: DecodeHintType.values()) {
+
+      if (hintType == DecodeHintType.CHARACTER_SET ||
+          hintType == DecodeHintType.NEED_RESULT_POINT_CALLBACK ||
+          hintType == DecodeHintType.POSSIBLE_FORMATS) {
+        continue; // This hint is specified in another way
+      }
+
+      String parameterName = hintType.name();
+      String parameterText = parameters.get(parameterName);
+      if (parameterText == null) {
+        continue;
+      }
+      if (hintType.getValueType().equals(Object.class)) {
+        // This is an unspecified type of hint content. Use the value as is.
+        // TODO: Can we make a different assumption on this?
+        hints.put(hintType, parameterText);
+        continue;
+      }
+      if (hintType.getValueType().equals(Void.class)) {
+        // Void hints are just flags: use the constant specified by DecodeHintType
+        hints.put(hintType, Boolean.TRUE);
+        continue;
+      }
+      if (hintType.getValueType().equals(String.class)) {
+        // A string hint: use the decoded value.
+        hints.put(hintType, parameterText);
+        continue;
+      }
+      if (hintType.getValueType().equals(Boolean.class)) {
+        // A boolean hint: a few values for false, everything else is true.
+        // An empty parameter is simply a flag-style parameter, assuming true
+        if (parameterText.isEmpty()) {
+          hints.put(hintType, Boolean.TRUE);
+        } else if ("0".equals(parameterText) || 
+                   "false".equalsIgnoreCase(parameterText) || 
+                   "no".equalsIgnoreCase(parameterText)) {
+          hints.put(hintType, Boolean.FALSE);
+        } else {
+          hints.put(hintType, Boolean.TRUE);
+        }
+
+        continue;
+      }
+      if (hintType.getValueType().equals(int[].class)) {
+        // An integer array. Used to specify valid lengths.
+        // Strip a trailing comma as in Java style array initialisers.
+        if (!parameterText.isEmpty() && parameterText.charAt(parameterText.length() - 1) == ',') {
+          parameterText = parameterText.substring(0, parameterText.length() - 1);
+        }
+        String[] values = COMMA.split(parameterText);
+        int[] array = new int[values.length];
+        for (int i = 0; i < values.length; i++) {
+          try {
+            array[i] = Integer.parseInt(values[i]);
+          } catch (NumberFormatException ignored) {
+            Log.w(TAG, "Skipping array of integers hint " + hintType + " due to invalid numeric value: '" + values[i] + '\'');
+            array = null;
+            break;
+          }
+        }
+        if (array != null) {
+          hints.put(hintType, array);
+        }
+        continue;
+      } 
+      Log.w(TAG, "Unsupported hint type '" + hintType + "' of type " + hintType.getValueType());
+    }
+
+    Log.i(TAG, "Hints from the URI: " + hints);
+    return hints;
+  }
+
+  static Map<DecodeHintType, Object> parseDecodeHints(Intent intent) {
+    Bundle extras = intent.getExtras();
+    if (extras == null || extras.isEmpty()) {
+      return null;
+    }
+    Map<DecodeHintType,Object> hints = new EnumMap<>(DecodeHintType.class);
+
+    for (DecodeHintType hintType: DecodeHintType.values()) {
+
+      if (hintType == DecodeHintType.CHARACTER_SET ||
+          hintType == DecodeHintType.NEED_RESULT_POINT_CALLBACK ||
+          hintType == DecodeHintType.POSSIBLE_FORMATS) {
+        continue; // This hint is specified in another way
+      }
+
+      String hintName = hintType.name();
+      if (extras.containsKey(hintName)) {
+        if (hintType.getValueType().equals(Void.class)) {
+          // Void hints are just flags: use the constant specified by the DecodeHintType
+          hints.put(hintType, Boolean.TRUE);
+        } else {
+          Object hintData = extras.get(hintName);
+          if (hintType.getValueType().isInstance(hintData)) {
+            hints.put(hintType, hintData);
+          } else {
+            Log.w(TAG, "Ignoring hint " + hintType + " because it is not assignable from " + hintData);
+          }
+        }
+      }
+    }
+
+    Log.i(TAG, "Hints from the Intent: " + hints);
+    return hints;
+  }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/DecodeThread.java b/src/com/android/documentsui/DSN/ui/common/barcode/DecodeThread.java
new file mode 100644
index 0000000..1d79f93
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/DecodeThread.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.content.SharedPreferences;
+import android.os.Handler;
+import android.os.Looper;
+import android.preference.PreferenceManager;
+import android.util.Log;
+
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.ResultPointCallback;
+
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * This thread does all the heavy lifting of decoding the images.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+final class DecodeThread extends Thread {
+
+    public static final String BARCODE_BITMAP = "barcode_bitmap";
+    public static final String BARCODE_SCALED_FACTOR = "barcode_scaled_factor";
+
+    private final CaptureActivity activity;
+    private final Map<DecodeHintType, Object> hints;
+    private Handler handler;
+    private final CountDownLatch handlerInitLatch;
+
+    DecodeThread(CaptureActivity activity,
+                 Collection<BarcodeFormat> decodeFormats,
+                 Map<DecodeHintType, ?> baseHints,
+                 String characterSet,
+                 ResultPointCallback resultPointCallback) {
+
+        this.activity = activity;
+        handlerInitLatch = new CountDownLatch(1);
+
+        hints = new EnumMap<>(DecodeHintType.class);
+        if (baseHints != null) {
+            hints.putAll(baseHints);
+        }
+
+        // The prefs can't change while the thread is running, so pick them up once here.
+        if (decodeFormats == null || decodeFormats.isEmpty()) {
+            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
+            decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
+
+            // 一维码: 商品
+            decodeFormats.addAll(DecodeFormatManager.PRODUCT_FORMATS);
+
+            // 一维码: 工业
+            decodeFormats.addAll(DecodeFormatManager.INDUSTRIAL_FORMATS);
+
+            // 二维码
+            decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);
+
+            // Data Matrix
+            decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);
+
+            // Aztec
+            decodeFormats.addAll(DecodeFormatManager.AZTEC_FORMATS);
+
+            // PDF417
+            decodeFormats.addAll(DecodeFormatManager.PDF417_FORMATS);
+        }
+        hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
+
+        if (characterSet != null) {
+            hints.put(DecodeHintType.CHARACTER_SET, characterSet);
+        }
+        hints.put(DecodeHintType.NEED_RESULT_POINT_CALLBACK, resultPointCallback);
+        Log.i("DecodeThread", "Hints: " + hints);
+    }
+
+    Handler getHandler() {
+        try {
+            handlerInitLatch.await();
+        } catch (InterruptedException ie) {
+            // continue?
+        }
+        return handler;
+    }
+
+    @Override
+    public void run() {
+        Looper.prepare();
+        handler = new DecodeHandler(activity, hints);
+        handlerInitLatch.countDown();
+        Looper.loop();
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/FinishListener.java b/src/com/android/documentsui/DSN/ui/common/barcode/FinishListener.java
new file mode 100644
index 0000000..f1ced7f
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/FinishListener.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.app.Activity;
+import android.content.DialogInterface;
+
+/**
+ * Simple listener used to exit the app in a few cases.
+ *
+ * @author Sean Owen
+ */
+public final class FinishListener implements DialogInterface.OnClickListener, DialogInterface.OnCancelListener {
+
+  private final Activity activityToFinish;
+
+  public FinishListener(Activity activityToFinish) {
+    this.activityToFinish = activityToFinish;
+  }
+
+  @Override
+  public void onCancel(DialogInterface dialogInterface) {
+    run();
+  }
+
+  @Override
+  public void onClick(DialogInterface dialogInterface, int i) {
+    run();
+  }
+
+  private void run() {
+    activityToFinish.finish();
+  }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/Intents.java b/src/com/android/documentsui/DSN/ui/common/barcode/Intents.java
new file mode 100644
index 0000000..8fdbe7d
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/Intents.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+/**
+ * This class provides the constants to use when sending an Intent to Barcode Scanner.
+ * These strings are effectively API and cannot be changed.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class Intents {
+  private Intents() {
+  }
+
+  /**
+   * Constants related to the {@link Scan#ACTION} Intent.
+   */
+  public static final class Scan {
+    /**
+     * Send this intent to open the Barcodes app in scanning mode, find a barcode, and return
+     * the results.
+     */
+    public static final String ACTION = "com.njzhikejia.mabaojia.SCAN";
+
+    /**
+     * By default, sending this will decode all barcodes that we understand. However it
+     * may be useful to limit scanning to certain formats. Use
+     * {@link android.content.Intent#putExtra(String, String)} with one of the values below.
+     *
+     * Setting this is effectively shorthand for setting explicit formats with {@link #FORMATS}.
+     * It is overridden by that setting.
+     */
+    public static final String MODE = "SCAN_MODE";
+
+    /**
+     * Decode only UPC and EAN barcodes. This is the right choice for shopping apps which get
+     * prices, reviews, etc. for products.
+     */
+    public static final String PRODUCT_MODE = "PRODUCT_MODE";
+
+    /**
+     * Decode only 1D barcodes.
+     */
+    public static final String ONE_D_MODE = "ONE_D_MODE";
+
+    /**
+     * Decode only QR codes.
+     */
+    public static final String QR_CODE_MODE = "QR_CODE_MODE";
+
+    /**
+     * Decode only Data Matrix codes.
+     */
+    public static final String DATA_MATRIX_MODE = "DATA_MATRIX_MODE";
+
+    /**
+     * Decode only Aztec.
+     */
+    public static final String AZTEC_MODE = "AZTEC_MODE";
+
+    /**
+     * Decode only PDF417.
+     */
+    public static final String PDF417_MODE = "PDF417_MODE";
+
+    /**
+     * Comma-separated list of formats to scan for. The values must match the names of
+     * {@link com.google.zxing.BarcodeFormat}s, e.g. {@link com.google.zxing.BarcodeFormat#EAN_13}.
+     * Example: "EAN_13,EAN_8,QR_CODE". This overrides {@link #MODE}.
+     */
+    public static final String FORMATS = "SCAN_FORMATS";
+
+    /**
+     * Optional parameter to specify the id of the camera from which to recognize barcodes.
+     * Overrides the default camera that would otherwise would have been selected.
+     * If provided, should be an int.
+     */
+    public static final String CAMERA_ID = "SCAN_CAMERA_ID";
+
+    /**
+     * @see com.google.zxing.DecodeHintType#CHARACTER_SET
+     */
+    public static final String CHARACTER_SET = "CHARACTER_SET";
+
+    /**
+     * Optional parameters to specify the width and height of the scanning rectangle in pixels.
+     * The app will try to honor these, but will clamp them to the size of the preview frame.
+     * You should specify both or neither, and pass the size as an int.
+     */
+    public static final String WIDTH = "SCAN_WIDTH";
+    public static final String HEIGHT = "SCAN_HEIGHT";
+
+    /**
+     * Desired duration in milliseconds for which to pause after a successful scan before
+     * returning to the calling intent. Specified as a long, not an integer!
+     * For example: 1000L, not 1000.
+     */
+    public static final String RESULT_DISPLAY_DURATION_MS = "RESULT_DISPLAY_DURATION_MS";
+
+    /**
+     * Prompt to show on-screen when scanning by intent. Specified as a {@link String}.
+     */
+    public static final String PROMPT_MESSAGE = "PROMPT_MESSAGE";
+
+    /**
+     * If a barcode is found, Barcodes returns {@link android.app.Activity#RESULT_OK} to
+     * {@link android.app.Activity#onActivityResult(int, int, android.content.Intent)}
+     * of the app which requested the scan via
+     * {@link android.app.Activity#startActivityForResult(android.content.Intent, int)}
+     * The barcodes contents can be retrieved with
+     * {@link android.content.Intent#getStringExtra(String)}.
+     * If the user presses Back, the result code will be {@link android.app.Activity#RESULT_CANCELED}.
+     */
+    public static final String RESULT = "SCAN_RESULT";
+
+    /**
+     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_FORMAT}
+     * to determine which barcode format was found.
+     * See {@link com.google.zxing.BarcodeFormat} for possible values.
+     */
+    public static final String RESULT_FORMAT = "SCAN_RESULT_FORMAT";
+
+    /**
+     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_UPC_EAN_EXTENSION}
+     * to return the content of any UPC extension barcode that was also found. Only applicable
+     * to {@link com.google.zxing.BarcodeFormat#UPC_A} and {@link com.google.zxing.BarcodeFormat#EAN_13}
+     * formats.
+     */
+    public static final String RESULT_UPC_EAN_EXTENSION = "SCAN_RESULT_UPC_EAN_EXTENSION";
+
+    /**
+     * Call {@link android.content.Intent#getByteArrayExtra(String)} with {@link #RESULT_BYTES}
+     * to get a {@code byte[]} of raw bytes in the barcode, if available.
+     */
+    public static final String RESULT_BYTES = "SCAN_RESULT_BYTES";
+
+    /**
+     * Key for the value of {@link com.google.zxing.ResultMetadataType#ORIENTATION}, if available.
+     * Call {@link android.content.Intent#getIntArrayExtra(String)} with {@link #RESULT_ORIENTATION}.
+     */
+    public static final String RESULT_ORIENTATION = "SCAN_RESULT_ORIENTATION";
+
+    /**
+     * Key for the value of {@link com.google.zxing.ResultMetadataType#ERROR_CORRECTION_LEVEL}, if available.
+     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_ERROR_CORRECTION_LEVEL}.
+     */
+    public static final String RESULT_ERROR_CORRECTION_LEVEL = "SCAN_RESULT_ERROR_CORRECTION_LEVEL";
+
+    /**
+     * Prefix for keys that map to the values of {@link com.google.zxing.ResultMetadataType#BYTE_SEGMENTS},
+     * if available. The actual values will be set under a series of keys formed by adding 0, 1, 2, ...
+     * to this prefix. So the first byte segment is under key "SCAN_RESULT_BYTE_SEGMENTS_0" for example.
+     * Call {@link android.content.Intent#getByteArrayExtra(String)} with these keys.
+     */
+    public static final String RESULT_BYTE_SEGMENTS_PREFIX = "SCAN_RESULT_BYTE_SEGMENTS_";
+
+    /**
+     * Setting this to false will not save scanned codes in the history. Specified as a {@code boolean}.
+     */
+    public static final String SAVE_HISTORY = "SAVE_HISTORY";
+
+    private Scan() {
+    }
+  }
+
+  /**
+   * Constants related to the scan history and retrieving history items.
+   */
+  public static final class History {
+
+    public static final String ITEM_NUMBER = "ITEM_NUMBER";
+
+    private History() {
+    }
+  }
+
+  /**
+   * Constants related to the {@link Encode#ACTION} Intent.
+   */
+  public static final class Encode {
+    /**
+     * Send this intent to encode a piece of data as a QR code and display it full screen, so
+     * that another person can scan the barcode from your screen.
+     */
+    public static final String ACTION = "com.google.zxing.client.android.ENCODE";
+
+    /**
+     * The data to encode. Use {@link android.content.Intent#putExtra(String, String)} or
+     * {@link android.content.Intent#putExtra(String, android.os.Bundle)},
+     * depending on the type and format specified. Non-QR Code formats should
+     * just use a String here. For QR Code, see Contents for details.
+     */
+    public static final String DATA = "ENCODE_DATA";
+
+    /**
+     * The type of data being supplied if the format is QR Code. Use
+     * {@link android.content.Intent#putExtra(String, String)} with one of {@link Contents.Type}.
+     */
+    public static final String TYPE = "ENCODE_TYPE";
+
+    /**
+     * The barcode format to be displayed. If this isn't specified or is blank,
+     * it defaults to QR Code. Use {@link android.content.Intent#putExtra(String, String)}, where
+     * format is one of {@link com.google.zxing.BarcodeFormat}.
+     */
+    public static final String FORMAT = "ENCODE_FORMAT";
+
+    /**
+     * Normally the contents of the barcode are displayed to the user in a TextView. Setting this
+     * boolean to false will hide that TextView, showing only the encode barcode.
+     */
+    public static final String SHOW_CONTENTS = "ENCODE_SHOW_CONTENTS";
+
+    private Encode() {
+    }
+  }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/LocaleManager.java b/src/com/android/documentsui/DSN/ui/common/barcode/LocaleManager.java
new file mode 100644
index 0000000..7a8406e
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/LocaleManager.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.content.Context;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * Handles any locale-specific logic for the client.
+ *
+ * @author Sean Owen
+ */
+public final class LocaleManager {
+
+  private static final String DEFAULT_TLD = "com";
+  private static final String DEFAULT_COUNTRY = "US";
+  private static final String DEFAULT_LANGUAGE = "en";
+
+  /**
+   * Locales (well, countries) where Google web search is available.
+   * These should be kept in sync with our translations.
+   */
+  private static final Map<String,String> GOOGLE_COUNTRY_TLD;
+  static {
+    GOOGLE_COUNTRY_TLD = new HashMap<>();
+    GOOGLE_COUNTRY_TLD.put("AR", "com.ar"); // ARGENTINA
+    GOOGLE_COUNTRY_TLD.put("AU", "com.au"); // AUSTRALIA
+    GOOGLE_COUNTRY_TLD.put("BR", "com.br"); // BRAZIL
+    GOOGLE_COUNTRY_TLD.put("BG", "bg"); // BULGARIA
+    GOOGLE_COUNTRY_TLD.put(Locale.CANADA.getCountry(), "ca");
+    GOOGLE_COUNTRY_TLD.put(Locale.CHINA.getCountry(), "cn");
+    GOOGLE_COUNTRY_TLD.put("CZ", "cz"); // CZECH REPUBLIC
+    GOOGLE_COUNTRY_TLD.put("DK", "dk"); // DENMARK
+    GOOGLE_COUNTRY_TLD.put("FI", "fi"); // FINLAND
+    GOOGLE_COUNTRY_TLD.put(Locale.FRANCE.getCountry(), "fr");
+    GOOGLE_COUNTRY_TLD.put(Locale.GERMANY.getCountry(), "de");
+    GOOGLE_COUNTRY_TLD.put("GR", "gr"); // GREECE
+    GOOGLE_COUNTRY_TLD.put("HU", "hu"); // HUNGARY
+    GOOGLE_COUNTRY_TLD.put("ID", "co.id"); // INDONESIA
+    GOOGLE_COUNTRY_TLD.put("IL", "co.il"); // ISRAEL
+    GOOGLE_COUNTRY_TLD.put(Locale.ITALY.getCountry(), "it");
+    GOOGLE_COUNTRY_TLD.put(Locale.JAPAN.getCountry(), "co.jp");
+    GOOGLE_COUNTRY_TLD.put(Locale.KOREA.getCountry(), "co.kr");
+    GOOGLE_COUNTRY_TLD.put("NL", "nl"); // NETHERLANDS
+    GOOGLE_COUNTRY_TLD.put("PL", "pl"); // POLAND
+    GOOGLE_COUNTRY_TLD.put("PT", "pt"); // PORTUGAL
+    GOOGLE_COUNTRY_TLD.put("RO", "ro"); // ROMANIA    
+    GOOGLE_COUNTRY_TLD.put("RU", "ru"); // RUSSIA
+    GOOGLE_COUNTRY_TLD.put("SK", "sk"); // SLOVAK REPUBLIC
+    GOOGLE_COUNTRY_TLD.put("SI", "si"); // SLOVENIA
+    GOOGLE_COUNTRY_TLD.put("ES", "es"); // SPAIN
+    GOOGLE_COUNTRY_TLD.put("SE", "se"); // SWEDEN
+    GOOGLE_COUNTRY_TLD.put("CH", "ch"); // SWITZERLAND    
+    GOOGLE_COUNTRY_TLD.put(Locale.TAIWAN.getCountry(), "tw");
+    GOOGLE_COUNTRY_TLD.put("TR", "com.tr"); // TURKEY
+    GOOGLE_COUNTRY_TLD.put("UA", "com.ua"); // UKRAINE
+    GOOGLE_COUNTRY_TLD.put(Locale.UK.getCountry(), "co.uk");
+    GOOGLE_COUNTRY_TLD.put(Locale.US.getCountry(), "com");
+  }
+
+  /**
+   * Google Product Search for mobile is available in fewer countries than web search. See here:
+   * http://support.google.com/merchants/bin/answer.py?hl=en-GB&answer=160619
+   */
+  private static final Map<String,String> GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD;
+  static {
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD = new HashMap<>();
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("AU", "com.au"); // AUSTRALIA
+    //GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.CHINA.getCountry(), "cn");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.FRANCE.getCountry(), "fr");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.GERMANY.getCountry(), "de");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.ITALY.getCountry(), "it");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.JAPAN.getCountry(), "co.jp");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("NL", "nl"); // NETHERLANDS
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("ES", "es"); // SPAIN
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("CH", "ch"); // SWITZERLAND
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.UK.getCountry(), "co.uk");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.US.getCountry(), "com");
+  }
+
+  /**
+   * Book search is offered everywhere that web search is available.
+   */
+  private static final Map<String,String> GOOGLE_BOOK_SEARCH_COUNTRY_TLD = GOOGLE_COUNTRY_TLD;
+
+  private static final Collection<String> TRANSLATED_HELP_ASSET_LANGUAGES =
+      Arrays.asList("de", "en", "es", "fr", "it", "ja", "ko", "nl", "pt", "ru", "uk", "zh-rCN", "zh-rTW", "zh-rHK");
+
+  private LocaleManager() {}
+
+  /**
+   * @param context application's {@link Context}
+   * @return country-specific TLD suffix appropriate for the current default locale
+   *  (e.g. "co.uk" for the United Kingdom)
+   */
+  public static String getCountryTLD(Context context) {
+    return doGetTLD(GOOGLE_COUNTRY_TLD, context);
+  }
+
+  /**
+   * The same as above, but specifically for Google Product Search.
+   *
+   * @param context application's {@link Context}
+   * @return The top-level domain to use.
+   */
+  public static String getProductSearchCountryTLD(Context context) {
+    return doGetTLD(GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD, context);
+  }
+
+  /**
+   * The same as above, but specifically for Google Book Search.
+   *
+   * @param context application's {@link Context}
+   * @return The top-level domain to use.
+   */
+  public static String getBookSearchCountryTLD(Context context) {
+    return doGetTLD(GOOGLE_BOOK_SEARCH_COUNTRY_TLD, context);
+  }
+
+  /**
+   * Does a given URL point to Google Book Search, regardless of domain.
+   *
+   * @param url The address to check.
+   * @return True if this is a Book Search URL.
+   */
+  public static boolean isBookSearchUrl(String url) {
+    return url.startsWith("http://google.com/books") || url.startsWith("http://books.google.");
+  }
+
+  private static String getSystemCountry() {
+    Locale locale = Locale.getDefault();
+    return locale == null ? DEFAULT_COUNTRY : locale.getCountry();
+  }
+
+  private static String getSystemLanguage() {
+    Locale locale = Locale.getDefault();
+    if (locale == null) {
+      return DEFAULT_LANGUAGE;
+    }
+    String language = locale.getLanguage();
+    // Special case Chinese
+    if (Locale.SIMPLIFIED_CHINESE.getLanguage().equals(language)) {
+      return language + "-r" + getSystemCountry();
+    }
+    return language;
+  }
+
+  static String getTranslatedAssetLanguage() {
+    String language = getSystemLanguage();
+    return TRANSLATED_HELP_ASSET_LANGUAGES.contains(language) ? language : DEFAULT_LANGUAGE;
+  }
+
+  private static String doGetTLD(Map<String,String> map, Context context) {
+    String tld = map.get(getCountry(context));
+    return tld == null ? DEFAULT_TLD : tld;
+  }
+
+  private static String getCountry(Context context) {
+    String countryOverride = "-";
+    if (!countryOverride.isEmpty() && !"-".equals(countryOverride)) {
+      return countryOverride;
+    }
+    return getSystemCountry();
+  }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/ViewfinderResultPointCallback.java b/src/com/android/documentsui/DSN/ui/common/barcode/ViewfinderResultPointCallback.java
new file mode 100644
index 0000000..759c110
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/ViewfinderResultPointCallback.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2009 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import com.google.zxing.ResultPoint;
+import com.google.zxing.ResultPointCallback;
+
+final class ViewfinderResultPointCallback implements ResultPointCallback {
+
+    private final ViewfinderView viewfinderView;
+
+    ViewfinderResultPointCallback(ViewfinderView viewfinderView) {
+        this.viewfinderView = viewfinderView;
+    }
+
+    @Override
+    public void foundPossibleResultPoint(ResultPoint point) {
+        viewfinderView.addPossibleResultPoint(point);
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/ViewfinderView.java b/src/com/android/documentsui/DSN/ui/common/barcode/ViewfinderView.java
new file mode 100644
index 0000000..84d8458
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/ViewfinderView.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.util.AttributeSet;
+import android.view.View;
+
+import com.google.zxing.ResultPoint;
+
+import java.util.Collection;
+import java.util.HashSet;
+
+import com.android.documentsui.R;
+import com.android.documentsui.DSN.ui.common.barcode.camera.CameraManager;
+
+
+/**
+ * This view is overlaid on top of the camera preview. It adds the viewfinder rectangle and partial
+ * transparency outside it, as well as the laser scanner animation and result points.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ViewfinderView extends View {
+    private CameraManager cameraManager;
+
+    private static final long ANIMATION_DELAY = 10L;
+    private static final int OPAQUE = 0xFF;
+
+    private int ScreenRate;
+    private static final int CORNER_WIDTH = 10;
+    private static final int MIDDLE_LINE_WIDTH = 4;
+    private static final int MIDDLE_LINE_PADDING = 5;
+    private static final int SPEEN_DISTANCE = 5;
+    private static float density;
+
+
+    private Paint paint;
+    private int slideTop;
+    private int slideBottom;
+
+    private Bitmap resultBitmap;
+    private final int maskColor;
+    private final int resultColor;
+
+    private final int resultPointColor;
+    private Collection<ResultPoint> possibleResultPoints;
+    private Collection<ResultPoint> lastPossibleResultPoints;
+
+    boolean isFirst;
+
+    public ViewfinderView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        density = context.getResources().getDisplayMetrics().density;
+        ScreenRate = (int)(20 * density);
+
+        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        Resources resources = getResources();
+        maskColor = resources.getColor(R.color.viewfinder_mask);
+        resultColor = resources.getColor(R.color.result_view);
+
+        resultPointColor = resources.getColor(R.color.possible_result_points);
+        possibleResultPoints = new HashSet<ResultPoint>(5);
+    }
+
+    public void setCameraManager(CameraManager cameraManager) {
+        this.cameraManager = cameraManager;
+    }
+
+    @SuppressLint("DrawAllocation")
+    @Override
+    public void onDraw(Canvas canvas) {
+        if (cameraManager == null) {
+            return; // not ready yet, early draw before done configuring
+        }
+        Rect frame = cameraManager.getFramingRect();
+        if (frame == null) {
+            return;
+        }
+
+        if(!isFirst){
+            isFirst = true;
+            slideTop = frame.top;
+            slideBottom = frame.bottom;
+        }
+
+        int width = canvas.getWidth();
+        int height = canvas.getHeight();
+
+        paint.setColor(resultBitmap != null ? resultColor : maskColor);
+
+        canvas.drawRect(0, 0, width, frame.top, paint);
+        canvas.drawRect(0, frame.top, frame.left, frame.bottom + 1, paint);
+        canvas.drawRect(frame.right + 1, frame.top, width, frame.bottom + 1,
+                paint);
+        canvas.drawRect(0, frame.bottom + 1, width, height, paint);
+
+        if (resultBitmap == null) {
+            paint.setColor(getResources().getColor(R.color.colorAccent));
+            canvas.drawRect(frame.left, frame.top, frame.left + ScreenRate,
+                    frame.top + CORNER_WIDTH, paint);
+            canvas.drawRect(frame.left, frame.top, frame.left + CORNER_WIDTH, frame.top
+                    + ScreenRate, paint);
+            canvas.drawRect(frame.right - ScreenRate, frame.top, frame.right,
+                    frame.top + CORNER_WIDTH, paint);
+            canvas.drawRect(frame.right - CORNER_WIDTH, frame.top, frame.right, frame.top
+                    + ScreenRate, paint);
+            canvas.drawRect(frame.left, frame.bottom - CORNER_WIDTH, frame.left
+                    + ScreenRate, frame.bottom, paint);
+            canvas.drawRect(frame.left, frame.bottom - ScreenRate,
+                    frame.left + CORNER_WIDTH, frame.bottom, paint);
+            canvas.drawRect(frame.right - ScreenRate, frame.bottom - CORNER_WIDTH,
+                    frame.right, frame.bottom, paint);
+            canvas.drawRect(frame.right - CORNER_WIDTH, frame.bottom - ScreenRate,
+                    frame.right, frame.bottom, paint);
+
+            slideTop += SPEEN_DISTANCE;
+            if(slideTop >= frame.bottom){
+                slideTop = frame.top;
+            }
+            Paint linePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            linePaint.setColor(getResources().getColor(R.color.colorAccent));
+            canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2, frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, linePaint);
+
+            Collection<ResultPoint> currentPossible = possibleResultPoints;
+            Collection<ResultPoint> currentLast = lastPossibleResultPoints;
+            if (currentPossible.isEmpty()) {
+                lastPossibleResultPoints = null;
+            } else {
+                possibleResultPoints = new HashSet<ResultPoint>(5);
+                lastPossibleResultPoints = currentPossible;
+                paint.setAlpha(OPAQUE);
+                paint.setColor(resultPointColor);
+                for (ResultPoint point : currentPossible) {
+                    canvas.drawCircle(frame.left + point.getX(), frame.top
+                            + point.getY(), 6.0f, paint);
+                }
+            }
+            if (currentLast != null) {
+                paint.setAlpha(OPAQUE / 2);
+                paint.setColor(resultPointColor);
+                for (ResultPoint point : currentLast) {
+                    canvas.drawCircle(frame.left + point.getX(), frame.top
+                            + point.getY(), 3.0f, paint);
+                }
+            }
+
+            postInvalidateDelayed(ANIMATION_DELAY, frame.left, frame.top,
+                    frame.right, frame.bottom);
+        }
+    }
+
+    public void drawViewfinder() {
+        resultBitmap = null;
+        invalidate();
+    }
+
+    /**
+     * Draw a bitmap with the result points highlighted instead of the live scanning display.
+     *
+     * @param barcode An image of the decoded barcode.
+     */
+    public void drawResultBitmap(Bitmap barcode) {
+        resultBitmap = barcode;
+        invalidate();
+    }
+
+    public void addPossibleResultPoint(ResultPoint point) {
+        possibleResultPoints.add(point);
+    }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/camera/AutoFocusManager.java b/src/com/android/documentsui/DSN/ui/common/barcode/camera/AutoFocusManager.java
new file mode 100644
index 0000000..2a27710
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/camera/AutoFocusManager.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2012 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.camera;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.hardware.Camera;
+import android.os.AsyncTask;
+import android.preference.PreferenceManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.concurrent.RejectedExecutionException;
+
+
+final class AutoFocusManager implements Camera.AutoFocusCallback {
+
+    private static final String TAG = AutoFocusManager.class.getSimpleName();
+
+    private static final long AUTO_FOCUS_INTERVAL_MS = 1000L;
+    private static final Collection<String> FOCUS_MODES_CALLING_AF;
+
+    static {
+        FOCUS_MODES_CALLING_AF = new ArrayList<>(2);
+        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_AUTO);
+        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_MACRO);
+    }
+
+    private boolean stopped;
+    private boolean focusing;
+    private final boolean useAutoFocus;
+    private final Camera camera;
+    private AsyncTask<?, ?, ?> outstandingTask;
+
+    AutoFocusManager(Context context, Camera camera) {
+        this.camera = camera;
+        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(context);
+        String currentFocusMode = camera.getParameters().getFocusMode();
+        useAutoFocus = FOCUS_MODES_CALLING_AF.contains(currentFocusMode);
+        Log.i(TAG, "Current focus mode '" + currentFocusMode + "'; use auto focus? " + useAutoFocus);
+        start();
+    }
+
+    @Override
+    public synchronized void onAutoFocus(boolean success, Camera theCamera) {
+        focusing = false;
+        autoFocusAgainLater();
+    }
+
+    private synchronized void autoFocusAgainLater() {
+        if (!stopped && outstandingTask == null) {
+            AutoFocusTask newTask = new AutoFocusTask();
+            try {
+                newTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+                outstandingTask = newTask;
+            } catch (RejectedExecutionException ree) {
+                Log.w(TAG, "Could not request auto focus", ree);
+            }
+        }
+    }
+
+    synchronized void start() {
+        if (useAutoFocus) {
+            outstandingTask = null;
+            if (!stopped && !focusing) {
+                try {
+                    camera.autoFocus(this);
+                    focusing = true;
+                } catch (RuntimeException re) {
+                    // Have heard RuntimeException reported in Android 4.0.x+; continue?
+                    Log.w(TAG, "Unexpected exception while focusing", re);
+                    // Try again later to keep cycle going
+                    autoFocusAgainLater();
+                }
+            }
+        }
+    }
+
+    private synchronized void cancelOutstandingTask() {
+        if (outstandingTask != null) {
+            if (outstandingTask.getStatus() != AsyncTask.Status.FINISHED) {
+                outstandingTask.cancel(true);
+            }
+            outstandingTask = null;
+        }
+    }
+
+    synchronized void stop() {
+        stopped = true;
+        if (useAutoFocus) {
+            cancelOutstandingTask();
+            // Doesn't hurt to call this even if not focusing
+            try {
+                camera.cancelAutoFocus();
+            } catch (RuntimeException re) {
+                // Have heard RuntimeException reported in Android 4.0.x+; continue?
+                Log.w(TAG, "Unexpected exception while cancelling focusing", re);
+            }
+        }
+    }
+
+    private final class AutoFocusTask extends AsyncTask<Object, Object, Object> {
+        @Override
+        protected Object doInBackground(Object... voids) {
+            try {
+                Thread.sleep(AUTO_FOCUS_INTERVAL_MS);
+            } catch (InterruptedException e) {
+                // continue
+            }
+            start();
+            return null;
+        }
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraConfigurationManager.java b/src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraConfigurationManager.java
new file mode 100644
index 0000000..93054ac
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraConfigurationManager.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.camera;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.hardware.Camera;
+import android.util.Log;
+import android.view.Display;
+import android.view.Surface;
+import android.view.WindowManager;
+
+import com.android.documentsui.DSN.ui.common.barcode.camera.open.CameraFacing;
+import com.android.documentsui.DSN.ui.common.barcode.camera.open.OpenCamera;
+
+
+/**
+ * A class which deals with reading, parsing, and setting the camera parameters which are used to
+ * configure the camera hardware.
+ */
+final class CameraConfigurationManager {
+
+    private static final String TAG = "CameraConfiguration";
+
+    private final Context context;
+    private int cwNeededRotation;
+    private int cwRotationFromDisplayToCamera;
+    private Point screenResolution;
+    private Point cameraResolution;
+    private Point bestPreviewSize;
+    private Point previewSizeOnScreen;
+
+    CameraConfigurationManager(Context context) {
+        this.context = context;
+    }
+
+    /**
+     * Reads, one time, values from the camera that are needed by the app.
+     */
+    void initFromCameraParameters(OpenCamera camera) {
+        Camera.Parameters parameters = camera.getCamera().getParameters();
+        WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = manager.getDefaultDisplay();
+
+        // 判断屏幕方向，是否有需要从自然角度旋转到显示器角度
+        int displayRotation = display.getRotation();
+        int cwRotationFromNaturalToDisplay;
+        switch (displayRotation) {
+            case Surface.ROTATION_0:
+                cwRotationFromNaturalToDisplay = 0;
+                break;
+            case Surface.ROTATION_90:
+                cwRotationFromNaturalToDisplay = 90;
+                break;
+            case Surface.ROTATION_180:
+                cwRotationFromNaturalToDisplay = 180;
+                break;
+            case Surface.ROTATION_270:
+                cwRotationFromNaturalToDisplay = 270;
+                break;
+            default:
+                // Have seen this return incorrect values like -90
+                if (displayRotation % 90 == 0) {
+                    cwRotationFromNaturalToDisplay = (360 + displayRotation) % 360;
+                } else {
+                    throw new IllegalArgumentException("Bad rotation: " + displayRotation);
+                }
+        }
+        Log.i(TAG, "Display at: " + cwRotationFromNaturalToDisplay);
+
+        // 判断相机的方向，根据前后摄像机判断是否有需要旋转
+        int cwRotationFromNaturalToCamera = camera.getOrientation();
+        Log.i(TAG, "Camera at: " + cwRotationFromNaturalToCamera);
+
+        // Still not 100% sure about this. But acts like we need to flip this:
+        if (camera.getFacing() == CameraFacing.FRONT) {
+            cwRotationFromNaturalToCamera = (360 - cwRotationFromNaturalToCamera) % 360;
+            Log.i(TAG, "Front camera overriden to: " + cwRotationFromNaturalToCamera);
+        }
+
+        // 根据屏幕方向和相机方向判断是否有需要进行旋转
+        cwRotationFromDisplayToCamera =
+                (360 + cwRotationFromNaturalToCamera - cwRotationFromNaturalToDisplay) % 360;
+        Log.i(TAG, "Final display orientation: " + cwRotationFromDisplayToCamera);
+        if (camera.getFacing() == CameraFacing.FRONT) {
+            Log.i(TAG, "Compensating rotation for front camera");
+            cwNeededRotation = (360 - cwRotationFromDisplayToCamera) % 360;
+        } else {
+            cwNeededRotation = cwRotationFromDisplayToCamera;
+        }
+        Log.i(TAG, "Clockwise rotation from display to camera: " + cwNeededRotation);
+
+        Point theScreenResolution = new Point();
+        display.getSize(theScreenResolution);
+        screenResolution = theScreenResolution;
+        Log.i(TAG, "Screen resolution in current orientation: " + screenResolution);
+
+        // 寻找最佳的预览宽高值
+        cameraResolution = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);
+        Log.i(TAG, "Camera resolution: " + cameraResolution);
+        bestPreviewSize = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);
+        Log.i(TAG, "Best available preview size: " + bestPreviewSize);
+
+        boolean isScreenPortrait = screenResolution.x < screenResolution.y;
+        boolean isPreviewSizePortrait = bestPreviewSize.x < bestPreviewSize.y;
+
+        if (isScreenPortrait == isPreviewSizePortrait) {
+            previewSizeOnScreen = bestPreviewSize;
+        } else {
+            previewSizeOnScreen = new Point(bestPreviewSize.y, bestPreviewSize.x);
+        }
+        Log.i(TAG, "Preview size on screen: " + previewSizeOnScreen);
+    }
+
+    void setDesiredCameraParameters(OpenCamera camera, boolean safeMode) {
+
+        Camera theCamera = camera.getCamera();
+        Camera.Parameters parameters = theCamera.getParameters();
+
+        if (parameters == null) {
+            Log.w(TAG, "Device error: no camera parameters are available. Proceeding without configuration.");
+            return;
+        }
+
+        Log.i(TAG, "Initial camera parameters: " + parameters.flatten());
+
+        if (safeMode) {
+            Log.w(TAG, "In camera config safe mode -- most settings will not be honored");
+        }
+
+        initializeTorch(parameters);
+
+        // 设置对焦功能
+        CameraConfigurationUtils.setFocus(parameters, true, true, safeMode);
+
+        if (!safeMode) {
+            // 不需要进行条形码场景匹配
+            CameraConfigurationUtils.setBarcodeSceneMode(parameters);
+
+            // 不使用距离测量
+            CameraConfigurationUtils.setVideoStabilization(parameters);
+            CameraConfigurationUtils.setFocusArea(parameters);
+            CameraConfigurationUtils.setMetering(parameters);
+        }
+
+        //parameters.setPreviewSize(bestPreviewSize.x, bestPreviewSize.y);
+
+        //theCamera.setParameters(parameters);
+
+        theCamera.setDisplayOrientation(cwRotationFromDisplayToCamera);
+
+        Camera.Parameters afterParameters = theCamera.getParameters();
+        Camera.Size afterSize = afterParameters.getPreviewSize();
+        if (afterSize != null && (bestPreviewSize.x != afterSize.width || bestPreviewSize.y != afterSize.height)) {
+            Log.w(TAG, "Camera said it supported preview size " + bestPreviewSize.x + 'x' + bestPreviewSize.y +
+                    ", but after setting it, preview size is " + afterSize.width + 'x' + afterSize.height);
+            bestPreviewSize.x = afterSize.width;
+            bestPreviewSize.y = afterSize.height;
+        }
+    }
+
+    Point getBestPreviewSize() {
+        return bestPreviewSize;
+    }
+
+    Point getPreviewSizeOnScreen() {
+        return previewSizeOnScreen;
+    }
+
+    Point getCameraResolution() {
+        return cameraResolution;
+    }
+
+    Point getScreenResolution() {
+        return screenResolution;
+    }
+
+    int getCWNeededRotation() {
+        return cwNeededRotation;
+    }
+
+    boolean getTorchState(Camera camera) {
+        if (camera != null) {
+            Camera.Parameters parameters = camera.getParameters();
+            if (parameters != null) {
+                String flashMode = parameters.getFlashMode();
+                return flashMode != null &&
+                        (Camera.Parameters.FLASH_MODE_ON.equals(flashMode) ||
+                                Camera.Parameters.FLASH_MODE_TORCH.equals(flashMode));
+            }
+        }
+        return false;
+    }
+
+    void setTorch(Camera camera, boolean newSetting) {
+        Camera.Parameters parameters = camera.getParameters();
+        doSetTorch(parameters, newSetting);
+        camera.setParameters(parameters);
+    }
+
+    private void initializeTorch(Camera.Parameters parameters) {
+        doSetTorch(parameters, false);
+    }
+
+    private void doSetTorch(Camera.Parameters parameters, boolean newSetting) {
+        CameraConfigurationUtils.setTorch(parameters, newSetting);
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraConfigurationUtils.java b/src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraConfigurationUtils.java
new file mode 100644
index 0000000..ae2458a
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraConfigurationUtils.java
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2014 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.camera;
+
+import android.annotation.TargetApi;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.hardware.Camera;
+import android.os.Build;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.regex.Pattern;
+
+/**
+ * Utility methods for configuring the Android camera.
+ *
+ * @author Sean Owen
+ */
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+public final class CameraConfigurationUtils {
+
+    private static final String TAG = "CameraConfiguration";
+
+    private static final Pattern SEMICOLON = Pattern.compile(";");
+
+    private static final int MIN_PREVIEW_PIXELS = 480 * 320; // normal screen
+    private static final float MAX_EXPOSURE_COMPENSATION = 1.5f;
+    private static final float MIN_EXPOSURE_COMPENSATION = 0.0f;
+    private static final double MAX_ASPECT_DISTORTION = 0.15;
+    private static final int MIN_FPS = 10;
+    private static final int MAX_FPS = 20;
+    private static final int AREA_PER_1000 = 400;
+
+    private CameraConfigurationUtils() {
+    }
+
+    public static void setFocus(Camera.Parameters parameters,
+                                boolean autoFocus,
+                                boolean disableContinuous,
+                                boolean safeMode) {
+        List<String> supportedFocusModes = parameters.getSupportedFocusModes();
+        String focusMode = null;
+        if (autoFocus) {
+            if (safeMode || disableContinuous) {
+                focusMode = findSettableValue("focus mode",
+                        supportedFocusModes,
+                        Camera.Parameters.FOCUS_MODE_AUTO);
+            } else {
+                focusMode = findSettableValue("focus mode",
+                        supportedFocusModes,
+                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,
+                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO,
+                        Camera.Parameters.FOCUS_MODE_AUTO);
+            }
+        }
+        // Maybe selected auto-focus but not available, so fall through here:
+        if (!safeMode && focusMode == null) {
+            focusMode = findSettableValue("focus mode",
+                    supportedFocusModes,
+                    Camera.Parameters.FOCUS_MODE_MACRO,
+                    Camera.Parameters.FOCUS_MODE_EDOF);
+        }
+        if (focusMode != null) {
+            if (focusMode.equals(parameters.getFocusMode())) {
+                Log.i(TAG, "Focus mode already set to " + focusMode);
+            } else {
+                parameters.setFocusMode(focusMode);
+            }
+        }
+    }
+
+    public static void setTorch(Camera.Parameters parameters, boolean on) {
+        List<String> supportedFlashModes = parameters.getSupportedFlashModes();
+        String flashMode;
+        if (on) {
+            flashMode = findSettableValue("flash mode",
+                    supportedFlashModes,
+                    Camera.Parameters.FLASH_MODE_TORCH,
+                    Camera.Parameters.FLASH_MODE_ON);
+        } else {
+            flashMode = findSettableValue("flash mode",
+                    supportedFlashModes,
+                    Camera.Parameters.FLASH_MODE_OFF);
+        }
+        if (flashMode != null) {
+            if (flashMode.equals(parameters.getFlashMode())) {
+                Log.i(TAG, "Flash mode already set to " + flashMode);
+            } else {
+                Log.i(TAG, "Setting flash mode to " + flashMode);
+                parameters.setFlashMode(flashMode);
+            }
+        }
+    }
+
+    public static void setBestExposure(Camera.Parameters parameters, boolean lightOn) {
+        int minExposure = parameters.getMinExposureCompensation();
+        int maxExposure = parameters.getMaxExposureCompensation();
+        float step = parameters.getExposureCompensationStep();
+        if ((minExposure != 0 || maxExposure != 0) && step > 0.0f) {
+            // Set low when light is on
+            float targetCompensation = lightOn ? MIN_EXPOSURE_COMPENSATION : MAX_EXPOSURE_COMPENSATION;
+            int compensationSteps = Math.round(targetCompensation / step);
+            float actualCompensation = step * compensationSteps;
+            // Clamp value:
+            compensationSteps = Math.max(Math.min(compensationSteps, maxExposure), minExposure);
+            if (parameters.getExposureCompensation() == compensationSteps) {
+                Log.i(TAG, "Exposure compensation already set to " + compensationSteps + " / " + actualCompensation);
+            } else {
+                Log.i(TAG, "Setting exposure compensation to " + compensationSteps + " / " + actualCompensation);
+                parameters.setExposureCompensation(compensationSteps);
+            }
+        } else {
+            Log.i(TAG, "Camera does not support exposure compensation");
+        }
+    }
+
+    public static void setBestPreviewFPS(Camera.Parameters parameters) {
+        setBestPreviewFPS(parameters, MIN_FPS, MAX_FPS);
+    }
+
+    public static void setBestPreviewFPS(Camera.Parameters parameters, int minFPS, int maxFPS) {
+        List<int[]> supportedPreviewFpsRanges = parameters.getSupportedPreviewFpsRange();
+        Log.i(TAG, "Supported FPS ranges: " + toString(supportedPreviewFpsRanges));
+        if (supportedPreviewFpsRanges != null && !supportedPreviewFpsRanges.isEmpty()) {
+            int[] suitableFPSRange = null;
+            for (int[] fpsRange : supportedPreviewFpsRanges) {
+                int thisMin = fpsRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX];
+                int thisMax = fpsRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX];
+                if (thisMin >= minFPS * 1000 && thisMax <= maxFPS * 1000) {
+                    suitableFPSRange = fpsRange;
+                    break;
+                }
+            }
+            if (suitableFPSRange == null) {
+                Log.i(TAG, "No suitable FPS range?");
+            } else {
+                int[] currentFpsRange = new int[2];
+                parameters.getPreviewFpsRange(currentFpsRange);
+                if (Arrays.equals(currentFpsRange, suitableFPSRange)) {
+                    Log.i(TAG, "FPS range already set to " + Arrays.toString(suitableFPSRange));
+                } else {
+                    Log.i(TAG, "Setting FPS range to " + Arrays.toString(suitableFPSRange));
+                    parameters.setPreviewFpsRange(suitableFPSRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX],
+                            suitableFPSRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]);
+                }
+            }
+        }
+    }
+
+    public static void setFocusArea(Camera.Parameters parameters) {
+        if (parameters.getMaxNumFocusAreas() > 0) {
+            Log.i(TAG, "Old focus areas: " + toString(parameters.getFocusAreas()));
+            List<Camera.Area> middleArea = buildMiddleArea(AREA_PER_1000);
+            Log.i(TAG, "Setting focus area to : " + toString(middleArea));
+            parameters.setFocusAreas(middleArea);
+        } else {
+            Log.i(TAG, "Device does not support focus areas");
+        }
+    }
+
+    public static void setMetering(Camera.Parameters parameters) {
+        if (parameters.getMaxNumMeteringAreas() > 0) {
+            Log.i(TAG, "Old metering areas: " + parameters.getMeteringAreas());
+            List<Camera.Area> middleArea = buildMiddleArea(AREA_PER_1000);
+            Log.i(TAG, "Setting metering area to : " + toString(middleArea));
+            parameters.setMeteringAreas(middleArea);
+        } else {
+            Log.i(TAG, "Device does not support metering areas");
+        }
+    }
+
+    private static List<Camera.Area> buildMiddleArea(int areaPer1000) {
+        return Collections.singletonList(
+                new Camera.Area(new Rect(-areaPer1000, -areaPer1000, areaPer1000, areaPer1000), 1));
+    }
+
+    public static void setVideoStabilization(Camera.Parameters parameters) {
+        if (parameters.isVideoStabilizationSupported()) {
+            if (parameters.getVideoStabilization()) {
+                Log.i(TAG, "Video stabilization already enabled");
+            } else {
+                Log.i(TAG, "Enabling video stabilization...");
+                parameters.setVideoStabilization(true);
+            }
+        } else {
+            Log.i(TAG, "This device does not support video stabilization");
+        }
+    }
+
+    public static void setBarcodeSceneMode(Camera.Parameters parameters) {
+        if (Camera.Parameters.SCENE_MODE_BARCODE.equals(parameters.getSceneMode())) {
+            Log.i(TAG, "Barcode scene mode already set");
+            return;
+        }
+        String sceneMode = findSettableValue("scene mode",
+                parameters.getSupportedSceneModes(),
+                Camera.Parameters.SCENE_MODE_BARCODE);
+        if (sceneMode != null) {
+            parameters.setSceneMode(sceneMode);
+        }
+    }
+
+    public static void setZoom(Camera.Parameters parameters, double targetZoomRatio) {
+        if (parameters.isZoomSupported()) {
+            Integer zoom = indexOfClosestZoom(parameters, targetZoomRatio);
+            if (zoom == null) {
+                return;
+            }
+            if (parameters.getZoom() == zoom) {
+                Log.i(TAG, "Zoom is already set to " + zoom);
+            } else {
+                Log.i(TAG, "Setting zoom to " + zoom);
+                parameters.setZoom(zoom);
+            }
+        } else {
+            Log.i(TAG, "Zoom is not supported");
+        }
+    }
+
+    private static Integer indexOfClosestZoom(Camera.Parameters parameters, double targetZoomRatio) {
+        List<Integer> ratios = parameters.getZoomRatios();
+        Log.i(TAG, "Zoom ratios: " + ratios);
+        int maxZoom = parameters.getMaxZoom();
+        if (ratios == null || ratios.isEmpty() || ratios.size() != maxZoom + 1) {
+            Log.w(TAG, "Invalid zoom ratios!");
+            return null;
+        }
+        double target100 = 100.0 * targetZoomRatio;
+        double smallestDiff = Double.POSITIVE_INFINITY;
+        int closestIndex = 0;
+        for (int i = 0; i < ratios.size(); i++) {
+            double diff = Math.abs(ratios.get(i) - target100);
+            if (diff < smallestDiff) {
+                smallestDiff = diff;
+                closestIndex = i;
+            }
+        }
+        Log.i(TAG, "Chose zoom ratio of " + (ratios.get(closestIndex) / 100.0));
+        return closestIndex;
+    }
+
+    public static void setInvertColor(Camera.Parameters parameters) {
+        if (Camera.Parameters.EFFECT_NEGATIVE.equals(parameters.getColorEffect())) {
+            Log.i(TAG, "Negative effect already set");
+            return;
+        }
+        String colorMode = findSettableValue("color effect",
+                parameters.getSupportedColorEffects(),
+                Camera.Parameters.EFFECT_NEGATIVE);
+        if (colorMode != null) {
+            parameters.setColorEffect(colorMode);
+        }
+    }
+
+    public static Point findBestPreviewSizeValue(Camera.Parameters parameters, Point screenResolution) {
+
+        // 获取当前手机支持的屏幕预览尺寸
+        List<Camera.Size> rawSupportedSizes = parameters.getSupportedPreviewSizes();
+        if (rawSupportedSizes == null) {
+            Log.w(TAG, "Device returned no supported preview sizes; using default");
+            Camera.Size defaultSize = parameters.getPreviewSize();
+            if (defaultSize == null) {
+                throw new IllegalStateException("Parameters contained no preview size!");
+            }
+            return new Point(defaultSize.width, defaultSize.height);
+        }
+
+        // Sort by size, descending
+        // 对这些尺寸根据像素值（即宽乘高的值）进行从小到大排序
+        List<Camera.Size> supportedPreviewSizes = new ArrayList<>(rawSupportedSizes);
+        Collections.sort(supportedPreviewSizes, new Comparator<Camera.Size>() {
+            @Override
+            public int compare(Camera.Size a, Camera.Size b) {
+                int aPixels = a.height * a.width;
+                int bPixels = b.height * b.width;
+                if (bPixels < aPixels) {
+                    return -1;
+                }
+                if (bPixels > aPixels) {
+                    return 1;
+                }
+                return 0;
+            }
+        });
+
+        if (Log.isLoggable(TAG, Log.INFO)) {
+            StringBuilder previewSizesString = new StringBuilder();
+            for (Camera.Size supportedPreviewSize : supportedPreviewSizes) {
+                previewSizesString.append(supportedPreviewSize.width).append('x')
+                        .append(supportedPreviewSize.height).append(' ');
+            }
+            Log.i(TAG, "Supported preview sizes: " + previewSizesString);
+        }
+
+        double screenAspectRatio = screenResolution.x / (double) screenResolution.y;
+
+        // Remove sizes that are unsuitable
+        Iterator<Camera.Size> it = supportedPreviewSizes.iterator();
+        while (it.hasNext()) {
+            Camera.Size supportedPreviewSize = it.next();
+            int realWidth = supportedPreviewSize.width;
+            int realHeight = supportedPreviewSize.height;
+
+            // 首先把不符合最小预览像素值的尺寸排除
+            if (realWidth * realHeight < MIN_PREVIEW_PIXELS) {
+                it.remove();
+                continue;
+            }
+
+            boolean isCandidatePortrait = realWidth < realHeight;
+            int maybeFlippedWidth = isCandidatePortrait ? realHeight : realWidth;
+            int maybeFlippedHeight = isCandidatePortrait ? realWidth : realHeight;
+            double aspectRatio = maybeFlippedWidth / (double) maybeFlippedHeight;
+            double distortion = Math.abs(aspectRatio - screenAspectRatio);
+
+            // 根据宽高比判断是否满足最大误差要求（默认最大值为0.15，即宽高比默认不能超过给定比例的15%）
+            if (distortion > MAX_ASPECT_DISTORTION) {
+                it.remove();
+                continue;
+            }
+
+            if (maybeFlippedWidth == screenResolution.x && maybeFlippedHeight == screenResolution.y) {
+                Point exactPoint = new Point(realWidth, realHeight);
+                Log.i(TAG, "Found preview size exactly matching screen size: " + exactPoint);
+                return exactPoint;
+            }
+        }
+
+        // If no exact match, use largest preview size. This was not a great idea on older devices because
+        // of the additional computation needed. We're likely to get here on newer Android 4+ devices, where
+        // the CPU is much more powerful.
+        // 如果没有精确匹配到合适的尺寸，则使用最大的尺寸，这样设置便是预览图像可能产生拉伸的根本原因
+        if (!supportedPreviewSizes.isEmpty()) {
+            Camera.Size largestPreview = supportedPreviewSizes.get(0);
+            Point largestSize = new Point(largestPreview.width, largestPreview.height);
+            Log.i(TAG, "Using largest suitable preview size: " + largestSize);
+            return largestSize;
+        }
+
+        // If there is nothing at all suitable, return current preview size
+        // 如果没有找到合适的尺寸，就返回默认设定的尺寸
+        Camera.Size defaultPreview = parameters.getPreviewSize();
+        if (defaultPreview == null) {
+            throw new IllegalStateException("Parameters contained no preview size!");
+        }
+        Point defaultSize = new Point(defaultPreview.width, defaultPreview.height);
+        Log.i(TAG, "No suitable preview sizes, using default: " + defaultSize);
+        return defaultSize;
+    }
+
+    private static String findSettableValue(String name,
+                                            Collection<String> supportedValues,
+                                            String... desiredValues) {
+        Log.i(TAG, "Requesting " + name + " value from among: " + Arrays.toString(desiredValues));
+        Log.i(TAG, "Supported " + name + " values: " + supportedValues);
+        if (supportedValues != null) {
+            for (String desiredValue : desiredValues) {
+                if (supportedValues.contains(desiredValue)) {
+                    Log.i(TAG, "Can set " + name + " to: " + desiredValue);
+                    return desiredValue;
+                }
+            }
+        }
+        Log.i(TAG, "No supported values match");
+        return null;
+    }
+
+    private static String toString(Collection<int[]> arrays) {
+        if (arrays == null || arrays.isEmpty()) {
+            return "[]";
+        }
+        StringBuilder buffer = new StringBuilder();
+        buffer.append('[');
+        Iterator<int[]> it = arrays.iterator();
+        while (it.hasNext()) {
+            buffer.append(Arrays.toString(it.next()));
+            if (it.hasNext()) {
+                buffer.append(", ");
+            }
+        }
+        buffer.append(']');
+        return buffer.toString();
+    }
+
+    private static String toString(Iterable<Camera.Area> areas) {
+        if (areas == null) {
+            return null;
+        }
+        StringBuilder result = new StringBuilder();
+        for (Camera.Area area : areas) {
+            result.append(area.rect).append(':').append(area.weight).append(' ');
+        }
+        return result.toString();
+    }
+
+    public static String collectStats(Camera.Parameters parameters) {
+        return collectStats(parameters.flatten());
+    }
+
+    public static String collectStats(CharSequence flattenedParams) {
+        StringBuilder result = new StringBuilder(1000);
+
+        result.append("BOARD=").append(Build.BOARD).append('\n');
+        result.append("BRAND=").append(Build.BRAND).append('\n');
+        result.append("CPU_ABI=").append(Build.CPU_ABI).append('\n');
+        result.append("DEVICE=").append(Build.DEVICE).append('\n');
+        result.append("DISPLAY=").append(Build.DISPLAY).append('\n');
+        result.append("FINGERPRINT=").append(Build.FINGERPRINT).append('\n');
+        result.append("HOST=").append(Build.HOST).append('\n');
+        result.append("ID=").append(Build.ID).append('\n');
+        result.append("MANUFACTURER=").append(Build.MANUFACTURER).append('\n');
+        result.append("MODEL=").append(Build.MODEL).append('\n');
+        result.append("PRODUCT=").append(Build.PRODUCT).append('\n');
+        result.append("TAGS=").append(Build.TAGS).append('\n');
+        result.append("TIME=").append(Build.TIME).append('\n');
+        result.append("TYPE=").append(Build.TYPE).append('\n');
+        result.append("USER=").append(Build.USER).append('\n');
+        result.append("VERSION.CODENAME=").append(Build.VERSION.CODENAME).append('\n');
+        result.append("VERSION.INCREMENTAL=").append(Build.VERSION.INCREMENTAL).append('\n');
+        result.append("VERSION.RELEASE=").append(Build.VERSION.RELEASE).append('\n');
+        result.append("VERSION.SDK_INT=").append(Build.VERSION.SDK_INT).append('\n');
+
+        if (flattenedParams != null) {
+            String[] params = SEMICOLON.split(flattenedParams);
+            Arrays.sort(params);
+            for (String param : params) {
+                result.append(param).append('\n');
+            }
+        }
+
+        return result.toString();
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraManager.java b/src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraManager.java
new file mode 100644
index 0000000..f74b235
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/camera/CameraManager.java
@@ -0,0 +1,351 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.camera;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.hardware.Camera;
+import android.os.Handler;
+import android.util.Log;
+import android.view.SurfaceHolder;
+
+import com.google.zxing.PlanarYUVLuminanceSource;
+
+import java.io.IOException;
+
+import com.android.documentsui.DSN.ui.common.barcode.camera.open.OpenCamera;
+import com.android.documentsui.DSN.ui.common.barcode.camera.open.OpenCameraInterface;
+
+
+/**
+ * This object wraps the Camera service object and expects to be the only one talking to it. The
+ * implementation encapsulates the steps needed to take preview-sized images, which are used for
+ * both preview and decoding.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class CameraManager {
+
+    private static final String TAG = CameraManager.class.getSimpleName();
+
+    private static final int MIN_FRAME_WIDTH = 240;
+    public static final int MIN_FRAME_HEIGHT = 240;
+    private static final int MAX_FRAME_WIDTH = 1200; // = 5/8 * 1920
+    public static final int MAX_FRAME_HEIGHT = 675; // = 5/8 * 1080
+
+    private final Context context;
+    private final CameraConfigurationManager configManager;
+    private OpenCamera camera;
+    private AutoFocusManager autoFocusManager;
+    private Rect framingRect;
+    private Rect framingRectInPreview;
+    private boolean initialized;
+    private boolean previewing;
+    private int requestedCameraId = OpenCameraInterface.NO_REQUESTED_CAMERA;
+    private int requestedFramingRectWidth;
+    private int requestedFramingRectHeight;
+    /**
+     * Preview frames are delivered here, which we pass on to the registered handler. Make sure to
+     * clear the handler so it will only receive one message.
+     */
+    private final PreviewCallback previewCallback;
+
+    public CameraManager(Context context) {
+        this.context = context;
+        this.configManager = new CameraConfigurationManager(context);
+        previewCallback = new PreviewCallback(configManager);
+    }
+
+    /**
+     * Opens the camera driver and initializes the hardware parameters.
+     *
+     * @param holder The surface object which the camera will draw preview frames into.
+     * @throws IOException Indicates the camera driver failed to open.
+     */
+    public synchronized void openDriver(SurfaceHolder holder) throws IOException {
+        OpenCamera theCamera = camera;
+        if (theCamera == null) {
+            theCamera = OpenCameraInterface.open(requestedCameraId);
+            if (theCamera == null) {
+                throw new IOException("Camera.open() failed to return object from driver");
+            }
+            camera = theCamera;
+        }
+
+        if (!initialized) {
+            initialized = true;
+            configManager.initFromCameraParameters(theCamera);
+            if (requestedFramingRectWidth > 0 && requestedFramingRectHeight > 0) {
+                setManualFramingRect(requestedFramingRectWidth, requestedFramingRectHeight);
+                requestedFramingRectWidth = 0;
+                requestedFramingRectHeight = 0;
+            }
+        }
+
+        Camera cameraObject = theCamera.getCamera();
+        Camera.Parameters parameters = cameraObject.getParameters();
+        String parametersFlattened = parameters == null ? null : parameters.flatten(); // Save these, temporarily
+        try {
+            configManager.setDesiredCameraParameters(theCamera, false);
+        } catch (RuntimeException re) {
+            // Driver failed
+            Log.w(TAG, "Camera rejected parameters. Setting only minimal safe-mode parameters");
+            Log.i(TAG, "Resetting to saved camera params: " + parametersFlattened);
+            // Reset:
+            if (parametersFlattened != null) {
+                parameters = cameraObject.getParameters();
+                parameters.unflatten(parametersFlattened);
+                try {
+                    cameraObject.setParameters(parameters);
+                    configManager.setDesiredCameraParameters(theCamera, true);
+                } catch (RuntimeException re2) {
+                    // Well, darn. Give up
+                    Log.w(TAG, "Camera rejected even safe-mode parameters! No configuration");
+                }
+            }
+        }
+        cameraObject.setPreviewDisplay(holder);
+
+    }
+
+    public synchronized boolean isOpen() {
+        return camera != null;
+    }
+
+    /**
+     * Closes the camera driver if still in use.
+     */
+    public synchronized void closeDriver() {
+        if (camera != null) {
+            camera.getCamera().release();
+            camera = null;
+            // Make sure to clear these each time we close the camera, so that any scanning rect
+            // requested by intent is forgotten.
+            framingRect = null;
+            framingRectInPreview = null;
+        }
+    }
+
+    /**
+     * Asks the camera hardware to begin drawing preview frames to the screen.
+     */
+    public synchronized void startPreview() {
+        OpenCamera theCamera = camera;
+        if (theCamera != null && !previewing) {
+            theCamera.getCamera().startPreview();
+            previewing = true;
+            autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());
+        }
+    }
+
+    /**
+     * Tells the camera to stop drawing preview frames.
+     */
+    public synchronized void stopPreview() {
+        if (autoFocusManager != null) {
+            autoFocusManager.stop();
+            autoFocusManager = null;
+        }
+        if (camera != null && previewing) {
+            camera.getCamera().stopPreview();
+            previewCallback.setHandler(null, 0);
+            previewing = false;
+        }
+    }
+
+    /**
+     * Convenience method for CaptureActivity
+     *
+     * @param newSetting if {@code true}, light should be turned on if currently off. And vice versa.
+     */
+    public synchronized void setTorch(boolean newSetting) {
+        OpenCamera theCamera = camera;
+        if (theCamera != null) {
+            if (newSetting != configManager.getTorchState(theCamera.getCamera())) {
+                boolean wasAutoFocusManager = autoFocusManager != null;
+                if (wasAutoFocusManager) {
+                    autoFocusManager.stop();
+                    autoFocusManager = null;
+                }
+                configManager.setTorch(theCamera.getCamera(), newSetting);
+                if (wasAutoFocusManager) {
+                    autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());
+                    autoFocusManager.start();
+                }
+            }
+        }
+    }
+
+    public synchronized boolean getTorch() {
+        OpenCamera theCamera = camera;
+        return theCamera != null && configManager.getTorchState(theCamera.getCamera());
+    }
+
+    /**
+     * A single preview frame will be returned to the handler supplied. The data will arrive as byte[]
+     * in the message.obj field, with width and height encoded as message.arg1 and message.arg2,
+     * respectively.
+     *
+     * @param handler The handler to send the message to.
+     * @param message The what field of the message to be sent.
+     */
+    public synchronized void requestPreviewFrame(Handler handler, int message) {
+        OpenCamera theCamera = camera;
+        if (theCamera != null && previewing) {
+            previewCallback.setHandler(handler, message);
+            theCamera.getCamera().setOneShotPreviewCallback(previewCallback);
+        }
+    }
+
+    /**
+     * Calculates the framing rect which the UI should draw to show the user where to place the
+     * barcode. This target helps with alignment as well as forces the user to hold the device
+     * far enough away to ensure the image will be in focus.
+     *
+     * @return The rectangle to draw on screen in window coordinates.
+     */
+    public synchronized Rect getFramingRect() {
+        if (framingRect == null) {
+            if (camera == null) {
+                return null;
+            }
+
+            // 获取屏幕的尺寸像素
+            Point screenResolution = configManager.getScreenResolution();
+            if (screenResolution == null) {
+                // Called early, before init even finished
+                return null;
+            }
+
+            int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);
+            //int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
+            int height = width;
+            int leftOffset = (screenResolution.x - width) / 2;
+            int topOffset = (screenResolution.y - height) / 3;
+            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);
+            Log.d(TAG, "Calculated framing rect: " + framingRect);
+        }
+        return framingRect;
+    }
+
+    public static int findDesiredDimensionInRange(int resolution, int hardMin, int hardMax) {
+        int dim = 5 * resolution / 8; // Target 5/8 of each dimension
+        if (dim < hardMin) {
+            return hardMin;
+        }
+        if (dim > hardMax) {
+            return hardMax;
+        }
+        return dim;
+    }
+
+    /**
+     * Like {@link #getFramingRect} but coordinates are in terms of the preview frame,
+     * not UI / screen.
+     *
+     * @return {@link Rect} expressing barcode scan area in terms of the preview size
+     */
+    public synchronized Rect getFramingRectInPreview() {
+        if (framingRectInPreview == null) {
+            Rect framingRect = getFramingRect();
+            if (framingRect == null) {
+                return null;
+            }
+
+            // 获取相机分辨率和屏幕分辨率
+            Rect rect = new Rect(framingRect);
+            Point cameraResolution = configManager.getCameraResolution();
+            Point screenResolution = configManager.getScreenResolution();
+            if (cameraResolution == null || screenResolution == null) {
+                // Called early, before init even finished
+                return null;
+            }
+
+            // 根据相机分辨率和屏幕分辨率的比例对屏幕中央聚焦框进行调整
+            rect.left = rect.left * cameraResolution.x / screenResolution.x;
+            rect.right = rect.right * cameraResolution.x / screenResolution.x;
+            rect.top = rect.top * cameraResolution.y / screenResolution.y;
+            rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;
+            framingRectInPreview = rect;
+        }
+        return framingRectInPreview;
+    }
+
+
+    /**
+     * Allows third party apps to specify the camera ID, rather than determine
+     * it automatically based on available cameras and their orientation.
+     *
+     * @param cameraId camera ID of the camera to use. A negative value means "no preference".
+     */
+    public synchronized void setManualCameraId(int cameraId) {
+        requestedCameraId = cameraId;
+    }
+
+    /**
+     * Allows third party apps to specify the scanning rectangle dimensions, rather than determine
+     * them automatically based on screen resolution.
+     *
+     * @param width  The width in pixels to scan.
+     * @param height The height in pixels to scan.
+     */
+    public synchronized void setManualFramingRect(int width, int height) {
+        if (initialized) {
+            Point screenResolution = configManager.getScreenResolution();
+            if (width > screenResolution.x) {
+                width = screenResolution.x;
+            }
+            if (height > screenResolution.y) {
+                height = screenResolution.y;
+            }
+            int leftOffset = (screenResolution.x - width) / 2;
+            int topOffset = (screenResolution.y - height) / 2;
+            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);
+            Log.d(TAG, "Calculated manual framing rect: " + framingRect);
+            framingRectInPreview = null;
+        } else {
+            requestedFramingRectWidth = width;
+            requestedFramingRectHeight = height;
+        }
+    }
+
+    /**
+     * A factory method to build the appropriate LuminanceSource object based on the format
+     * of the preview buffers, as described by Camera.Parameters.
+     *
+     * @param data   A preview frame.
+     * @param width  The width of the image.
+     * @param height The height of the image.
+     * @return A PlanarYUVLuminanceSource instance.
+     */
+    public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int height) {
+        // 取得预览框内的矩形
+//        Rect rect = getFramingRectInPreview();
+//        if (rect == null) {
+//            return null;
+//        }
+//
+//        // Go ahead and assume it's YUV rather than die.
+//        return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,
+//                rect.width(), rect.height(), false);
+
+        // 直接返回整幅图像的数据，而不计算聚焦框大小。
+        return new PlanarYUVLuminanceSource(data, width, height, 0, 0, width, height, false);
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/camera/PreviewCallback.java b/src/com/android/documentsui/DSN/ui/common/barcode/camera/PreviewCallback.java
new file mode 100644
index 0000000..e062237
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/camera/PreviewCallback.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.camera;
+
+import android.graphics.Point;
+import android.hardware.Camera;
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+
+final class PreviewCallback implements Camera.PreviewCallback {
+
+    private static final String TAG = PreviewCallback.class.getSimpleName();
+
+    private final CameraConfigurationManager configManager;
+    private Handler previewHandler;
+    private int previewMessage;
+
+    PreviewCallback(CameraConfigurationManager configManager) {
+        this.configManager = configManager;
+    }
+
+    void setHandler(Handler previewHandler, int previewMessage) {
+        this.previewHandler = previewHandler;
+        this.previewMessage = previewMessage;
+    }
+
+    @Override
+    public void onPreviewFrame(byte[] data, Camera camera) {
+        Point cameraResolution = configManager.getCameraResolution();
+        Handler thePreviewHandler = previewHandler;
+        if (cameraResolution != null && thePreviewHandler != null) {
+            Message message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.x,
+                    cameraResolution.y, data);
+            message.sendToTarget();
+            previewHandler = null;
+        } else {
+            Log.d(TAG, "Got preview callback, but no handler or resolution available");
+        }
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/camera/open/CameraFacing.java b/src/com/android/documentsui/DSN/ui/common/barcode/camera/open/CameraFacing.java
new file mode 100644
index 0000000..21159de
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/camera/open/CameraFacing.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.camera.open;
+
+/**
+ * Enumeration of directions a camera may face: front or back.
+ */
+public enum CameraFacing {
+  BACK,  // must be value 0!
+  FRONT, // must be value 1!
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/camera/open/OpenCamera.java b/src/com/android/documentsui/DSN/ui/common/barcode/camera/open/OpenCamera.java
new file mode 100644
index 0000000..9b09c69
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/camera/open/OpenCamera.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.camera.open;
+
+import android.hardware.Camera;
+
+/**
+ * Represents an open Camera and its metadata, like facing direction and orientation.
+ */
+public final class OpenCamera {
+  
+  private final int index;
+  private final Camera camera;
+  private final CameraFacing facing;
+  private final int orientation;
+  
+  public OpenCamera(int index, Camera camera, CameraFacing facing, int orientation) {
+    this.index = index;
+    this.camera = camera;
+    this.facing = facing;
+    this.orientation = orientation;
+  }
+
+  public Camera getCamera() {
+    return camera;
+  }
+
+  public CameraFacing getFacing() {
+    return facing;
+  }
+
+  public int getOrientation() {
+    return orientation;
+  }
+
+  @Override
+  public String toString() {
+    return "Camera #" + index + " : " + facing + ',' + orientation;
+  }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/camera/open/OpenCameraInterface.java b/src/com/android/documentsui/DSN/ui/common/barcode/camera/open/OpenCameraInterface.java
new file mode 100644
index 0000000..fc71648
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/camera/open/OpenCameraInterface.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2012 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.camera.open;
+
+import android.hardware.Camera;
+import android.util.Log;
+
+/**
+ * Abstraction over the Camera API that helps open them and return their metadata.
+ */
+public final class OpenCameraInterface {
+
+  private static final String TAG = OpenCameraInterface.class.getName();
+
+  private OpenCameraInterface() {
+  }
+
+  /** For {@link #open(int)}, means no preference for which camera to open. */
+  public static final int NO_REQUESTED_CAMERA = -1;
+
+  /**
+   * Opens the requested camera with {@link Camera#open(int)}, if one exists.
+   *
+   * @param cameraId camera ID of the camera to use. A negative value
+   *  or {@link #NO_REQUESTED_CAMERA} means "no preference", in which case a rear-facing
+   *  camera is returned if possible or else any camera
+   * @return handle to {@link OpenCamera} that was opened
+   */
+  public static OpenCamera open(int cameraId) {
+
+    int numCameras = Camera.getNumberOfCameras();
+    if (numCameras == 0) {
+      Log.w(TAG, "No cameras!");
+      return null;
+    }
+
+    boolean explicitRequest = cameraId >= 0;
+
+    Camera.CameraInfo selectedCameraInfo = null;
+    int index;
+    if (explicitRequest) {
+      index = cameraId;
+      selectedCameraInfo = new Camera.CameraInfo();
+      Camera.getCameraInfo(index, selectedCameraInfo);
+    } else {
+      index = 0;
+      while (index < numCameras) {
+        Camera.CameraInfo cameraInfo = new Camera.CameraInfo();
+        Camera.getCameraInfo(index, cameraInfo);
+        CameraFacing reportedFacing = CameraFacing.values()[cameraInfo.facing];
+        if (reportedFacing == CameraFacing.BACK) {
+          selectedCameraInfo = cameraInfo;
+          break;
+        }
+        index++;
+      }
+    }
+
+    Camera camera;
+    if (index < numCameras) {
+      Log.i(TAG, "Opening camera #" + index);
+      camera = Camera.open(index);
+    } else {
+      if (explicitRequest) {
+        Log.w(TAG, "Requested camera does not exist: " + cameraId);
+        camera = null;
+      } else {
+        Log.i(TAG, "No camera facing " + CameraFacing.BACK + "; returning camera #0");
+        camera = Camera.open(0);
+        selectedCameraInfo = new Camera.CameraInfo();
+        Camera.getCameraInfo(0, selectedCameraInfo);
+      }
+    }
+
+    if (camera == null) {
+      return null;
+    }
+    return new OpenCamera(index,
+                          camera,
+                          CameraFacing.values()[selectedCameraInfo.facing],
+                          selectedCameraInfo.orientation);
+  }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/AddressBookResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/AddressBookResultHandler.java
new file mode 100644
index 0000000..18db4a7
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/AddressBookResultHandler.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+import android.graphics.Typeface;
+import android.telephony.PhoneNumberUtils;
+import android.text.Spannable;
+import android.text.SpannableString;
+import android.text.style.StyleSpan;
+
+import com.google.zxing.client.result.AddressBookParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+import com.android.documentsui.R;
+
+
+/**
+ * Handles address book entries.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class AddressBookResultHandler extends ResultHandler {
+
+  private static final DateFormat[] DATE_FORMATS = {
+    new SimpleDateFormat("xxxxMMdd", Locale.ENGLISH),
+    new SimpleDateFormat("xxxxMMdd'T'HHmmss", Locale.ENGLISH),
+    new SimpleDateFormat("xxxx-MM-dd", Locale.ENGLISH),
+    new SimpleDateFormat("xxxx-MM-dd'T'HH:mm:ss", Locale.ENGLISH),
+  };
+  static {
+    for (DateFormat format : DATE_FORMATS) {
+      format.setLenient(false);
+    }
+  }
+
+  private static final int[] BUTTON_TEXTS = {
+    R.string.button_add_contact,
+    R.string.button_show_map,
+    R.string.button_dial,
+    R.string.button_email,
+  };
+
+  private final boolean[] fields;
+  private int buttonCount;
+
+  // This takes all the work out of figuring out which buttons/actions should be in which
+  // positions, based on which fields are present in this barcode.
+  private int mapIndexToAction(int index) {
+    if (index < buttonCount) {
+      int count = -1;
+      for (int x = 0; x < MAX_BUTTON_COUNT; x++) {
+        if (fields[x]) {
+          count++;
+        }
+        if (count == index) {
+          return x;
+        }
+      }
+    }
+    return -1;
+  }
+
+  public AddressBookResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+    AddressBookParsedResult addressResult = (AddressBookParsedResult) result;
+    String[] addresses = addressResult.getAddresses();
+    String[] phoneNumbers = addressResult.getPhoneNumbers();
+    String[] emails = addressResult.getEmails();
+
+    fields = new boolean[MAX_BUTTON_COUNT];
+    fields[0] = true; // Add contact is always available
+    fields[1] = addresses != null && addresses.length > 0 && addresses[0] != null && !addresses[0].isEmpty();
+    fields[2] = phoneNumbers != null && phoneNumbers.length > 0;
+    fields[3] = emails != null && emails.length > 0;
+
+    buttonCount = 0;
+    for (int x = 0; x < MAX_BUTTON_COUNT; x++) {
+      if (fields[x]) {
+        buttonCount++;
+      }
+    }
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttonCount;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return BUTTON_TEXTS[mapIndexToAction(index)];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    AddressBookParsedResult addressResult = (AddressBookParsedResult) getResult();
+    String[] addresses = addressResult.getAddresses();
+    String address1 = addresses == null || addresses.length < 1 ? null : addresses[0];
+    String[] addressTypes = addressResult.getAddressTypes();
+    String address1Type = addressTypes == null || addressTypes.length < 1 ? null : addressTypes[0];
+    int action = mapIndexToAction(index);
+    switch (action) {
+      case 0:
+        addContact(addressResult.getNames(),
+                   addressResult.getNicknames(),
+                   addressResult.getPronunciation(),
+                   addressResult.getPhoneNumbers(),
+                   addressResult.getPhoneTypes(),
+                   addressResult.getEmails(),
+                   addressResult.getEmailTypes(),
+                   addressResult.getNote(),
+                   addressResult.getInstantMessenger(),
+                   address1,
+                   address1Type,
+                   addressResult.getOrg(),
+                   addressResult.getTitle(),
+                   addressResult.getURLs(),
+                   addressResult.getBirthday(),
+                   addressResult.getGeo());
+        break;
+      case 1:
+        searchMap(address1);
+        break;
+      case 2:
+        dialPhone(addressResult.getPhoneNumbers()[0]);
+        break;
+      case 3:
+        sendEmail(addressResult.getEmails(), null, null, null, null);
+        break;
+      default:
+        break;
+    }
+  }
+
+  private static Date parseDate(String s) {
+    for (DateFormat currentFormat : DATE_FORMATS) {
+      try {
+        return currentFormat.parse(s);
+      } catch (ParseException e) {
+        // continue
+      }
+    }
+    return null;
+  }
+
+  // Overriden so we can hyphenate phone numbers, format birthdays, and bold the name.
+  @Override
+  public CharSequence getDisplayContents() {
+    AddressBookParsedResult result = (AddressBookParsedResult) getResult();
+    StringBuilder contents = new StringBuilder(100);
+    ParsedResult.maybeAppend(result.getNames(), contents);
+    int namesLength = contents.length();
+
+    String pronunciation = result.getPronunciation();
+    if (pronunciation != null && !pronunciation.isEmpty()) {
+      contents.append("\n(");
+      contents.append(pronunciation);
+      contents.append(')');
+    }
+
+    ParsedResult.maybeAppend(result.getTitle(), contents);
+    ParsedResult.maybeAppend(result.getOrg(), contents);
+    ParsedResult.maybeAppend(result.getAddresses(), contents);
+    String[] numbers = result.getPhoneNumbers();
+    if (numbers != null) {
+      for (String number : numbers) {
+        if (number != null) {
+          ParsedResult.maybeAppend(PhoneNumberUtils.formatNumber(number), contents);
+        }
+      }
+    }
+    ParsedResult.maybeAppend(result.getEmails(), contents);
+    ParsedResult.maybeAppend(result.getURLs(), contents);
+
+    String birthday = result.getBirthday();
+    if (birthday != null && !birthday.isEmpty()) {
+      Date date = parseDate(birthday);
+      if (date != null) {
+        ParsedResult.maybeAppend(DateFormat.getDateInstance(DateFormat.MEDIUM).format(date.getTime()), contents);
+      }
+    }
+    ParsedResult.maybeAppend(result.getNote(), contents);
+
+    if (namesLength > 0) {
+      // Bold the full name to make it stand out a bit.
+      Spannable styled = new SpannableString(contents.toString());
+      styled.setSpan(new StyleSpan(Typeface.BOLD), 0, namesLength, 0);
+      return styled;
+    } else {
+      return contents.toString();
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_address_book;
+  }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/CalendarResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/CalendarResultHandler.java
new file mode 100644
index 0000000..bd46d34
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/CalendarResultHandler.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.util.Log;
+
+import com.google.zxing.client.result.CalendarParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import java.text.DateFormat;
+import java.util.Date;
+
+import com.android.documentsui.R;
+
+
+/**
+ * Handles calendar entries encoded in QR Codes.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ * @author Sean Owen
+ */
+public final class CalendarResultHandler extends ResultHandler {
+
+  private static final String TAG = CalendarResultHandler.class.getSimpleName();
+
+  private static final int[] buttons = {
+      R.string.button_add_calendar
+  };
+
+  public CalendarResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    if (index == 0) {
+      CalendarParsedResult calendarResult = (CalendarParsedResult) getResult();
+
+      String description = calendarResult.getDescription();
+      String organizer = calendarResult.getOrganizer();
+      if (organizer != null) { // No separate Intent key, put in description
+        if (description == null) {
+          description = organizer;
+        } else {
+          description = description + '\n' + organizer;
+        }
+      }
+
+      addCalendarEvent(calendarResult.getSummary(),
+                       calendarResult.getStart(),
+                       calendarResult.isStartAllDay(),
+                       calendarResult.getEnd(),
+                       calendarResult.getLocation(),
+                       description,
+                       calendarResult.getAttendees());
+    }
+  }
+
+  /**
+   * Sends an intent to create a new calendar event by prepopulating the Add Event UI. Older
+   * versions of the system have a bug where the event title will not be filled out.
+   *
+   * @param summary A description of the event
+   * @param start   The start time
+   * @param allDay  if true, event is considered to be all day starting from start time
+   * @param end     The end time (optional)
+   * @param location a text description of the event location
+   * @param description a text description of the event itself
+   * @param attendees attendees to invite
+   */
+  private void addCalendarEvent(String summary,
+                                Date start,
+                                boolean allDay,
+                                Date end,
+                                String location,
+                                String description,
+                                String[] attendees) {
+    Intent intent = new Intent(Intent.ACTION_INSERT);
+    intent.setType("vnd.android.cursor.item/event");
+    long startMilliseconds = start.getTime();
+    intent.putExtra("beginTime", startMilliseconds);
+    if (allDay) {
+      intent.putExtra("allDay", true);
+    }
+    long endMilliseconds;
+    if (end == null) {
+      if (allDay) {
+        // + 1 day
+        endMilliseconds = startMilliseconds + 24 * 60 * 60 * 1000;
+      } else {
+        endMilliseconds = startMilliseconds;
+      }
+    } else {
+      endMilliseconds = end.getTime();
+    }
+    intent.putExtra("endTime", endMilliseconds);
+    intent.putExtra("title", summary);
+    intent.putExtra("eventLocation", location);
+    intent.putExtra("description", description);
+    if (attendees != null) {
+      intent.putExtra(Intent.EXTRA_EMAIL, attendees);
+      // Documentation says this is either a String[] or comma-separated String, which is right?
+    }
+
+    try {
+      // Do this manually at first
+      rawLaunchIntent(intent);
+    } catch (ActivityNotFoundException anfe) {
+      Log.w(TAG, "No calendar app available that responds to " + Intent.ACTION_INSERT);
+      // For calendar apps that don't like "INSERT":
+      intent.setAction(Intent.ACTION_EDIT);
+      launchIntent(intent); // Fail here for real if nothing can handle it
+    }
+  }
+
+
+  @Override
+  public CharSequence getDisplayContents() {
+
+    CalendarParsedResult calResult = (CalendarParsedResult) getResult();
+    StringBuilder result = new StringBuilder(100);
+
+    ParsedResult.maybeAppend(calResult.getSummary(), result);
+
+    Date start = calResult.getStart();
+    ParsedResult.maybeAppend(format(calResult.isStartAllDay(), start), result);
+
+    Date end = calResult.getEnd();
+    if (end != null) {
+      if (calResult.isEndAllDay() && !start.equals(end)) {
+        // Show only year/month/day
+        // if it's all-day and this is the end date, it's exclusive, so show the user
+        // that it ends on the day before to make more intuitive sense.
+        // But don't do it if the event already (incorrectly?) specifies the same start/end
+        end = new Date(end.getTime() - 24 * 60 * 60 * 1000);
+      }
+      ParsedResult.maybeAppend(format(calResult.isEndAllDay(), end), result);
+    }
+
+    ParsedResult.maybeAppend(calResult.getLocation(), result);
+    ParsedResult.maybeAppend(calResult.getOrganizer(), result);
+    ParsedResult.maybeAppend(calResult.getAttendees(), result);
+    ParsedResult.maybeAppend(calResult.getDescription(), result);
+    return result.toString();
+  }
+
+  private static String format(boolean allDay, Date date) {
+    if (date == null) {
+      return null;
+    }
+    DateFormat format = allDay
+        ? DateFormat.getDateInstance(DateFormat.MEDIUM)
+        : DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);
+    return format.format(date);
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_calendar;
+  }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/EmailAddressResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/EmailAddressResultHandler.java
new file mode 100644
index 0000000..bdb58eb
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/EmailAddressResultHandler.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.client.result.EmailAddressParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.documentsui.R;
+
+/**
+ * Handles email addresses.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class EmailAddressResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_email,
+      R.string.button_add_contact
+  };
+
+  public EmailAddressResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    EmailAddressParsedResult emailResult = (EmailAddressParsedResult) getResult();
+    switch (index) {
+      case 0:
+        sendEmail(emailResult.getTos(),
+                  emailResult.getCCs(),
+                  emailResult.getBCCs(),
+                  emailResult.getSubject(),
+                  emailResult.getBody());
+        break;
+      case 1:
+        addEmailOnlyContact(emailResult.getTos(), null);
+        break;
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_email_address;
+  }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/GeoResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/GeoResultHandler.java
new file mode 100644
index 0000000..67160a2
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/GeoResultHandler.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.client.result.GeoParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.documentsui.R;
+
+
+/**
+ * Handles geographic coordinates (typically encoded as geo: URLs).
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class GeoResultHandler extends ResultHandler {
+    private static final int[] buttons = {
+            R.string.button_show_map,
+            R.string.button_get_directions
+    };
+
+    public GeoResultHandler(Activity activity, ParsedResult result) {
+        super(activity, result);
+    }
+
+    @Override
+    public int getButtonCount() {
+        return buttons.length;
+    }
+
+    @Override
+    public int getButtonText(int index) {
+        return buttons[index];
+    }
+
+    @Override
+    public void handleButtonPress(int index) {
+        GeoParsedResult geoResult = (GeoParsedResult) getResult();
+        switch (index) {
+            case 0:
+                openMap(geoResult.getGeoURI());
+                break;
+            case 1:
+                getDirections(geoResult.getLatitude(), geoResult.getLongitude());
+                break;
+        }
+    }
+
+    @Override
+    public int getDisplayTitle() {
+        return R.string.result_geo;
+    }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/ISBNResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/ISBNResultHandler.java
new file mode 100644
index 0000000..c5705bc
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/ISBNResultHandler.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ISBNParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.documentsui.R;
+
+/**
+ * Handles books encoded by their ISBN values.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ISBNResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_product_search,
+      R.string.button_book_search,
+      R.string.button_search_book_contents,
+      R.string.button_custom_product_search
+  };
+
+  public ISBNResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+    super(activity, result, rawResult);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    ISBNParsedResult isbnResult = (ISBNParsedResult) getResult();
+    switch (index) {
+      case 0:
+        openProductSearch(isbnResult.getISBN());
+        break;
+      case 1:
+        openBookSearch(isbnResult.getISBN());
+        break;
+      case 3:
+        openURL(fillInCustomSearchURL(isbnResult.getISBN()));
+        break;
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_isbn;
+  }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/ProductResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/ProductResultHandler.java
new file mode 100644
index 0000000..5f770f1
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/ProductResultHandler.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ExpandedProductParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.ProductParsedResult;
+
+import com.android.documentsui.R;
+
+
+/**
+ * Handles generic products which are not books.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ProductResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_product_search,
+      R.string.button_web_search,
+      R.string.button_custom_product_search
+  };
+
+  public ProductResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+    super(activity, result, rawResult);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    String productID = getProductIDFromResult(getResult());
+    switch (index) {
+      case 0:
+        openProductSearch(productID);
+        break;
+      case 1:
+        webSearch(productID);
+        break;
+      case 2:
+        openURL(fillInCustomSearchURL(productID));
+        break;
+    }
+  }
+
+  private static String getProductIDFromResult(ParsedResult rawResult) {
+    if (rawResult instanceof ProductParsedResult) {
+      return ((ProductParsedResult) rawResult).getNormalizedProductID();
+    }
+    if (rawResult instanceof ExpandedProductParsedResult) {
+      return ((ExpandedProductParsedResult) rawResult).getRawText();
+    }
+    throw new IllegalArgumentException(rawResult.getClass().toString());
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_product;
+  }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/ResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/ResultHandler.java
new file mode 100644
index 0000000..1dd20ea
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/ResultHandler.java
@@ -0,0 +1,497 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ActivityNotFoundException;
+import android.content.ContentValues;
+import android.content.Intent;
+import android.net.Uri;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.ParsedResultType;
+import com.google.zxing.client.result.ResultParser;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.Locale;
+
+import com.android.documentsui.R;
+import com.android.documentsui.DSN.ui.common.barcode.Contents;
+import com.android.documentsui.DSN.ui.common.barcode.LocaleManager;
+
+
+/**
+ * A base class for the Android-specific barcode handlers. These allow the app to polymorphically
+ * suggest the appropriate actions for each data type.
+ * <p>
+ * This class also contains a bunch of utility methods to take common actions like opening a URL.
+ * They could easily be moved into a helper object, but it can't be static because the Activity
+ * instance is needed to launch an intent.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ * @author Sean Owen
+ */
+public abstract class ResultHandler {
+
+    private static final String TAG = ResultHandler.class.getSimpleName();
+
+    private static final String[] EMAIL_TYPE_STRINGS = {"home", "work", "mobile"};
+    private static final String[] PHONE_TYPE_STRINGS = {"home", "work", "mobile", "fax", "pager", "main"};
+    private static final String[] ADDRESS_TYPE_STRINGS = {"home", "work"};
+    private static final int[] EMAIL_TYPE_VALUES = {
+            ContactsContract.CommonDataKinds.Email.TYPE_HOME,
+            ContactsContract.CommonDataKinds.Email.TYPE_WORK,
+            ContactsContract.CommonDataKinds.Email.TYPE_MOBILE,
+    };
+    private static final int[] PHONE_TYPE_VALUES = {
+            ContactsContract.CommonDataKinds.Phone.TYPE_HOME,
+            ContactsContract.CommonDataKinds.Phone.TYPE_WORK,
+            ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE,
+            ContactsContract.CommonDataKinds.Phone.TYPE_FAX_WORK,
+            ContactsContract.CommonDataKinds.Phone.TYPE_PAGER,
+            ContactsContract.CommonDataKinds.Phone.TYPE_MAIN,
+    };
+    private static final int[] ADDRESS_TYPE_VALUES = {
+            ContactsContract.CommonDataKinds.StructuredPostal.TYPE_HOME,
+            ContactsContract.CommonDataKinds.StructuredPostal.TYPE_WORK,
+    };
+    private static final int NO_TYPE = -1;
+
+    public static final int MAX_BUTTON_COUNT = 4;
+
+    private final ParsedResult result;
+    private final Activity activity;
+    private final Result rawResult;
+    private final String customProductSearch;
+
+    ResultHandler(Activity activity, ParsedResult result) {
+        this(activity, result, null);
+    }
+
+    ResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+        this.result = result;
+        this.activity = activity;
+        this.rawResult = rawResult;
+        this.customProductSearch = parseCustomSearchURL();
+    }
+
+    public final ParsedResult getResult() {
+        return result;
+    }
+
+    final boolean hasCustomProductSearch() {
+        return customProductSearch != null;
+    }
+
+    final Activity getActivity() {
+        return activity;
+    }
+
+    /**
+     * Indicates how many buttons the derived class wants shown.
+     *
+     * @return The integer button count.
+     */
+    public abstract int getButtonCount();
+
+    /**
+     * The text of the nth action button.
+     *
+     * @param index From 0 to getButtonCount() - 1
+     * @return The button text as a resource ID
+     */
+    public abstract int getButtonText(int index);
+
+    public Integer getDefaultButtonID() {
+        return null;
+    }
+
+    /**
+     * Execute the action which corresponds to the nth button.
+     *
+     * @param index The button that was clicked.
+     */
+    public abstract void handleButtonPress(int index);
+
+    /**
+     * Some barcode contents are considered secure, and should not be saved to history, copied to
+     * the clipboard, or otherwise persisted.
+     *
+     * @return If true, do not create any permanent record of these contents.
+     */
+    public boolean areContentsSecure() {
+        return false;
+    }
+
+    /**
+     * Create a possibly styled string for the contents of the current barcode.
+     *
+     * @return The text to be displayed.
+     */
+    public CharSequence getDisplayContents() {
+        String contents = result.getDisplayResult();
+        return contents.replace("\r", "");
+    }
+
+    /**
+     * A string describing the kind of barcode that was found, e.g. "Found contact info".
+     *
+     * @return The resource ID of the string.
+     */
+    public abstract int getDisplayTitle();
+
+    /**
+     * A convenience method to get the parsed type. Should not be overridden.
+     *
+     * @return The parsed type, e.g. URI or ISBN
+     */
+    public final ParsedResultType getType() {
+        return result.getType();
+    }
+
+    final void addPhoneOnlyContact(String[] phoneNumbers, String[] phoneTypes) {
+        addContact(null, null, null, phoneNumbers, phoneTypes, null, null, null, null, null, null, null, null, null, null, null);
+    }
+
+    final void addEmailOnlyContact(String[] emails, String[] emailTypes) {
+        addContact(null, null, null, null, null, emails, emailTypes, null, null, null, null, null, null, null, null, null);
+    }
+
+    final void addContact(String[] names,
+                          String[] nicknames,
+                          String pronunciation,
+                          String[] phoneNumbers,
+                          String[] phoneTypes,
+                          String[] emails,
+                          String[] emailTypes,
+                          String note,
+                          String instantMessenger,
+                          String address,
+                          String addressType,
+                          String org,
+                          String title,
+                          String[] urls,
+                          String birthday,
+                          String[] geo) {
+
+        // Only use the first name in the array, if present.
+        Intent intent = new Intent(Intent.ACTION_INSERT_OR_EDIT, ContactsContract.Contacts.CONTENT_URI);
+        intent.setType(ContactsContract.Contacts.CONTENT_ITEM_TYPE);
+        putExtra(intent, ContactsContract.Intents.Insert.NAME, names != null ? names[0] : null);
+
+        putExtra(intent, ContactsContract.Intents.Insert.PHONETIC_NAME, pronunciation);
+
+        int phoneCount = Math.min(phoneNumbers != null ? phoneNumbers.length : 0, Contents.PHONE_KEYS.length);
+        for (int x = 0; x < phoneCount; x++) {
+            putExtra(intent, Contents.PHONE_KEYS[x], phoneNumbers[x]);
+            if (phoneTypes != null && x < phoneTypes.length) {
+                int type = toPhoneContractType(phoneTypes[x]);
+                if (type >= 0) {
+                    intent.putExtra(Contents.PHONE_TYPE_KEYS[x], type);
+                }
+            }
+        }
+
+        int emailCount = Math.min(emails != null ? emails.length : 0, Contents.EMAIL_KEYS.length);
+        for (int x = 0; x < emailCount; x++) {
+            putExtra(intent, Contents.EMAIL_KEYS[x], emails[x]);
+            if (emailTypes != null && x < emailTypes.length) {
+                int type = toEmailContractType(emailTypes[x]);
+                if (type >= 0) {
+                    intent.putExtra(Contents.EMAIL_TYPE_KEYS[x], type);
+                }
+            }
+        }
+
+        ArrayList<ContentValues> data = new ArrayList<>();
+        if (urls != null) {
+            for (String url : urls) {
+                if (url != null && !url.isEmpty()) {
+                    ContentValues row = new ContentValues(2);
+                    row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Website.CONTENT_ITEM_TYPE);
+                    row.put(ContactsContract.CommonDataKinds.Website.URL, url);
+                    data.add(row);
+                    break;
+                }
+            }
+        }
+
+        if (birthday != null) {
+            ContentValues row = new ContentValues(3);
+            row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
+            row.put(ContactsContract.CommonDataKinds.Event.TYPE, ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY);
+            row.put(ContactsContract.CommonDataKinds.Event.START_DATE, birthday);
+            data.add(row);
+        }
+
+        if (nicknames != null) {
+            for (String nickname : nicknames) {
+                if (nickname != null && !nickname.isEmpty()) {
+                    ContentValues row = new ContentValues(3);
+                    row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Nickname.CONTENT_ITEM_TYPE);
+                    row.put(ContactsContract.CommonDataKinds.Nickname.TYPE,
+                            ContactsContract.CommonDataKinds.Nickname.TYPE_DEFAULT);
+                    row.put(ContactsContract.CommonDataKinds.Nickname.NAME, nickname);
+                    data.add(row);
+                    break;
+                }
+            }
+        }
+
+        if (!data.isEmpty()) {
+            intent.putParcelableArrayListExtra(ContactsContract.Intents.Insert.DATA, data);
+        }
+
+        StringBuilder aggregatedNotes = new StringBuilder();
+        if (note != null) {
+            aggregatedNotes.append('\n').append(note);
+        }
+        if (geo != null) {
+            aggregatedNotes.append('\n').append(geo[0]).append(',').append(geo[1]);
+        }
+
+        if (aggregatedNotes.length() > 0) {
+            // Remove extra leading '\n'
+            putExtra(intent, ContactsContract.Intents.Insert.NOTES, aggregatedNotes.substring(1));
+        }
+
+        putExtra(intent, ContactsContract.Intents.Insert.IM_HANDLE, instantMessenger);
+        putExtra(intent, ContactsContract.Intents.Insert.POSTAL, address);
+        if (addressType != null) {
+            int type = toAddressContractType(addressType);
+            if (type >= 0) {
+                intent.putExtra(ContactsContract.Intents.Insert.POSTAL_TYPE, type);
+            }
+        }
+        putExtra(intent, ContactsContract.Intents.Insert.COMPANY, org);
+        putExtra(intent, ContactsContract.Intents.Insert.JOB_TITLE, title);
+        launchIntent(intent);
+    }
+
+    private static int toEmailContractType(String typeString) {
+        return doToContractType(typeString, EMAIL_TYPE_STRINGS, EMAIL_TYPE_VALUES);
+    }
+
+    private static int toPhoneContractType(String typeString) {
+        return doToContractType(typeString, PHONE_TYPE_STRINGS, PHONE_TYPE_VALUES);
+    }
+
+    private static int toAddressContractType(String typeString) {
+        return doToContractType(typeString, ADDRESS_TYPE_STRINGS, ADDRESS_TYPE_VALUES);
+    }
+
+    private static int doToContractType(String typeString, String[] types, int[] values) {
+        if (typeString == null) {
+            return NO_TYPE;
+        }
+        for (int i = 0; i < types.length; i++) {
+            String type = types[i];
+            if (typeString.startsWith(type) || typeString.startsWith(type.toUpperCase(Locale.ENGLISH))) {
+                return values[i];
+            }
+        }
+        return NO_TYPE;
+    }
+
+    final void shareByEmail(String contents) {
+        sendEmail(null, null, null, null, contents);
+    }
+
+    final void sendEmail(String[] to,
+                         String[] cc,
+                         String[] bcc,
+                         String subject,
+                         String body) {
+        Intent intent = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
+        if (to != null && to.length != 0) {
+            intent.putExtra(Intent.EXTRA_EMAIL, to);
+        }
+        if (cc != null && cc.length != 0) {
+            intent.putExtra(Intent.EXTRA_CC, cc);
+        }
+        if (bcc != null && bcc.length != 0) {
+            intent.putExtra(Intent.EXTRA_BCC, bcc);
+        }
+        putExtra(intent, Intent.EXTRA_SUBJECT, subject);
+        putExtra(intent, Intent.EXTRA_TEXT, body);
+        intent.setType("text/plain");
+        launchIntent(intent);
+    }
+
+    final void shareBySMS(String contents) {
+        sendSMSFromUri("smsto:", contents);
+    }
+
+    final void sendSMS(String phoneNumber, String body) {
+        sendSMSFromUri("smsto:" + phoneNumber, body);
+    }
+
+    private void sendSMSFromUri(String uri, String body) {
+        Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));
+        putExtra(intent, "sms_body", body);
+        // Exit the app once the SMS is sent
+        intent.putExtra("compose_mode", true);
+        launchIntent(intent);
+    }
+
+    final void sendMMS(String phoneNumber, String subject, String body) {
+        sendMMSFromUri("mmsto:" + phoneNumber, subject, body);
+    }
+
+    private void sendMMSFromUri(String uri, String subject, String body) {
+        Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));
+        // The Messaging app needs to see a valid subject or else it will treat this an an SMS.
+        if (subject == null || subject.isEmpty()) {
+            putExtra(intent, "subject", activity.getString(R.string.msg_default_mms_subject));
+        } else {
+            putExtra(intent, "subject", subject);
+        }
+        putExtra(intent, "sms_body", body);
+        intent.putExtra("compose_mode", true);
+        launchIntent(intent);
+    }
+
+    final void dialPhone(String phoneNumber) {
+        launchIntent(new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + phoneNumber)));
+    }
+
+    final void dialPhoneFromUri(String uri) {
+        launchIntent(new Intent(Intent.ACTION_DIAL, Uri.parse(uri)));
+    }
+
+    final void openMap(String geoURI) {
+        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(geoURI)));
+    }
+
+    /**
+     * Do a geo search using the address as the query.
+     *
+     * @param address The address to find
+     */
+    final void searchMap(String address) {
+        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse("geo:0,0?q=" + Uri.encode(address))));
+    }
+
+    final void getDirections(double latitude, double longitude) {
+        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse("http://maps.google." +
+                LocaleManager.getCountryTLD(activity) + "/maps?f=d&daddr=" + latitude + ',' + longitude)));
+    }
+
+    // Uses the mobile-specific version of Product Search, which is formatted for small screens.
+    final void openProductSearch(String upc) {
+        Uri uri = Uri.parse("http://www.google." + LocaleManager.getProductSearchCountryTLD(activity) +
+                "/m/products?q=" + upc + "&source=zxing");
+        launchIntent(new Intent(Intent.ACTION_VIEW, uri));
+    }
+
+    final void openBookSearch(String isbn) {
+        Uri uri = Uri.parse("http://books.google." + LocaleManager.getBookSearchCountryTLD(activity) +
+                "/books?vid=isbn" + isbn);
+        launchIntent(new Intent(Intent.ACTION_VIEW, uri));
+    }
+
+    final void openURL(String url) {
+        // Strangely, some Android browsers don't seem to register to handle HTTP:// or HTTPS://.
+        // Lower-case these as it should always be OK to lower-case these schemes.
+        if (url.startsWith("HTTP://")) {
+            url = "http" + url.substring(4);
+        } else if (url.startsWith("HTTPS://")) {
+            url = "https" + url.substring(5);
+        }
+        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+        try {
+            launchIntent(intent);
+        } catch (ActivityNotFoundException ignored) {
+            Log.w(TAG, "Nothing available to handle " + intent);
+        }
+    }
+
+    final void webSearch(String query) {
+        Intent intent = new Intent(Intent.ACTION_WEB_SEARCH);
+        intent.putExtra("query", query);
+        launchIntent(intent);
+    }
+
+    /**
+     * Like {@link #launchIntent(Intent)} but will tell you if it is not handle-able
+     * via {@link ActivityNotFoundException}.
+     *
+     * @throws ActivityNotFoundException if Intent can't be handled
+     */
+    final void rawLaunchIntent(Intent intent) {
+        if (intent != null) {
+            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+            Log.d(TAG, "Launching intent: " + intent + " with extras: " + intent.getExtras());
+            activity.startActivity(intent);
+        }
+    }
+
+    /**
+     * Like {@link #rawLaunchIntent(Intent)} but will show a user dialog if nothing is available to handle.
+     */
+    final void launchIntent(Intent intent) {
+        try {
+            rawLaunchIntent(intent);
+        } catch (ActivityNotFoundException ignored) {
+            AlertDialog.Builder builder = new AlertDialog.Builder(activity);
+            builder.setTitle(R.string.app_name);
+            builder.setMessage(R.string.msg_intent_failed);
+            builder.setPositiveButton(R.string.confirm, null);
+            builder.show();
+        }
+    }
+
+    private static void putExtra(Intent intent, String key, String value) {
+        if (value != null && !value.isEmpty()) {
+            intent.putExtra(key, value);
+        }
+    }
+
+    private String parseCustomSearchURL() {
+        return null;
+    }
+
+    final String fillInCustomSearchURL(String text) {
+        if (customProductSearch == null) {
+            return text; // ?
+        }
+        try {
+            text = URLEncoder.encode(text, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            // can't happen; UTF-8 is always supported. Continue, I guess, without encoding
+        }
+        String url = customProductSearch;
+        if (rawResult != null) {
+            // Replace %f but only if it doesn't seem to be a hex escape sequence. This remains
+            // problematic but avoids the more surprising problem of breaking escapes
+            url = url.replaceFirst("%f(?![0-9a-f])", rawResult.getBarcodeFormat().toString());
+            if (url.contains("%t")) {
+                ParsedResult parsedResultAgain = ResultParser.parseResult(rawResult);
+                url = url.replace("%t", parsedResultAgain.getType().toString());
+            }
+        }
+        // Replace %s last as it might contain itself %f or %t
+        return url.replace("%s", text);
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/ResultHandlerFactory.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/ResultHandlerFactory.java
new file mode 100644
index 0000000..b83d50b
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/ResultHandlerFactory.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.ResultParser;
+
+import com.android.documentsui.DSN.ui.common.barcode.CaptureActivity;
+
+
+/**
+ * Manufactures Android-specific handlers based on the barcode content's type.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ResultHandlerFactory {
+  private ResultHandlerFactory() {
+  }
+
+  public static ResultHandler makeResultHandler(CaptureActivity activity, Result rawResult) {
+    ParsedResult result = parseResult(rawResult);
+    switch (result.getType()) {
+      case ADDRESSBOOK:
+        return new AddressBookResultHandler(activity, result);
+      case EMAIL_ADDRESS:
+        return new EmailAddressResultHandler(activity, result);
+      case PRODUCT:
+        return new ProductResultHandler(activity, result, rawResult);
+      case URI:
+        return new URIResultHandler(activity, result);
+      case GEO:
+        return new GeoResultHandler(activity, result);
+      case TEL:
+        return new TelResultHandler(activity, result);
+      case SMS:
+        return new SMSResultHandler(activity, result);
+      case CALENDAR:
+        return new CalendarResultHandler(activity, result);
+      case ISBN:
+        return new ISBNResultHandler(activity, result, rawResult);
+      default:
+        return new TextResultHandler(activity, result, rawResult);
+    }
+  }
+
+  private static ParsedResult parseResult(Result rawResult) {
+    return ResultParser.parseResult(rawResult);
+  }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/SMSResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/SMSResultHandler.java
new file mode 100644
index 0000000..90d70f0
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/SMSResultHandler.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+import android.telephony.PhoneNumberUtils;
+
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.SMSParsedResult;
+
+import com.android.documentsui.R;
+
+/**
+ * Handles SMS addresses, offering a choice of composing a new SMS or MMS message.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class SMSResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_sms,
+      R.string.button_mms
+  };
+
+  public SMSResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    SMSParsedResult smsResult = (SMSParsedResult) getResult();
+    String number = smsResult.getNumbers()[0];
+    switch (index) {
+      case 0:
+        // Don't know of a way yet to express a SENDTO intent with multiple recipients
+        sendSMS(number, smsResult.getBody());
+        break;
+      case 1:
+        sendMMS(number, smsResult.getSubject(), smsResult.getBody());
+        break;
+    }
+  }
+
+  @Override
+  public CharSequence getDisplayContents() {
+    SMSParsedResult smsResult = (SMSParsedResult) getResult();
+    String[] rawNumbers = smsResult.getNumbers();
+    String[] formattedNumbers = new String[rawNumbers.length];
+    for (int i = 0; i < rawNumbers.length; i++) {
+      formattedNumbers[i] = PhoneNumberUtils.formatNumber(rawNumbers[i]);
+    }
+    StringBuilder contents = new StringBuilder(50);
+    ParsedResult.maybeAppend(formattedNumbers, contents);
+    ParsedResult.maybeAppend(smsResult.getSubject(), contents);
+    ParsedResult.maybeAppend(smsResult.getBody(), contents);
+    return contents.toString();
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_sms;
+  }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/TelResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/TelResultHandler.java
new file mode 100644
index 0000000..c8e919b
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/TelResultHandler.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+import android.telephony.PhoneNumberUtils;
+
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.TelParsedResult;
+
+import com.android.documentsui.R;
+
+
+/**
+ * Offers relevant actions for telephone numbers.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class TelResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_dial,
+      R.string.button_add_contact
+  };
+
+  public TelResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    TelParsedResult telResult = (TelParsedResult) getResult();
+    switch (index) {
+      case 0:
+        dialPhoneFromUri(telResult.getTelURI());
+        // When dialer comes up, it allows underlying display activity to continue or something,
+        // but app can't get camera in this state. Avoid issues by just quitting, only in the
+        // case of a phone number
+        getActivity().finish();
+        break;
+      case 1:
+        String[] numbers = new String[1];
+        numbers[0] = telResult.getNumber();
+        addPhoneOnlyContact(numbers, null);
+        break;
+    }
+  }
+
+  // Overriden so we can take advantage of Android's phone number hyphenation routines.
+  @Override
+  public CharSequence getDisplayContents() {
+    String contents = getResult().getDisplayResult();
+    contents = contents.replace("\r", "");
+    return PhoneNumberUtils.formatNumber(contents);
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_tel;
+  }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/TextResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/TextResultHandler.java
new file mode 100644
index 0000000..2ee6481
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/TextResultHandler.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.documentsui.R;
+
+
+/**
+ * This class handles TextParsedResult as well as unknown formats. It's the fallback handler.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class TextResultHandler extends ResultHandler {
+
+  private static final int[] buttons = {
+      R.string.button_web_search,
+      R.string.button_share_by_email,
+      R.string.button_share_by_sms,
+      R.string.button_custom_product_search,
+  };
+
+  public TextResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+    super(activity, result, rawResult);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    String text = getResult().getDisplayResult();
+    switch (index) {
+      case 0:
+        webSearch(text);
+        break;
+      case 1:
+        shareByEmail(text);
+        break;
+      case 2:
+        shareBySMS(text);
+        break;
+      case 3:
+        openURL(fillInCustomSearchURL(text));
+        break;
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_text;
+  }
+}
diff --git a/src/com/android/documentsui/DSN/ui/common/barcode/result/URIResultHandler.java b/src/com/android/documentsui/DSN/ui/common/barcode/result/URIResultHandler.java
new file mode 100644
index 0000000..2e63045
--- /dev/null
+++ b/src/com/android/documentsui/DSN/ui/common/barcode/result/URIResultHandler.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.documentsui.DSN.ui.common.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.URIParsedResult;
+
+import java.util.Locale;
+
+import com.android.documentsui.R;
+import com.android.documentsui.DSN.ui.common.barcode.LocaleManager;
+
+
+/**
+ * Offers appropriate actions for URLS.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class URIResultHandler extends ResultHandler {
+    // URIs beginning with entries in this array will not be saved to history or copied to the
+    // clipboard for security.
+    private static final String[] SECURE_PROTOCOLS = {
+            "otpauth:"
+    };
+
+    private static final int[] buttons = {
+            R.string.button_open_browser,
+            R.string.button_share_by_email,
+            R.string.button_share_by_sms,
+            R.string.button_search_book_contents,
+    };
+
+    public URIResultHandler(Activity activity, ParsedResult result) {
+        super(activity, result);
+    }
+
+    @Override
+    public int getButtonCount() {
+        if (LocaleManager.isBookSearchUrl(((URIParsedResult) getResult()).getURI())) {
+            return buttons.length;
+        }
+        return buttons.length - 1;
+    }
+
+    @Override
+    public int getButtonText(int index) {
+        return buttons[index];
+    }
+
+    @Override
+    public Integer getDefaultButtonID() {
+        return 0;
+    }
+
+    @Override
+    public void handleButtonPress(int index) {
+        URIParsedResult uriResult = (URIParsedResult) getResult();
+        String uri = uriResult.getURI();
+        switch (index) {
+            case 0:
+                openURL(uri);
+                break;
+            case 1:
+                shareByEmail(uri);
+                break;
+            case 2:
+                shareBySMS(uri);
+                break;
+        }
+    }
+
+    @Override
+    public int getDisplayTitle() {
+        return R.string.result_uri;
+    }
+
+    @Override
+    public boolean areContentsSecure() {
+        URIParsedResult uriResult = (URIParsedResult) getResult();
+        String uri = uriResult.getURI().toLowerCase(Locale.ENGLISH);
+        for (String secure : SECURE_PROTOCOLS) {
+            if (uri.startsWith(secure)) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/com/android/documentsui/DSN/util/CommonUtil.java b/src/com/android/documentsui/DSN/util/CommonUtil.java
new file mode 100644
index 0000000..b89decd
--- /dev/null
+++ b/src/com/android/documentsui/DSN/util/CommonUtil.java
@@ -0,0 +1,169 @@
+package com.android.documentsui.DSN.util;
+
+import android.Manifest;
+import android.app.Activity;
+import android.app.KeyguardManager;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.hardware.fingerprint.FingerprintManager;
+import android.os.Build;
+import android.support.v4.app.ActivityCompat;
+import android.util.DisplayMetrics;
+import android.util.Log;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import com.google.gson.JsonParseException;
+
+
+public class CommonUtil {
+    public static int MNEMONIC_WORD_LENGTH = 12;
+
+    public static String generateSimpleAddress(String fullAddress) {
+        String simpleName = fullAddress;
+        if (fullAddress.length() > 18) {
+            simpleName = fullAddress.substring(0, 10) + "..." + fullAddress.substring(fullAddress.length() - 8);
+        }
+        return simpleName;
+    }
+
+    public static BigDecimal getAccountFromWei(BigInteger value) {
+        BigDecimal bigDecimal = new BigDecimal(value);
+        return bigDecimal.divide(new BigDecimal(Math.pow(10, 18)), 4, BigDecimal.ROUND_HALF_UP);
+    }
+
+    public static String parseAccountContent(String value) {
+        return value.replaceAll("\\s*", "");
+    }
+
+    public static BigInteger convertWeiFromEther(BigDecimal value) {
+        return value.multiply(new BigDecimal(Math.pow(10, 18))).toBigInteger();
+    }
+
+    public static boolean isPasswordValid(String password) {
+        return password.length() > 4;
+    }
+
+    // Return network name base of url
+    public static String generateNetworkName(String url) {
+        if (url.contains("mainnet")) {
+            return "Mainnet";
+        } else if (url.contains("ropsten")) {
+            return "Ropsten";
+        } else if (url.contains("infuranet")) {
+            return "INFURAnet";
+        } else if (url.contains("kovan")) {
+            return "Kovan";
+        } else if (url.contains("rinkeby")) {
+            return "Rinkeby";
+        } else {
+            return "";
+        }
+    }
+
+
+
+    public static int getScreenWidth(Activity context) {
+        DisplayMetrics dm = new DisplayMetrics();
+        context.getWindowManager().getDefaultDisplay().getMetrics(dm);
+        return dm.widthPixels;
+    }
+
+
+    public static int getScreenHeight(Activity context) {
+        DisplayMetrics dm = new DisplayMetrics();
+        context.getWindowManager().getDefaultDisplay().getMetrics(dm);
+        return dm.heightPixels;
+    }
+
+    public static int dip2px(Context context, float dpValue) {
+        final float scale = context.getResources().getDisplayMetrics().density;
+        return (int) (dpValue * scale + 0.5f);
+    }
+
+     public static boolean isGoodJson(String jsonStr) {
+        JsonElement jsonElement;
+        try {
+            jsonElement = new JsonParser().parse(jsonStr);
+        } catch (Exception e) {
+            return false;
+        }
+        if (jsonElement == null) {
+            return false;
+            }
+        if (!jsonElement.isJsonObject()) {
+            return false;
+            }
+        return true;
+    }
+
+
+    public static boolean isValidMnemonics(String mnemonics) {
+        String[] mnemonicList = mnemonics.split(" ");
+        return mnemonicList.length == MNEMONIC_WORD_LENGTH;
+    }
+
+    public static JsonObject stringToJson(String json){
+        JsonParser jp = new JsonParser();
+        JsonObject jsonObj = jp.parse(json).getAsJsonObject();
+        return jsonObj;
+    }
+
+    public static boolean isFinger(Context context) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            FingerprintManager manager = (FingerprintManager) context.getSystemService(Context.FINGERPRINT_SERVICE);
+            KeyguardManager mKeyManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
+            if (ActivityCompat.checkSelfPermission(context, Manifest.permission.USE_FINGERPRINT) != PackageManager.PERMISSION_GRANTED) {
+                return false;
+            }
+
+            if (manager == null || mKeyManager == null) {
+                return false;
+            }
+            // Is hardware detected fingerprint
+            if (!manager.isHardwareDetected()) {
+                return false;
+            }
+
+            //is open PIN
+            if (!mKeyManager.isKeyguardSecure()) {
+                return false;
+            }
+
+            //Is enrolled fingerprint
+            if (!manager.hasEnrolledFingerprints()) {
+               // BLog.d("commonUtils", "no fingerprint");
+                return false;
+            }
+            return true;
+        } else{
+            return false;
+        }
+    }
+
+    /**
+     * Timestamp converted to date format string
+     * */
+    public static String timestampToDate(long seconds, String format) {
+        if(format == null || format.isEmpty()) {
+            format = "yyyy-MM-dd HH:mm:ss";
+        }
+        SimpleDateFormat sdf = new SimpleDateFormat(format);
+        return sdf.format(new Date(seconds * 1000));
+    }
+
+}
diff --git a/src/com/android/documentsui/DSN/util/PermissionUtil.java b/src/com/android/documentsui/DSN/util/PermissionUtil.java
new file mode 100644
index 0000000..b8b537c
--- /dev/null
+++ b/src/com/android/documentsui/DSN/util/PermissionUtil.java
@@ -0,0 +1,138 @@
+/*
+* Copyright 2015 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.documentsui.DSN.util;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.provider.Settings;
+import android.support.v4.app.ActivityCompat;
+import android.support.v7.app.AlertDialog;
+import android.util.Log;
+import android.widget.Toast;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.android.documentsui.R;
+
+/**
+ * Utility class that wraps access to the runtime permissions API in M and provides basic helper
+ * methods.
+ */
+public class PermissionUtil {
+
+    private static final String TAG = PermissionUtil.class.getSimpleName();
+    public static final int CODE_CAMERA_SCAN = 10000;
+    public static final int CODE_EXTERNAL_STORAGE = 10001;
+
+    public static final String PERMISSION_CAMERA = Manifest.permission.CAMERA;
+    public static final String PERMISSION_WRITE_EXTERNAL_STORAGE = Manifest.permission.WRITE_EXTERNAL_STORAGE;
+
+    public static final String[] CAMERA_PERMISSIONS = {
+            PERMISSION_CAMERA
+    };
+
+    public static final String[] EXTERNAL_STORAGE_PERMISSIONS = {
+            PERMISSION_WRITE_EXTERNAL_STORAGE
+    };
+
+    /**
+     * Check that all given permissions have been granted by verifying that each entry in the
+     * given array is of the value {@link PackageManager#PERMISSION_GRANTED}.
+     *
+     * @see Activity#onRequestPermissionsResult(int, String[], int[])
+     */
+    public static boolean verifyPermissions(int[] grantResults) {
+        // At least one result must be checked.
+        if(grantResults.length < 1){
+            return false;
+        }
+
+        // Verify that each required permission has been granted, otherwise return false.
+        for (int result : grantResults) {
+            if (result != PackageManager.PERMISSION_GRANTED) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Request multi permissions one time.
+     */
+    public static void requestMultiPermissions(final Activity activity, String[] permissionList, int requestCode) {
+
+        final List<String> unGrantPermissionsList = getNoGrantedPermission(activity, permissionList);
+
+        if (unGrantPermissionsList == null) {
+            return;
+        }
+        Log.d(TAG, "requestMultiPermissions permissionsList:" + unGrantPermissionsList.size());
+
+        if (unGrantPermissionsList.size() > 0) {
+            ActivityCompat.requestPermissions(activity, unGrantPermissionsList.toArray(new String[unGrantPermissionsList.size()]),
+                    requestCode);
+            Log.d(TAG, "showMessageOKCancel requestPermissions");
+        }
+    }
+
+    public static ArrayList<String> getNoGrantedPermission(Activity activity, String[] permissionList) {
+
+        ArrayList<String> permissions = new ArrayList<>();
+
+        for (int i = 0; i < permissionList.length; i++) {
+            String requestPermission = permissionList[i];
+
+            // default PERMISSION DENIED
+            int checkSelfPermission = PackageManager.PERMISSION_DENIED;
+            try {
+                checkSelfPermission = ActivityCompat.checkSelfPermission(activity, requestPermission);
+            } catch (RuntimeException e) {
+                Toast.makeText(activity, "please open those permission", Toast.LENGTH_SHORT)
+                        .show();
+                Log.e(TAG, "RuntimeException:" + e.getMessage());
+                return null;
+            }
+
+            if (checkSelfPermission != PackageManager.PERMISSION_GRANTED) {
+                permissions.add(requestPermission);
+            }
+        }
+        return permissions;
+    }
+
+    // Show the tip dialog
+    public static void openSettingActivity(final Activity activity, String message) {
+        new AlertDialog.Builder(activity)
+                .setMessage(message)
+                .setPositiveButton(R.string.action_go_settings, (dialog, which) -> {
+                    Intent intent = new Intent();
+                    intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+                    Log.d(TAG, "getPackageName(): " + activity.getPackageName());
+                    Uri uri = Uri.fromParts("package", activity.getPackageName(), null);
+                    intent.setData(uri);
+                    activity.startActivity(intent);
+                })
+                .setNegativeButton(R.string.cancel, null)
+                .create()
+                .show();
+    }
+}
diff --git a/src/com/android/documentsui/DSN/util/QRCodeUtil.java b/src/com/android/documentsui/DSN/util/QRCodeUtil.java
new file mode 100644
index 0000000..0a99b7c
--- /dev/null
+++ b/src/com/android/documentsui/DSN/util/QRCodeUtil.java
@@ -0,0 +1,165 @@
+package com.android.documentsui.DSN.util;
+
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.EncodeHintType;
+import com.google.zxing.WriterException;
+import com.google.zxing.common.BitMatrix;
+import com.google.zxing.qrcode.QRCodeWriter;
+import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
+
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import android.util.Log;
+
+
+public class QRCodeUtil {
+    /**
+     * Generate qrcode Bitmap
+     *
+     * @param content   the content
+     * @param widthPix  image width
+     * @param heightPix image height
+     * @param logoBm    the center logo (allow to be null)
+     * @return Generate qr code and save the file is successful
+     */
+    public static Bitmap createQRImage(String content, int widthPix, int heightPix, Bitmap logoBm) {
+        try {
+            if (content == null || "".equals(content) || content.length() < 1) {
+                return null;
+            }
+
+            // set config params
+            Map<EncodeHintType, Object> hints = new HashMap<>();
+            hints.put(EncodeHintType.CHARACTER_SET, "utf-8");
+            //Error Correction Level
+            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);
+            hints.put(EncodeHintType.MARGIN, 0); //default is 4
+
+            BitMatrix bitMatrix = new QRCodeWriter().encode(content, BarcodeFormat.QR_CODE, widthPix, heightPix, hints);
+            int[] pixels = new int[widthPix * heightPix];
+            for (int y = 0; y < heightPix; y++) {
+                for (int x = 0; x < widthPix; x++) {
+                    if (bitMatrix.get(x, y)) {
+                        pixels[y * widthPix + x] = 0xff000000;
+                    } else {
+                        // the background color
+                        pixels[y * widthPix + x] = 0xfff2f1f1;
+                    }
+                }
+            }
+
+            Bitmap bitmap = Bitmap.createBitmap(widthPix, heightPix, Bitmap.Config.ARGB_8888);
+            bitmap.setPixels(pixels, 0, widthPix, 0, 0, widthPix, heightPix);
+
+            if (logoBm != null) {
+                bitmap = addLogo(bitmap, logoBm);
+            }
+
+            return bitmap;
+        } catch (WriterException e) {
+            e.printStackTrace();
+        }
+
+        return null;
+    }
+
+    /**
+     * Generate qrcode Bitmap
+     *
+     * @param content   the content
+     * @param widthPix  image width
+     * @param heightPix image height
+     * @param logoBm    the center logo (allow to be null)
+     * @return Generate qr code and save the file is successful
+     */
+    public static Bitmap createQRImageTransparentBg(String content, int widthPix, int heightPix, Bitmap logoBm) {
+        try {
+            if (content == null || "".equals(content) || content.length() < 1) {
+                return null;
+            }
+
+            // set config params
+            Map<EncodeHintType, Object> hints = new HashMap<>();
+            hints.put(EncodeHintType.CHARACTER_SET, "utf-8");
+            //Error Correction Level
+            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);
+            hints.put(EncodeHintType.MARGIN, 0); //default is 4
+
+            BitMatrix bitMatrix = new QRCodeWriter().encode(content, BarcodeFormat.QR_CODE, widthPix, heightPix, hints);
+            int[] pixels = new int[widthPix * heightPix];
+            for (int y = 0; y < heightPix; y++) {
+                for (int x = 0; x < widthPix; x++) {
+                    if (bitMatrix.get(x, y)) {
+                        pixels[y * widthPix + x] = 0xff000000;
+                    } else {
+                        // the background color
+                        pixels[y * widthPix + x] = 0xffffffff;
+                    }
+                }
+            }
+
+            Bitmap bitmap = Bitmap.createBitmap(widthPix, heightPix, Bitmap.Config.ARGB_8888);
+            bitmap.setPixels(pixels, 0, widthPix, 0, 0, widthPix, heightPix);
+
+            if (logoBm != null) {
+                bitmap = addLogo(bitmap, logoBm);
+            }
+
+            return bitmap;
+        } catch (WriterException e) {
+            e.printStackTrace();
+        }
+
+        return null;
+    }
+
+
+    /**
+     * Add logo in the qrcode image
+     */
+    private static Bitmap addLogo(Bitmap src, Bitmap logo) {
+        if (src == null) {
+            return null;
+        }
+
+        if (logo == null) {
+            return src;
+        }
+
+        int srcWidth = src.getWidth();
+        int srcHeight = src.getHeight();
+        int logoWidth = logo.getWidth();
+        int logoHeight = logo.getHeight();
+
+        if (srcWidth == 0 || srcHeight == 0) {
+            return null;
+        }
+
+        if (logoWidth == 0 || logoHeight == 0) {
+            return src;
+        }
+
+        float scaleFactor = srcWidth * 1.0f / 5 / logoWidth;
+        Bitmap bitmap = Bitmap.createBitmap(srcWidth, srcHeight, Bitmap.Config.ARGB_8888);
+        try {
+            Canvas canvas = new Canvas(bitmap);
+            canvas.drawBitmap(src, 0, 0, null);
+            canvas.scale(scaleFactor, scaleFactor, srcWidth / 2, srcHeight / 2);
+            canvas.drawBitmap(logo, (srcWidth - logoWidth) / 2, (srcHeight - logoHeight) / 2, null);
+
+            canvas.save(Canvas.ALL_SAVE_FLAG);
+            canvas.restore();
+        } catch (Exception e) {
+            bitmap = null;
+            e.getStackTrace();
+        }
+
+        return bitmap;
+    }
+}
diff --git a/src/com/android/documentsui/DSNObjectMetaLoader.java b/src/com/android/documentsui/DSNObjectMetaLoader.java
deleted file mode 100644
index ffc1c95..0000000
--- a/src/com/android/documentsui/DSNObjectMetaLoader.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.android.documentsui;
-
-import android.content.AsyncTaskLoader;
-import android.content.Context;
-import android.util.Log;
-
-public class DSNObjectMetaLoader extends AsyncTaskLoader<DSNObjectMeta>  {
-
-    public DSNObjectMetaLoader(Context context) {
-        super(context);
-    }
-
-    @Override
-    public final DSNObjectMeta loadInBackground() {
-        Log.d("---dsnLoader-----", "--------dsn load in background------");
-        final DSNObjectMeta result = new DSNObjectMeta();
-        result.hashKey = "hashKey";
-      //  HttpServer.getInstance().getHttpIpfsdata();
-        return result;
-    }
-
-    @Override
-    protected void onStartLoading() {
-        Log.d("---dsnLoader-----", "--------dsn onStartLoading------");
-        super.onStartLoading();
-        forceLoad();
-    }
-
-
-    @Override
-    protected void onStopLoading() {
-        Log.d("---dsnLoader-----", "--------dsn on stop loading------");
-
-    }
-}
diff --git a/src/com/android/documentsui/DocumentsApplication.java b/src/com/android/documentsui/DocumentsApplication.java
index b77177b..34e2da3 100644
--- a/src/com/android/documentsui/DocumentsApplication.java
+++ b/src/com/android/documentsui/DocumentsApplication.java
@@ -49,8 +49,6 @@ public class DocumentsApplication extends Application {
     private DocumentClipper mClipper;
     private DragAndDropManager mDragAndDropManager;
     private Lookup<String, String> mFileTypeLookup;
-    private IPFS mIPFSHandle;
-    private String accountStr;
 
     public Injector<?> mInjector;
 
@@ -89,12 +87,6 @@ public class DocumentsApplication extends Application {
     public static Lookup<String, String> getFileTypeLookup(Context context) {
         return ((DocumentsApplication) context.getApplicationContext()).mFileTypeLookup;
     }
-    public static String getAccountStr(Context context) {
-        return ((DocumentsApplication) context.getApplicationContext()).accountStr;
-    }
-    public static IPFS getIPFSHandle(Context context) {
-        return ((DocumentsApplication) context.getApplicationContext()).mIPFSHandle;
-    }
 
     @Override
     public void onCreate() {
@@ -127,8 +119,6 @@ public class DocumentsApplication extends Application {
         final IntentFilter localeFilter = new IntentFilter();
         localeFilter.addAction(Intent.ACTION_LOCALE_CHANGED);
         registerReceiver(mCacheReceiver, localeFilter);
-        new Thread(new DSNDateInitRunnable()).start();
-
     }
 
     @Override
@@ -150,14 +140,4 @@ public class DocumentsApplication extends Application {
             }
         }
     };
-    class DSNDateInitRunnable implements Runnable {
-        @Override
-        public void run() {
-            mIPFSHandle = new IPFS("/ip4/127.0.0.1/tcp/5001");
-            final UserManager um = (UserManager)getSystemService(Context.USER_SERVICE);
-            int userId = UserHandle.myUserId();
-            accountStr = um.getUserBrahmaAccount(userId);
-
-        }
-    }
 }
diff --git a/src/com/android/documentsui/dirlist/DirectoryFragment.java b/src/com/android/documentsui/dirlist/DirectoryFragment.java
index 584559e..29e6510 100644
--- a/src/com/android/documentsui/dirlist/DirectoryFragment.java
+++ b/src/com/android/documentsui/dirlist/DirectoryFragment.java
@@ -112,6 +112,11 @@ import javax.annotation.Nullable;
 
 import com.android.documentsui.DSN.dirlist.DSNDirectoryFragment;
 
+import brahmaos.app.DSNManager;
+import android.app.AlertDialog;
+import static android.content.Context.DSNMANAGER_SERVICE;
+
+
 /**
  * Display the documents inside a single directory.
  */
@@ -407,12 +412,9 @@ public class DirectoryFragment extends Fragment implements SwipeRefreshLayout.On
                         : SortModel.SORT_DIMENSION_ID_TITLE);
 
         if(getArguments().getBoolean(Shared.FRAGMENT_MARK, true)){
-            Log.d("XULU_LOG","onActivityCreated:" + "true");
             return;
 
         }
-        Log.d("XULU_LOG","onActivityCreated:" + "false");
-
 
         // Kick off loader at least once
         mActions.loadDocumentsForCurrentStack();
@@ -649,6 +651,16 @@ public class DirectoryFragment extends Fragment implements SwipeRefreshLayout.On
             case R.id.action_menu_backup:
                 // deleteDocuments will end action mode if the documents are deleted.
                 // It won't end action mode if user cancels the delete.
+                DSNManager mManager = (DSNManager) getContext().getSystemService(DSNMANAGER_SERVICE);
+                int status = mManager.getDSNManagerStatus();
+                if (status == 0 || status == -1) {
+                    new  AlertDialog.Builder(mActivity)
+                        .setTitle("Alert" )
+                        .setMessage("Please open IPFS Switch in Settings" )
+                        .setPositiveButton("ok",  null )
+                        .show();
+                        return true;
+                }
                 mActions.backupDocuments();
                 return true;
 
diff --git a/src/com/android/documentsui/dirlist/ListeningGestureDetector.java b/src/com/android/documentsui/dirlist/ListeningGestureDetector.java
index 445ac4d..83307ab 100644
--- a/src/com/android/documentsui/dirlist/ListeningGestureDetector.java
+++ b/src/com/android/documentsui/dirlist/ListeningGestureDetector.java
@@ -95,7 +95,6 @@ final class ListeningGestureDetector extends GestureDetector implements OnItemTo
     @Override
     public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) {
         boolean handled = false;
-        Log.d("XULU_LOG",TAG+"/onInterceptTouchEvent/");
 
         // TODO: Re-wire event handling so that we're not dispatching
         //     events to to scaledetector's #onTouchEvent from this
@@ -129,14 +128,12 @@ final class ListeningGestureDetector extends GestureDetector implements OnItemTo
         // Forward all events to UserInputHandler.
         // This is necessary since UserInputHandler needs to always see the first DOWN event. Or
         // else all future UP events will be tossed.
-        Log.d("XULU_LOG",TAG+"/onInterceptTouchEvent/"+ String.valueOf(e.getAction() & MotionEvent.ACTION_MASK));
         handled |= onTouchEvent(e);
         return handled;
     }
 
     @Override
     public void onTouchEvent(RecyclerView rv, MotionEvent e) {
-            Log.d("XULU_LOG",TAG+"/onTouchEvent/");
         try (InputEvent event = MotionInputEvent.obtain(e, rv)) {
             if (Events.isMouseEvent(e)) {
                 mMouseDelegate.onTouchEvent(event);
diff --git a/src/com/android/documentsui/dirlist/UserInputHandler.java b/src/com/android/documentsui/dirlist/UserInputHandler.java
index c290ce4..d489a91 100644
--- a/src/com/android/documentsui/dirlist/UserInputHandler.java
+++ b/src/com/android/documentsui/dirlist/UserInputHandler.java
@@ -194,7 +194,6 @@ public final class UserInputHandler<T extends InputEvent>
         mSelectionMgr.toggleSelection(doc.getModelId());
         mSelectionMgr.setSelectionRangeBegin(doc.getAdapterPosition());
 
-        Log.d("XULU_LOG",TAG+"/selectDocument/"+mSelectionMgr.getSelection().size());
         // we set the focus on this doc so it will be the origin for keyboard events or shift+clicks
         // if there is only a single item selected, otherwise clear focus
         if (mSelectionMgr.getSelection().size() == 1) {
diff --git a/src/com/android/documentsui/files/DSNFilesActivity.java b/src/com/android/documentsui/files/DSNFilesActivity.java
index e111c8f..9e94689 100644
--- a/src/com/android/documentsui/files/DSNFilesActivity.java
+++ b/src/com/android/documentsui/files/DSNFilesActivity.java
@@ -44,8 +44,8 @@ import android.support.v7.app.ActionBar;
 import android.support.v7.app.AppCompatActivity;
 import android.widget.TextView;
 import android.text.format.Formatter;
-
-
+import android.widget.RelativeLayout;
+import android.widget.LinearLayout;
 
 import com.android.documentsui.AbstractActionHandler.CommonAddons;
 import com.android.documentsui.Injector.Injected;
@@ -73,7 +73,6 @@ import com.android.documentsui.Injector.ContentScoped;
 import com.android.documentsui.ui.MessageBuilder;
 import com.android.documentsui.services.FileOperationService.OpType;
 
-
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
@@ -94,19 +93,21 @@ import com.android.documentsui.base.Features;
 
 import android.annotation.IntDef;
 import javax.annotation.Nullable;
-import io.ipfs.api.IPFS;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import com.android.documentsui.services.DownloadDocumentsFromDSNJob;
 import com.android.documentsui.httpnetwork.ObjectMeta;
+import com.android.documentsui.DSN.DSNAddressQrcodeActivity;
+
+import brahmaos.app.DSNManager;
+import android.app.AlertDialog;
+
 
 public class DSNFilesActivity extends AppCompatActivity  {
 
     private static final String TAG = "DSNFilesActivity";
 
     protected State mState;
-
-
     protected DrawerController mDrawer;
 
     protected NavigationViewManager mNavigator;
@@ -140,6 +141,7 @@ public class DSNFilesActivity extends AppCompatActivity  {
 
     private PreferencesMonitor mPreferencesMonitor;
     private ObjectMeta mObjectMeta;
+    private LinearLayout layoutAccountAddressQRCode;
 
 
    // protected  void refreshDirectory(int anim);
@@ -162,30 +164,30 @@ public class DSNFilesActivity extends AppCompatActivity  {
 
         setContentView(R.layout.dsn_drawer_layout);
 
+        layoutAccountAddressQRCode =(LinearLayout)findViewById(R.id.layout_file_hashcode_qrcode);
+
         textViewHashKeyContent = (TextView)findViewById(R.id.tv_hashkey_content);
-        textViewHashKeyContent.setText(mObjectMeta.getobjectkey());
+        textViewHashKeyContent.setText(mObjectMeta.getObjectKey());
         textViewMimeTypeContent = (TextView)findViewById(R.id.tv_mimetype_content);
-        textViewMimeTypeContent.setText(mObjectMeta.getmimetype());
+        textViewMimeTypeContent.setText(mObjectMeta.getMimeType());
         textViewSizeContent = (TextView)findViewById(R.id.tv_size_content);
-        textViewSizeContent.setText(String.valueOf(mObjectMeta.getobjectsize()));
+        textViewSizeContent.setText(String.valueOf(mObjectMeta.getObjectSize()));
 
-        if (mObjectMeta.getobjectsize() > -1) {
+        if (mObjectMeta.getObjectSize() > -1) {
             textViewSizeContent.setVisibility(View.VISIBLE);
-            textViewSizeContent.setText(Formatter.formatFileSize(getApplicationContext(), mObjectMeta.getobjectsize()));
+            textViewSizeContent.setText(Formatter.formatFileSize(getApplicationContext(), mObjectMeta.getObjectSize()));
         } else {
             textViewSizeContent.setVisibility(View.INVISIBLE);
         }
 
         textViewNameContent = (TextView)findViewById(R.id.tv_name_content);
-        textViewNameContent.setText(mObjectMeta.getobjectname());
+        textViewNameContent.setText(mObjectMeta.getObjectName());
         textViewCreateTimeContent = (TextView)findViewById(R.id.tv_createtime_content);
-        textViewCreateTimeContent.setText(mObjectMeta.getobjectcreate_time());
+        textViewCreateTimeContent.setText(mObjectMeta.getObjectCreateTime());
         textViewSyncTimeContent = (TextView)findViewById(R.id.tv_synctime_content);
-        textViewSyncTimeContent.setText(mObjectMeta.getobjectsynctime());
+        textViewSyncTimeContent.setText(mObjectMeta.getObjectSyncTime());
         textViewBlockCOuntContent = (TextView)findViewById(R.id.tv_blockcount_content);
-        textViewBlockCOuntContent.setText(mObjectMeta.getobjectBlockCnt());
-
-
+        textViewBlockCOuntContent.setText(mObjectMeta.getObjectBlockCnt());
 
         //Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
         //setActionBar(toolbar);
@@ -224,11 +226,21 @@ public class DSNFilesActivity extends AppCompatActivity  {
     }
 
     @Override
+    protected void onStart() {
+        super.onStart();
+        layoutAccountAddressQRCode.setOnClickListener(v -> {
+            Intent intent = new Intent(DSNFilesActivity.this, DSNAddressQrcodeActivity.class);
+            intent.putExtra("DSNObjectMeta", mObjectMeta);
+            startActivity(intent);
+        });
+
+    }
+
+    @Override
     protected void onPostCreate(Bundle savedInstanceState) {
         super.onPostCreate(savedInstanceState);
     }
 
-
     @Override
     protected void onDestroy() {
        // mRootsMonitor.stop();
@@ -278,6 +290,7 @@ public class DSNFilesActivity extends AppCompatActivity  {
         if (toolbar != null) {
             setSupportActionBar(toolbar);
             ActionBar ab = getSupportActionBar();
+            ab.setTitle("Remote File");
             if (ab != null) {
                 ab.setDisplayHomeAsUpEnabled(true);
                 ab.setDisplayShowHomeEnabled(true);
@@ -297,6 +310,10 @@ public class DSNFilesActivity extends AppCompatActivity  {
        option_menu_download = menu.findItem(R.id.option_menu_download);
        option_menu_download.setVisible(true);
        option_menu_download.setEnabled(true);
+       MenuItem  option_menu_preview ;
+       option_menu_preview = menu.findItem(R.id.option_menu_preview);
+       option_menu_preview.setVisible(true);
+       option_menu_preview.setEnabled(true);
 
        Menus.disableHiddenItems(menu);
 
@@ -308,17 +325,13 @@ public class DSNFilesActivity extends AppCompatActivity  {
         DirectoryFragment dir;
         switch (item.getItemId()) {
             case R.id.option_menu_delete:
-                //Log.d("XULU_LOG","onOptionsItemSelected detele");
-                //Intent intent = new Intent(this,DSNFilesActivity.class);
-                //intent.putExtra("DSNObjectMeta", mObjectMeta);
-                //this.startActivity(intent);
                 break;
             case R.id.option_menu_download:
-                Log.d("XULU_LOG","onOptionsItemSelected download");
                 downloadDocumentsFromDSN();
                 break;
             case android.R.id.home:
                 finish();
+                break;
             default:
                 return super.onOptionsItemSelected(item);
         }
@@ -326,6 +339,16 @@ public class DSNFilesActivity extends AppCompatActivity  {
     }
     public void downloadDocumentsFromDSN() {
         List<DocumentInfo> docs = null;
+        DSNManager mManager = (DSNManager) getApplicationContext().getSystemService(DSNMANAGER_SERVICE);
+        int status = mManager.getDSNManagerStatus();
+        if (status == 0 || status == -1) {
+            new  AlertDialog.Builder(this)
+                .setTitle("Alert" )
+                .setMessage("Please open IPFS Switch in Settings" )
+                .setPositiveButton("ok",  null )
+                .show();
+            return;
+        }
         ConfirmationCallback result = (@Result int code) -> {
             // share the news with our caller, be it good or bad.
 
diff --git a/src/com/android/documentsui/httpnetwork/HttpServer.java b/src/com/android/documentsui/httpnetwork/HttpServer.java
index 958b4cc..9d0adf3 100644
--- a/src/com/android/documentsui/httpnetwork/HttpServer.java
+++ b/src/com/android/documentsui/httpnetwork/HttpServer.java
@@ -71,10 +71,6 @@ public class HttpServer extends BaseService{
                                 try {
                                     List<ObjectMeta> objectlist = objectMapper.readValue(objectMapper.writeValueAsString(apr.getData().get(ApiConst.PARAM_QUOTES)), new TypeReference<List<ObjectMeta>>() {});
                                     ObjectMeta tmpobj = objectlist.get(0);
-                                    //for(ObjectMeta getObjectMeta: objectlist)
-                                     //  DSNDirectoryFragment.getModel.add(getObjectMeta);
-                                      //Log.d("XULU_LOG","getHttpIpfsdata:" + xx.get_account_id());
-                                      //Log.d("XULU_LOG","getHttpIpfsdata:" + xx.get_object_name());
                                 } catch (IOException e1) {
                                     e1.printStackTrace();
                                 }
@@ -102,7 +98,7 @@ public class HttpServer extends BaseService{
                     }
                     @Override
                     public void onNext(LinkedHashMap<String, Object> apr) {
-			            Log.d(TAG,"postHttpIpfsdata:"+ apr.toString());
+                        Log.d(TAG,"postHttpIpfsdata:"+ apr.toString());
                     }
                 });
     }
diff --git a/src/com/android/documentsui/httpnetwork/Networks.java b/src/com/android/documentsui/httpnetwork/Networks.java
index eadb3ef..f9c6d8e 100644
--- a/src/com/android/documentsui/httpnetwork/Networks.java
+++ b/src/com/android/documentsui/httpnetwork/Networks.java
@@ -19,6 +19,7 @@ import retrofit2.Retrofit;
 import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;
 import retrofit2.converter.jackson.JacksonConverterFactory;
 import android.util.Log;
+import android.net.TrafficStats;
 
 /**
  * new api access
@@ -65,7 +66,6 @@ public class Networks {
                 .addConverterFactory(JacksonConverterFactory.create(mapper))
                 .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                 .build();
-
         return retrofit.create(service);
     }
 
@@ -100,13 +100,11 @@ public class Networks {
             }
         };
         okHttpClient.addNetworkInterceptor(responseInterceptor);
-        Log.d("XULU_LOG","configClient");
         if (BuildConfig.LOG_DEBUG) {
             HttpLoggingInterceptor httpLoggingInterceptor = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() {
                 @Override
                 public void log(@NonNull String message) {
                    // BLog.i(tag(), message);
-                   Log.d("XULU_LOG","HttpLogging " + message);
                 }
             });
             httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
diff --git a/src/com/android/documentsui/httpnetwork/ObjectMeta.java b/src/com/android/documentsui/httpnetwork/ObjectMeta.java
index 64d8367..39bf74d 100644
--- a/src/com/android/documentsui/httpnetwork/ObjectMeta.java
+++ b/src/com/android/documentsui/httpnetwork/ObjectMeta.java
@@ -28,67 +28,67 @@ public class ObjectMeta implements Serializable {
     @JsonProperty("object_block_cnt")
     private String objectBlockCnt;
 
-    //	account_id
-    public String getaccountid() {
+    // account_id
+    public String getAccountId() {
         return accountId;
     }
-    public void setaccountid(String accountId) {
+    public void setAccountId(String accountId) {
         this.accountId = accountId;
     }
-    //	object_key
-    public String getobjectkey() {
+    // object_key
+    public String getObjectKey() {
         return objectKey;
     }
 
-    public void setobjectkey(String objectKey) {
+    public void setObjectKey(String objectKey) {
         this.objectKey = objectKey;
     }
     //	mime_type
-    public String getmimetype() {
+    public String getMimeType() {
         return mimeType;
     }
 
-    public void setmimetype(String mimeType) {
+    public void setMimeType(String mimeType) {
         this.mimeType = mimeType;
     }
     // object_name
-    public String getobjectname() {
+    public String getObjectName() {
         return objectName;
     }
 
-    public void setobjectname(String objectName) {
+    public void setObjectName(String objectName) {
         this.objectName = objectName;
     }
-    //	object_size
-    public int getobjectsize() {
+    // object_size
+    public int getObjectSize() {
         return objectSize;
     }
 
-    public void setobjectsize(int objectSize) {
+    public void setObjectSize(int objectSize) {
         this.objectSize = objectSize;
     }
     // object_create_time
-    public String getobjectcreate_time() {
+    public String getObjectCreateTime() {
         return objectCreateTime;
     }
 
-    public void setobjectcreatetime(String objectCreateTime) {
+    public void setObjectCreateTime(String objectCreateTime) {
         this.objectCreateTime = objectCreateTime;
     }
     // object_sync_time
-    public String getobjectsynctime() {
+    public String getObjectSyncTime() {
         return objectSyncTime;
     }
 
-    public void setobjectsynctime(String objectSyncTime) {
+    public void setObjectSyncTime(String objectSyncTime) {
         this.objectSyncTime = objectSyncTime;
     }
     // object_block_cnt
-    public String getobjectBlockCnt() {
+    public String getObjectBlockCnt() {
         return objectBlockCnt;
     }
 
-    public void setobjectBlockCnt(String objectBlockCnt) {
+    public void setObjectBlockCnt(String objectBlockCnt) {
         this.objectBlockCnt = objectBlockCnt;
     }
     public String toString() {
@@ -102,5 +102,14 @@ public class ObjectMeta implements Serializable {
                 ", object_sync_time=" + objectSyncTime +
                 '}';
     }
+    public String toJsonString() {
+        return '{' +
+               // "\"account_id\":" + '\"' + accountId + '\"' +
+                "\"object_key\":" + '\"' + objectKey + '\"' +
+                ",\"mime_type\":" + '\"' + mimeType + '\"' +
+                ",\"object_name\":" +'\"' + objectName + '\"' +
+                ",\"object_size\":" + objectSize +
+                '}';
+    }
 }
 
diff --git a/src/com/android/documentsui/services/BackupJob.java b/src/com/android/documentsui/services/BackupJob.java
index c038461..bb1e64a 100644
--- a/src/com/android/documentsui/services/BackupJob.java
+++ b/src/com/android/documentsui/services/BackupJob.java
@@ -74,6 +74,9 @@ import java.util.Map;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 
+import brahmaos.app.DSNManager;
+import brahmaos.app.AddFileCallbackListener;
+import static android.content.Context.DSNMANAGER_SERVICE;
 
 
 final class BackupJob extends ResolvedResourcesJob {
@@ -84,11 +87,9 @@ final class BackupJob extends ResolvedResourcesJob {
     private static final String PRIMARY_PREFIX = "primary:";
     private static final String RAW_PREFIX = "raw:";
     private static final String RAW_STORAGE_PREFIX = "raw:/storage/emulated/0/";
-    private String ACOUNT_ID ;
     private final Uri mParentUri;
-
     private volatile int mDocsProcessed = 0;
-    private static IPFS mhandleIPFS;
+
     /**
      * Moves files to a destination identified by {@code destination}.
      * Performs most work by delegating to CopyJob, then deleting
@@ -142,12 +143,6 @@ final class BackupJob extends ResolvedResourcesJob {
     @Override
     void start() {
         ContentResolver resolver = appContext.getContentResolver();
-        mhandleIPFS = DocumentsApplication.getIPFSHandle(appContext);
-        ACOUNT_ID = DocumentsApplication.getAccountStr(appContext);
-        if((mhandleIPFS==null)|(ACOUNT_ID==null)){
-            Log.e(TAG, "mhandleIPFS or ACOUNT_ID is null");
-            return;
-        }
         DocumentInfo parentDoc;
         try {
             parentDoc = mParentUri != null
@@ -178,7 +173,7 @@ final class BackupJob extends ResolvedResourcesJob {
     }
     final void backupDocument(DocumentInfo doc, @Nullable DocumentInfo parent)
              throws ResourceException {
-         try {
+        // try {
             NamedStreamable.FileWrapper file;
 
            // Path path = DocumentsContract.findDocumentPath(getClient(doc), doc.derivedUri);
@@ -199,57 +194,43 @@ final class BackupJob extends ResolvedResourcesJob {
             String fileType;
             int blockCnt;
 
+            DSNManager mManager = (DSNManager) appContext.getSystemService(DSNMANAGER_SERVICE);
+
             List<String> filenames = getFileListame(mPath);
             if(filenames!= null){
                 for(String filename : filenames){
-                    File backupfile = new File(filename);
-                    Date nowDate = new Date();
-                    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
-                    createFileTime = dateFormat.format(nowDate);
-                    lastModifiedFileTime = dateFormat.format(new Date(backupfile.lastModified()));
-                    fileType = getFileType(filename);
-
-                    file = new NamedStreamable.FileWrapper(backupfile);
-                    List<MerkleNode> addResult = mhandleIPFS.add(file);
-                    blockCnt = getBlockCount(addResult.get(0));
-                    postHttpDSNData(addResult.get(0), lastModifiedFileTime, createFileTime, fileType,blockCnt);
+                    mManager.addFile(filename, null, new AddFileCallbackListener(){
+                        @Override
+                        public void onUploadProcess(long filesize, long uploadsize){
+                            //Log.d(TAG, "DSNManager addFile:" + filesize + '/' + uploadsize);
+                        }
+                        @Override
+                        public void onCompleted(String status){
+                            Log.d(TAG, "DSNManager onCompleted:" + status);
+                        }
+                        @Override
+                        public void onError(String status){
+                            Log.d(TAG, "DSNManager OnError:" + status);
+                        }
+                        @Override
+                        public void onNext(String status){
+                            Log.d(TAG, "DSNManager onNext:" + status);
+                        }
+                        @Override
+                        public void onCallbackComplete(boolean result, Map resultMap){
+                            Log.d(TAG, "DSNManager onCallbackComplete:" + resultMap.get("account_id"));
+                            Log.d(TAG, "DSNManager onCallbackComplete:" + resultMap.get("object_key"));
+                            Log.d(TAG, "DSNManager onCallbackComplete:" + String.valueOf(resultMap.get("object_block_cnt")));
+                        }
+                    });
                 }
             } else
                 return;
 
-        } catch (IOException e) {
-            throw new ResourceException("Failed to backup file %s due to an exception.",doc.derivedUri, e);
-        }
-
-    }
-
-    public int getBlockCount(MerkleNode node)throws ResourceException {
-        try{
-            List<MerkleNode> lsResult = mhandleIPFS.ls(node.hash);
-            return lsResult.get(0).links.size();
-        }  catch (IOException e) {
-             Log.e(TAG,"Failed to get BlockCount."+ e);
-        }
-        return 0;
-    }
 
-    public void postHttpDSNData(MerkleNode node,String modifyTime,String createTime,String fileType,int blockCnt){
-        Map<String,Object> body = new HashMap<String, Object>();
-        body.put("account_id",ACOUNT_ID);
-        body.put("object_key",node.hash.toString());
-        body.put("mime_type",fileType);
-        body.put("object_name",node.name.get());
-        if(node.size.isPresent())
-            body.put("object_size",node.size.get());
-        else
-            body.put("object_size",node.largeSize.get());
-        body.put("object_create_time",modifyTime);
-        body.put("object_sync_time",createTime);
-        body.put("object_block_cnt",blockCnt);
-        HttpServer.getInstance().postHttpIpfsdata(body);
     }
 
-	public List<String> getFileListame(String strPath) {
+    public List<String> getFileListame(String strPath) {
         List<String> returnList = new ArrayList();
         File dir = new File(strPath);
         if(!dir.isDirectory()){
@@ -266,16 +247,7 @@ final class BackupJob extends ResolvedResourcesJob {
 
         }
         return returnList;
-	}
-    public String getFileType(String filename){
-        int idx = filename.lastIndexOf(".");
-        if (idx <= 0 || (idx+1) == filename.length()) {
-            return null;
-        }
-        String extensionName = filename.substring(idx+1);
-        return MimeTypeMap.getSingleton().getMimeTypeFromExtension(extensionName);
     }
-
     /**
      * Get the last element
      */
diff --git a/src/com/android/documentsui/services/DownloadDocumentsFromDSNJob.java b/src/com/android/documentsui/services/DownloadDocumentsFromDSNJob.java
index 39e760a..bf56403 100644
--- a/src/com/android/documentsui/services/DownloadDocumentsFromDSNJob.java
+++ b/src/com/android/documentsui/services/DownloadDocumentsFromDSNJob.java
@@ -29,7 +29,6 @@ import android.os.StatFs;
 import android.os.Environment;
 import android.content.Context;
 
-
 import com.android.documentsui.Metrics;
 import com.android.documentsui.R;
 import com.android.documentsui.base.DocumentInfo;
@@ -37,7 +36,6 @@ import com.android.documentsui.base.DocumentStack;
 import com.android.documentsui.base.Features;
 import com.android.documentsui.clipping.UrisSupplier;
 import com.android.documentsui.DocumentsApplication;
-
 import com.android.documentsui.httpnetwork.ObjectMeta;
 
 import javax.annotation.Nullable;
@@ -63,14 +61,15 @@ import io.ipfs.api.IPFS;
 import io.ipfs.cid.Cid;
 import io.ipfs.api.JSONParser;
 
+import static android.content.Context.DSNMANAGER_SERVICE;
+import brahmaos.app.DSNManager;
+import brahmaos.app.GetFileCallbackListener;
 
 public class DownloadDocumentsFromDSNJob implements Runnable {
-
+    private static final String TAG = "DownloadDocumentsFromDSNJob";
     private String PATH_PREFIX = "/sdcard/LocalHD";
     private ObjectMeta mObjectMeta;
 
-    private static final String TAG = "DownloadDocumentsFromDSNJob";
-
     private Context mappContext;
     private IPFS mhandleIPFS;
 
@@ -79,61 +78,50 @@ public class DownloadDocumentsFromDSNJob implements Runnable {
         mappContext = appContext;
 
     }
-
-
     @Override
     public void run(){
-        mhandleIPFS = DocumentsApplication.getIPFSHandle(mappContext);
-        String mObjectName = mObjectMeta.getobjectname();
-        String mMimeType = mObjectMeta.getmimetype();
-        String mHashKey = mObjectMeta.getobjectkey();
-
-        StringBuffer fileNameBuffer = new StringBuffer();
-        fileNameBuffer.append(PATH_PREFIX);
-        fileNameBuffer.append("/");
-        fileNameBuffer.append(mObjectName);
-        String fileNameBufferString = fileNameBuffer.toString();
-
-        File filePath = new File(PATH_PREFIX);
-        createDirToStoreage(filePath);
-
-        try{
-            int len;
-            byte[] buffer = new byte[1024];
-            InputStream in = mhandleIPFS.catStream(Multihash.fromBase58(mHashKey));
-
-            try{
-                    FileOutputStream fileOutput = new FileOutputStream(fileNameBufferString);
-                    while ((len = in.read(buffer)) >= 0)
-                        fileOutput.write(buffer, 0, len);
-                    } catch (IOException e) {
-                    e.printStackTrace();
-                }
-
-           } catch (IOException e) {
-                e.printStackTrace();
-           }
+        String mObjectName = mObjectMeta.getObjectName();
+        String mMimeType = mObjectMeta.getMimeType();
+        String mHashKey = mObjectMeta.getObjectKey();
+        DSNManager mManager = (DSNManager) mappContext.getSystemService(DSNMANAGER_SERVICE);
+        mManager.getFile(mHashKey, null, new GetFileCallbackListener(){
+
+            @Override
+            public void onGetFileProcess(long filesize, long uploadsize){
+                //Log.d(TAG, "DocumentsUI onGetFileProcess:" + filesize + '/' + uploadsize);
+            }
+
+            @Override
+            public void onCallbackComplete(boolean status){
+                if(status == true) {
+                    if (!mHashKey.equals(mObjectName)) {
+                        File oldFile = new File(PATH_PREFIX + "/" + mHashKey);
+                        File newFile = new File(PATH_PREFIX + "/" + mObjectName);
+                        if(!oldFile.exists()){
+                            return;
+                        }
+                        if (newFile.exists())
+                            Log.d(TAG, "rename cannot sucess file has exist!");
+                        else {
+                            oldFile.renameTo(newFile);
+                            oldFile.delete();
+                        }
+                    } else
+                        Log.d(TAG, "newName is same to oldName!");
+                } else
+                    Log.d(TAG, "getFile onCallbackComplete return failure!");
+            }
+        });
     }
-    public void createDirToStoreage (File path) {
-         if (path.exists()) {
-             Log.d(TAG,"createDirToStoraage path is exist");;
-         } else {
-             try {
-                 path.createNewFile();
-             } catch (IOException e) {
-                 e.printStackTrace();
-             }
-         }
-
-     }
+
     private long getSDAvailableSize() {
         File path = Environment.getExternalStorageDirectory();
         StatFs stat = new StatFs(path.getPath());
         long blockSize = stat.getBlockSize();
         long availableBlocks = stat.getAvailableBlocks();
-        //return Formatter.formatFileSize(MainActivity.this, blockSize * availableBlocks);
         return availableBlocks;
     }
 
+
 }
 
diff --git a/src/com/android/documentsui/sidebar/RootsFragment.java b/src/com/android/documentsui/sidebar/RootsFragment.java
index 367e033..d7de6b3 100644
--- a/src/com/android/documentsui/sidebar/RootsFragment.java
+++ b/src/com/android/documentsui/sidebar/RootsFragment.java
@@ -272,7 +272,7 @@ public class RootsFragment extends Fragment {
                 libraries.add(item);
             } else if(root.authority.equals("com.android.providers.decenterlocaldisk.documents")||
                 root.authority.equals("com.android.providers.decentercloud.documents")){
-				decenters.add(item);
+                decenters.add(item);
             }else {
                 others.add(item);
             }
-- 
2.7.4

