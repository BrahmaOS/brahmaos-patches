From 7bec046999278081df448330e9a84fffa6680022 Mon Sep 17 00:00:00 2001
From: martin <martin@163.com>
Date: Mon, 26 Nov 2018 10:40:46 +0800
Subject: [PATCH] Fix permission camera

Change-Id: I12d0ab95fc46a334553bc25cd85f4d0d6b011a03
---
 res/layout/activity_capture.xml                    | 142 +--
 .../RequestImportVCardPermissionsActivity.java     |   2 +
 .../activities/RequestPermissionsActivity.java     |   1 +
 .../contacts/activities/base/BaseActivity.java     | 290 +++---
 src/com/android/contacts/util/PermissionUtil.java  | 276 +++---
 .../contacts/util/barcode/AmbientLightManager.java | 164 ++--
 .../android/contacts/util/barcode/BeepManager.java | 254 +++---
 .../contacts/util/barcode/CaptureActivity.java     | 854 +++++++++---------
 .../util/barcode/CaptureActivityHandler.java       | 344 +++----
 .../android/contacts/util/barcode/Contents.java    | 236 ++---
 .../contacts/util/barcode/DecodeFormatManager.java | 212 ++---
 .../contacts/util/barcode/DecodeHandler.java       | 258 +++---
 .../contacts/util/barcode/DecodeHintManager.java   | 472 +++++-----
 .../contacts/util/barcode/DecodeThread.java        | 226 ++---
 .../contacts/util/barcode/FinishListener.java      |  98 +-
 src/com/android/contacts/util/barcode/Intents.java | 462 +++++-----
 .../contacts/util/barcode/LocaleManager.java       | 370 ++++----
 .../barcode/ViewfinderResultPointCallback.java     |  70 +-
 .../contacts/util/barcode/ViewfinderView.java      | 382 ++++----
 .../util/barcode/camera/AutoFocusManager.java      | 260 +++---
 .../barcode/camera/CameraConfigurationManager.java | 446 ++++-----
 .../barcode/camera/CameraConfigurationUtils.java   | 910 +++++++++----------
 .../util/barcode/camera/CameraManager.java         | 700 +++++++--------
 .../util/barcode/camera/PreviewCallback.java       | 112 +--
 .../util/barcode/camera/open/CameraFacing.java     |  50 +-
 .../util/barcode/camera/open/OpenCamera.java       | 110 +--
 .../barcode/camera/open/OpenCameraInterface.java   | 196 ++--
 .../barcode/result/AddressBookResultHandler.java   | 438 ++++-----
 .../util/barcode/result/CalendarResultHandler.java | 376 ++++----
 .../barcode/result/EmailAddressResultHandler.java  | 144 +--
 .../util/barcode/result/GeoResultHandler.java      | 138 +--
 .../util/barcode/result/ISBNResultHandler.java     | 148 +--
 .../util/barcode/result/ProductResultHandler.java  | 170 ++--
 .../util/barcode/result/ResultHandler.java         | 994 ++++++++++-----------
 .../util/barcode/result/ResultHandlerFactory.java  | 126 +--
 .../util/barcode/result/SMSResultHandler.java      | 172 ++--
 .../util/barcode/result/TelResultHandler.java      | 168 ++--
 .../util/barcode/result/TextResultHandler.java     | 156 ++--
 .../util/barcode/result/URIResultHandler.java      | 208 ++---
 39 files changed, 5569 insertions(+), 5566 deletions(-)

diff --git a/res/layout/activity_capture.xml b/res/layout/activity_capture.xml
index 7433e5e..7a533c2 100644
--- a/res/layout/activity_capture.xml
+++ b/res/layout/activity_capture.xml
@@ -1,71 +1,71 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/tools"
-    android:id="@+id/capture_container"
-    android:orientation="vertical"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent">
-
-    <LinearLayout
-        android:id="@+id/toolbar_parent"
-        android:orientation="vertical"
-        android:layout_width="match_parent"
-        android:elevation="@dimen/tab_elevation"
-        android:layout_height="wrap_content" >
-        <FrameLayout
-            android:id="@+id/toolbar_frame"
-            android:layout_width="match_parent"
-            android:layout_height="?attr/actionBarSize"
-            android:background="?attr/colorPrimary">
-            <!-- the attribute padding removes the gap between this Toolbar and its parent FrameLayout on tablet -->
-            <android.support.v7.widget.Toolbar
-                android:layout_width="match_parent"
-                android:layout_height="?attr/actionBarSize"
-                android:id="@+id/toolbar"
-                android:padding="0dp"
-                style="@style/ContactsToolbarStyle" />
-        </FrameLayout>
-    </LinearLayout>
-
-    <FrameLayout
-        android:layout_width="match_parent"
-        android:layout_height="match_parent">
-        <SurfaceView android:id="@+id/preview_view"
-            android:layout_width="match_parent"
-            android:layout_height="match_parent"/>
-        <com.android.contacts.util.barcode.ViewfinderView
-            android:id="@+id/viewfinder_view"
-            android:layout_width="match_parent"
-            android:layout_height="match_parent"/>
-        <Button
-            android:id="@+id/set_torch_btn"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:textSize="@dimen/font_size_body"
-            android:textColor="@android:color/white"
-            android:padding="@dimen/space_small"
-            android:visibility="gone"/>
-        <TextView android:id="@+id/status_view"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="bottom|center_horizontal"
-            android:background="@android:color/transparent"
-            android:textColor="@android:color/white"/>
-    </FrameLayout>
-
-</LinearLayout>
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/tools"
+    android:id="@+id/capture_container"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:id="@+id/toolbar_parent"
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:elevation="@dimen/tab_elevation"
+        android:layout_height="wrap_content" >
+        <FrameLayout
+            android:id="@+id/toolbar_frame"
+            android:layout_width="match_parent"
+            android:layout_height="?attr/actionBarSize"
+            android:background="?attr/colorPrimary">
+            <!-- the attribute padding removes the gap between this Toolbar and its parent FrameLayout on tablet -->
+            <android.support.v7.widget.Toolbar
+                android:layout_width="match_parent"
+                android:layout_height="?attr/actionBarSize"
+                android:id="@+id/toolbar"
+                android:padding="0dp"
+                style="@style/ContactsToolbarStyle" />
+        </FrameLayout>
+    </LinearLayout>
+
+    <FrameLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+        <SurfaceView android:id="@+id/preview_view"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"/>
+        <com.android.contacts.util.barcode.ViewfinderView
+            android:id="@+id/viewfinder_view"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"/>
+        <Button
+            android:id="@+id/set_torch_btn"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textSize="@dimen/font_size_body"
+            android:textColor="@android:color/white"
+            android:padding="@dimen/space_small"
+            android:visibility="gone"/>
+        <TextView android:id="@+id/status_view"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="bottom|center_horizontal"
+            android:background="@android:color/transparent"
+            android:textColor="@android:color/white"/>
+    </FrameLayout>
+
+</LinearLayout>
diff --git a/src/com/android/contacts/activities/RequestImportVCardPermissionsActivity.java b/src/com/android/contacts/activities/RequestImportVCardPermissionsActivity.java
index 224339a..cab33b1 100644
--- a/src/com/android/contacts/activities/RequestImportVCardPermissionsActivity.java
+++ b/src/com/android/contacts/activities/RequestImportVCardPermissionsActivity.java
@@ -31,6 +31,8 @@ public class RequestImportVCardPermissionsActivity extends RequestPermissionsAct
             permission.WRITE_CONTACTS,
             // Storage group
             permission.READ_EXTERNAL_STORAGE,
+            // Camera group
+            permission.CAMERA,
     };
 
     @Override
diff --git a/src/com/android/contacts/activities/RequestPermissionsActivity.java b/src/com/android/contacts/activities/RequestPermissionsActivity.java
index bcfa128..12d5572 100644
--- a/src/com/android/contacts/activities/RequestPermissionsActivity.java
+++ b/src/com/android/contacts/activities/RequestPermissionsActivity.java
@@ -63,6 +63,7 @@ public class RequestPermissionsActivity extends RequestPermissionsActivityBase {
             permissions.add(permission.GET_ACCOUNTS);
             permissions.add(permission.READ_CONTACTS);
             permissions.add(permission.WRITE_CONTACTS);
+            permissions.add(permission.CAMERA);
 
             if (packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
                 // Phone group
diff --git a/src/com/android/contacts/activities/base/BaseActivity.java b/src/com/android/contacts/activities/base/BaseActivity.java
index 3936c47..c181adb 100644
--- a/src/com/android/contacts/activities/base/BaseActivity.java
+++ b/src/com/android/contacts/activities/base/BaseActivity.java
@@ -1,145 +1,145 @@
-/*
- * Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.activities.base;
-
-import android.Manifest;
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.content.res.Configuration;
-import android.os.Build;
-import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.v4.app.ActivityCompat;
-import android.support.v7.app.ActionBar;
-import android.support.v7.app.AppCompatActivity;
-import android.support.v7.widget.Toolbar;
-import android.view.MenuItem;
-import android.widget.Toast;
-
-import com.android.contacts.R;
-import com.android.contacts.util.PermissionUtil;
-
-
-public abstract class BaseActivity extends AppCompatActivity {
-
-    protected abstract String tag();
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-    }
-
-    @Override
-    protected void onPostCreate(@Nullable Bundle savedInstanceState) {
-        super.onPostCreate(savedInstanceState);
-        
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-    }
-
-    protected void showShortToast(String message) {
-        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
-    }
-
-    protected void showShortToast(int res) {
-        showShortToast(getString(res));
-    }
-
-    protected void showLongToast(String message) {
-        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
-    }
-
-    protected void showLongToast(int res) {
-        showLongToast(getString(res));
-    }
-
-    // Request camera permission
-    public void requestCameraScanPermission() {
-        PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
-    }
-
-    // Request write external storage
-    public void requestExternalStorage() {
-        PermissionUtil.requestMultiPermissions(this, PermissionUtil.EXTERNAL_STORAGE_PERMISSIONS, PermissionUtil.CODE_EXTERNAL_STORAGE);
-    }
-
-    public void handleCameraScanPermission() {}
-
-    public void handleExternalStoragePermission() {}
-
-    /**
-     * Callback received when a permissions request has been completed.
-     */
-    @Override
-    public void onRequestPermissionsResult(final int requestCode, @NonNull String[] permissions,
-                                           @NonNull int[] grantResults) {
-        if (requestCode == PermissionUtil.CODE_CAMERA_SCAN) {
-            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
-                    == PackageManager.PERMISSION_GRANTED) {
-                handleCameraScanPermission();
-            } else {
-                PermissionUtil.openSettingActivity(this, getString(R.string.tip_camera_permission));
-            }
-        } else if (requestCode == PermissionUtil.CODE_EXTERNAL_STORAGE) {
-            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)
-                    == PackageManager.PERMISSION_GRANTED) {
-                handleExternalStoragePermission();
-            } else {
-                PermissionUtil.openSettingActivity(this, getString(R.string.tip_external_storage_permission));
-            }
-        }
-    }
-
-    // show navigation backup action icon
-    protected void showNavBackBtn() {
-        Toolbar toolbar = findViewById(R.id.toolbar);
-        if (toolbar != null) {
-
-            setSupportActionBar(toolbar);
-            ActionBar ab = getSupportActionBar();
-            if (ab != null) {
-                ab.setDisplayHomeAsUpEnabled(true);
-                ab.setDisplayShowHomeEnabled(true);
-            }
-        }
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        int id = item.getItemId();
-        if (id == android.R.id.home) {
-            finish();
-            return true;
-        }
-
-        return super.onOptionsItemSelected(item);
-    }
-
-    /**
-     * set toolbar title
-     */
-    protected void setToolbarTitle(String title) {
-        Toolbar toolbar = findViewById(R.id.toolbar);
-        if (toolbar != null) {
-            toolbar.setTitle(title);
-        }
-    }
-}
+/*
+ * Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.activities.base;
+
+import android.Manifest;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.app.ActivityCompat;
+import android.support.v7.app.ActionBar;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import com.android.contacts.R;
+import com.android.contacts.util.PermissionUtil;
+
+
+public abstract class BaseActivity extends AppCompatActivity {
+
+    protected abstract String tag();
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+    }
+
+    @Override
+    protected void onPostCreate(@Nullable Bundle savedInstanceState) {
+        super.onPostCreate(savedInstanceState);
+        
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+    }
+
+    protected void showShortToast(String message) {
+        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
+    }
+
+    protected void showShortToast(int res) {
+        showShortToast(getString(res));
+    }
+
+    protected void showLongToast(String message) {
+        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
+    }
+
+    protected void showLongToast(int res) {
+        showLongToast(getString(res));
+    }
+
+    // Request camera permission
+    public void requestCameraScanPermission() {
+        PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
+    }
+
+    // Request write external storage
+    public void requestExternalStorage() {
+        PermissionUtil.requestMultiPermissions(this, PermissionUtil.EXTERNAL_STORAGE_PERMISSIONS, PermissionUtil.CODE_EXTERNAL_STORAGE);
+    }
+
+    public void handleCameraScanPermission() {}
+
+    public void handleExternalStoragePermission() {}
+
+    /**
+     * Callback received when a permissions request has been completed.
+     */
+    @Override
+    public void onRequestPermissionsResult(final int requestCode, @NonNull String[] permissions,
+                                           @NonNull int[] grantResults) {
+        if (requestCode == PermissionUtil.CODE_CAMERA_SCAN) {
+            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
+                    == PackageManager.PERMISSION_GRANTED) {
+                handleCameraScanPermission();
+            } else {
+                PermissionUtil.openSettingActivity(this, getString(R.string.tip_camera_permission));
+            }
+        } else if (requestCode == PermissionUtil.CODE_EXTERNAL_STORAGE) {
+            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)
+                    == PackageManager.PERMISSION_GRANTED) {
+                handleExternalStoragePermission();
+            } else {
+                PermissionUtil.openSettingActivity(this, getString(R.string.tip_external_storage_permission));
+            }
+        }
+    }
+
+    // show navigation backup action icon
+    protected void showNavBackBtn() {
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        if (toolbar != null) {
+
+            setSupportActionBar(toolbar);
+            ActionBar ab = getSupportActionBar();
+            if (ab != null) {
+                ab.setDisplayHomeAsUpEnabled(true);
+                ab.setDisplayShowHomeEnabled(true);
+            }
+        }
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        int id = item.getItemId();
+        if (id == android.R.id.home) {
+            finish();
+            return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+
+    /**
+     * set toolbar title
+     */
+    protected void setToolbarTitle(String title) {
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        if (toolbar != null) {
+            toolbar.setTitle(title);
+        }
+    }
+}
diff --git a/src/com/android/contacts/util/PermissionUtil.java b/src/com/android/contacts/util/PermissionUtil.java
index 3bd6f9b..afef432 100644
--- a/src/com/android/contacts/util/PermissionUtil.java
+++ b/src/com/android/contacts/util/PermissionUtil.java
@@ -1,138 +1,138 @@
-/*
- * Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util;
-
-import android.Manifest;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.net.Uri;
-import android.provider.Settings;
-import android.support.v4.app.ActivityCompat;
-import android.support.v7.app.AlertDialog;
-import android.util.Log;
-import android.widget.Toast;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import com.android.contacts.R;
-
-/**
- * Utility class that wraps access to the runtime permissions API in M and provides basic helper
- * methods.
- */
-public class PermissionUtil {
-
-    private static final String TAG = PermissionUtil.class.getSimpleName();
-    public static final int CODE_CAMERA_SCAN = 10000;
-    public static final int CODE_EXTERNAL_STORAGE = 10001;
-
-    public static final String PERMISSION_CAMERA = Manifest.permission.CAMERA;
-    public static final String PERMISSION_WRITE_EXTERNAL_STORAGE = Manifest.permission.WRITE_EXTERNAL_STORAGE;
-
-    public static final String[] CAMERA_PERMISSIONS = {
-            PERMISSION_CAMERA
-    };
-
-    public static final String[] EXTERNAL_STORAGE_PERMISSIONS = {
-            PERMISSION_WRITE_EXTERNAL_STORAGE
-    };
-
-    /**
-     * Check that all given permissions have been granted by verifying that each entry in the
-     * given array is of the value {@link PackageManager#PERMISSION_GRANTED}.
-     *
-     * @see Activity#onRequestPermissionsResult(int, String[], int[])
-     */
-    public static boolean verifyPermissions(int[] grantResults) {
-        // At least one result must be checked.
-        if(grantResults.length < 1){
-            return false;
-        }
-
-        // Verify that each required permission has been granted, otherwise return false.
-        for (int result : grantResults) {
-            if (result != PackageManager.PERMISSION_GRANTED) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Request multi permissions one time.
-     */
-    public static void requestMultiPermissions(final Activity activity, String[] permissionList, int requestCode) {
-
-        final List<String> unGrantPermissionsList = getNoGrantedPermission(activity, permissionList);
-
-        if (unGrantPermissionsList == null) {
-            return;
-        }
-        Log.d(TAG, "requestMultiPermissions permissionsList:" + unGrantPermissionsList.size());
-
-        if (unGrantPermissionsList.size() > 0) {
-            ActivityCompat.requestPermissions(activity, unGrantPermissionsList.toArray(new String[unGrantPermissionsList.size()]),
-                    requestCode);
-            Log.d(TAG, "showMessageOKCancel requestPermissions");
-        }
-    }
-
-    public static ArrayList<String> getNoGrantedPermission(Activity activity, String[] permissionList) {
-
-        ArrayList<String> permissions = new ArrayList<>();
-
-        for (int i = 0; i < permissionList.length; i++) {
-            String requestPermission = permissionList[i];
-
-            // default PERMISSION DENIED
-            int checkSelfPermission = PackageManager.PERMISSION_DENIED;
-            try {
-                checkSelfPermission = ActivityCompat.checkSelfPermission(activity, requestPermission);
-            } catch (RuntimeException e) {
-                Toast.makeText(activity, "please open those permission", Toast.LENGTH_SHORT)
-                        .show();
-                Log.e(TAG, "RuntimeException:" + e.getMessage());
-                return null;
-            }
-
-            if (checkSelfPermission != PackageManager.PERMISSION_GRANTED) {
-                permissions.add(requestPermission);
-            }
-        }
-        return permissions;
-    }
-
-    // Show the tip dialog
-    public static void openSettingActivity(final Context context, String message) {
-        new AlertDialog.Builder(context)
-                .setMessage(message)
-                .setPositiveButton(R.string.action_go_settings, (dialog, which) -> {
-                    Intent intent = new Intent();
-                    intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
-                    Log.d(TAG, "getPackageName(): " + context.getPackageName());
-                    Uri uri = Uri.fromParts("package", context.getPackageName(), null);
-                    intent.setData(uri);
-                    context.startActivity(intent);
-                })
-                .setNegativeButton(android.R.string.cancel, null)
-                .create()
-                .show();
-    }
-}
+/*
+ * Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.provider.Settings;
+import android.support.v4.app.ActivityCompat;
+import android.support.v7.app.AlertDialog;
+import android.util.Log;
+import android.widget.Toast;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.android.contacts.R;
+
+/**
+ * Utility class that wraps access to the runtime permissions API in M and provides basic helper
+ * methods.
+ */
+public class PermissionUtil {
+
+    private static final String TAG = PermissionUtil.class.getSimpleName();
+    public static final int CODE_CAMERA_SCAN = 10000;
+    public static final int CODE_EXTERNAL_STORAGE = 10001;
+
+    public static final String PERMISSION_CAMERA = Manifest.permission.CAMERA;
+    public static final String PERMISSION_WRITE_EXTERNAL_STORAGE = Manifest.permission.WRITE_EXTERNAL_STORAGE;
+
+    public static final String[] CAMERA_PERMISSIONS = {
+            PERMISSION_CAMERA
+    };
+
+    public static final String[] EXTERNAL_STORAGE_PERMISSIONS = {
+            PERMISSION_WRITE_EXTERNAL_STORAGE
+    };
+
+    /**
+     * Check that all given permissions have been granted by verifying that each entry in the
+     * given array is of the value {@link PackageManager#PERMISSION_GRANTED}.
+     *
+     * @see Activity#onRequestPermissionsResult(int, String[], int[])
+     */
+    public static boolean verifyPermissions(int[] grantResults) {
+        // At least one result must be checked.
+        if(grantResults.length < 1){
+            return false;
+        }
+
+        // Verify that each required permission has been granted, otherwise return false.
+        for (int result : grantResults) {
+            if (result != PackageManager.PERMISSION_GRANTED) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Request multi permissions one time.
+     */
+    public static void requestMultiPermissions(final Activity activity, String[] permissionList, int requestCode) {
+
+        final List<String> unGrantPermissionsList = getNoGrantedPermission(activity, permissionList);
+
+        if (unGrantPermissionsList == null) {
+            return;
+        }
+        Log.d(TAG, "requestMultiPermissions permissionsList:" + unGrantPermissionsList.size());
+
+        if (unGrantPermissionsList.size() > 0) {
+            ActivityCompat.requestPermissions(activity, unGrantPermissionsList.toArray(new String[unGrantPermissionsList.size()]),
+                    requestCode);
+            Log.d(TAG, "showMessageOKCancel requestPermissions");
+        }
+    }
+
+    public static ArrayList<String> getNoGrantedPermission(Activity activity, String[] permissionList) {
+
+        ArrayList<String> permissions = new ArrayList<>();
+
+        for (int i = 0; i < permissionList.length; i++) {
+            String requestPermission = permissionList[i];
+
+            // default PERMISSION DENIED
+            int checkSelfPermission = PackageManager.PERMISSION_DENIED;
+            try {
+                checkSelfPermission = ActivityCompat.checkSelfPermission(activity, requestPermission);
+            } catch (RuntimeException e) {
+                Toast.makeText(activity, "please open those permission", Toast.LENGTH_SHORT)
+                        .show();
+                Log.e(TAG, "RuntimeException:" + e.getMessage());
+                return null;
+            }
+
+            if (checkSelfPermission != PackageManager.PERMISSION_GRANTED) {
+                permissions.add(requestPermission);
+            }
+        }
+        return permissions;
+    }
+
+    // Show the tip dialog
+    public static void openSettingActivity(final Context context, String message) {
+        new AlertDialog.Builder(context)
+                .setMessage(message)
+                .setPositiveButton(R.string.action_go_settings, (dialog, which) -> {
+                    Intent intent = new Intent();
+                    intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+                    Log.d(TAG, "getPackageName(): " + context.getPackageName());
+                    Uri uri = Uri.fromParts("package", context.getPackageName(), null);
+                    intent.setData(uri);
+                    context.startActivity(intent);
+                })
+                .setNegativeButton(android.R.string.cancel, null)
+                .create()
+                .show();
+    }
+}
diff --git a/src/com/android/contacts/util/barcode/AmbientLightManager.java b/src/com/android/contacts/util/barcode/AmbientLightManager.java
index b33796e..ba4acdc 100644
--- a/src/com/android/contacts/util/barcode/AmbientLightManager.java
+++ b/src/com/android/contacts/util/barcode/AmbientLightManager.java
@@ -1,82 +1,82 @@
-/*
- * Copyright (C) 2012 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.content.Context;
-import android.hardware.Sensor;
-import android.hardware.SensorEvent;
-import android.hardware.SensorEventListener;
-import android.hardware.SensorManager;
-
-import com.android.contacts.util.barcode.camera.CameraManager;
-
-
-/**
- * Detects ambient light and switches on the front light when very dark, and off again when sufficiently light.
- *
- * @author Sean Owen
- * @author Nikolaus Huber
- */
-final class AmbientLightManager implements SensorEventListener {
-
-    private static final float TOO_DARK_LUX = 45.0f;
-    private static final float BRIGHT_ENOUGH_LUX = 45.0f;
-
-    private final Context context;
-    private CameraManager cameraManager;
-    private Sensor lightSensor;
-
-    AmbientLightManager(Context context) {
-        this.context = context;
-    }
-
-    void start(CameraManager cameraManager) {
-        this.cameraManager = cameraManager;
-        SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
-        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
-        if (lightSensor != null) {
-            sensorManager.registerListener(this, lightSensor, SensorManager.SENSOR_DELAY_NORMAL);
-        }
-    }
-
-    void stop() {
-        if (lightSensor != null) {
-            SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
-            sensorManager.unregisterListener(this);
-            cameraManager = null;
-            lightSensor = null;
-        }
-    }
-
-    @Override
-    public void onSensorChanged(SensorEvent sensorEvent) {
-        /*float ambientLightLux = sensorEvent.values[0];
-        if (cameraManager != null) {
-            if (ambientLightLux <= TOO_DARK_LUX) {
-                cameraManager.setTorch(true);
-            } else if (ambientLightLux >= BRIGHT_ENOUGH_LUX) {
-                cameraManager.setTorch(false);
-            }
-        }*/
-    }
-
-    @Override
-    public void onAccuracyChanged(Sensor sensor, int accuracy) {
-        // do nothing
-    }
-
-}
+/*
+ * Copyright (C) 2012 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.content.Context;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+
+import com.android.contacts.util.barcode.camera.CameraManager;
+
+
+/**
+ * Detects ambient light and switches on the front light when very dark, and off again when sufficiently light.
+ *
+ * @author Sean Owen
+ * @author Nikolaus Huber
+ */
+final class AmbientLightManager implements SensorEventListener {
+
+    private static final float TOO_DARK_LUX = 45.0f;
+    private static final float BRIGHT_ENOUGH_LUX = 45.0f;
+
+    private final Context context;
+    private CameraManager cameraManager;
+    private Sensor lightSensor;
+
+    AmbientLightManager(Context context) {
+        this.context = context;
+    }
+
+    void start(CameraManager cameraManager) {
+        this.cameraManager = cameraManager;
+        SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
+        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
+        if (lightSensor != null) {
+            sensorManager.registerListener(this, lightSensor, SensorManager.SENSOR_DELAY_NORMAL);
+        }
+    }
+
+    void stop() {
+        if (lightSensor != null) {
+            SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
+            sensorManager.unregisterListener(this);
+            cameraManager = null;
+            lightSensor = null;
+        }
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent sensorEvent) {
+        /*float ambientLightLux = sensorEvent.values[0];
+        if (cameraManager != null) {
+            if (ambientLightLux <= TOO_DARK_LUX) {
+                cameraManager.setTorch(true);
+            } else if (ambientLightLux >= BRIGHT_ENOUGH_LUX) {
+                cameraManager.setTorch(false);
+            }
+        }*/
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+        // do nothing
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/BeepManager.java b/src/com/android/contacts/util/barcode/BeepManager.java
index 88e7b78..625b6ba 100644
--- a/src/com/android/contacts/util/barcode/BeepManager.java
+++ b/src/com/android/contacts/util/barcode/BeepManager.java
@@ -1,127 +1,127 @@
-/*
- * Copyright (C) 2010 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.AssetFileDescriptor;
-import android.media.AudioManager;
-import android.media.MediaPlayer;
-import android.os.Build;
-import android.os.Vibrator;
-import android.util.Log;
-
-import java.io.Closeable;
-import java.io.IOException;
-
-import com.android.contacts.R;
-
-/**
- * Manages beeps and vibrations for {@link CaptureActivity}.
- */
-final class BeepManager implements MediaPlayer.OnErrorListener, Closeable {
-
-    private static final String TAG = BeepManager.class.getSimpleName();
-
-    private static final float BEEP_VOLUME = 0.10f;
-    private static final long VIBRATE_DURATION = 200L;
-
-    private final Activity activity;
-    private MediaPlayer mediaPlayer;
-    private boolean playBeep;
-    private boolean vibrate;
-
-    BeepManager(Activity activity) {
-        this.activity = activity;
-        this.mediaPlayer = null;
-        updatePrefs();
-    }
-
-    synchronized void updatePrefs() {
-        playBeep = shouldBeep(activity);
-        vibrate = false;
-        if (playBeep && mediaPlayer == null) {
-            // The volume on STREAM_SYSTEM is not adjustable, and users found it too loud,
-            // so we now play on the music stream.
-            activity.setVolumeControlStream(AudioManager.STREAM_MUSIC);
-            mediaPlayer = buildMediaPlayer(activity);
-        }
-    }
-
-    synchronized void playBeepSoundAndVibrate() {
-        if (playBeep && mediaPlayer != null) {
-            mediaPlayer.start();
-        }
-        if (vibrate) {
-            Vibrator vibrator = (Vibrator) activity.getSystemService(Context.VIBRATOR_SERVICE);
-            vibrator.vibrate(VIBRATE_DURATION);
-        }
-    }
-
-    private static boolean shouldBeep(Context activity) {
-        boolean shouldPlayBeep = true;
-        // See if sound settings overrides this
-        AudioManager audioService = (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);
-        if (audioService.getRingerMode() != AudioManager.RINGER_MODE_NORMAL) {
-            shouldPlayBeep = false;
-        }
-        return shouldPlayBeep;
-    }
-
-    @TargetApi(Build.VERSION_CODES.KITKAT)
-    private MediaPlayer buildMediaPlayer(Context activity) {
-        MediaPlayer mediaPlayer = new MediaPlayer();
-        try {
-            try (AssetFileDescriptor file = activity.getResources().openRawResourceFd(R.raw.beep)) {
-                mediaPlayer.setDataSource(file.getFileDescriptor(), file.getStartOffset(), file.getLength());
-            }
-            mediaPlayer.setOnErrorListener(this);
-            mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
-            mediaPlayer.setLooping(false);
-            mediaPlayer.setVolume(BEEP_VOLUME, BEEP_VOLUME);
-            mediaPlayer.prepare();
-            return mediaPlayer;
-        } catch (IOException ioe) {
-            Log.w(TAG, ioe);
-            mediaPlayer.release();
-            return null;
-        }
-    }
-
-    @Override
-    public synchronized boolean onError(MediaPlayer mp, int what, int extra) {
-        if (what == MediaPlayer.MEDIA_ERROR_SERVER_DIED) {
-            // we are finished, so put up an appropriate error toast if required and finish
-            activity.finish();
-        } else {
-            // possibly media player error, so release and recreate
-            close();
-            updatePrefs();
-        }
-        return true;
-    }
-
-    @Override
-    public synchronized void close() {
-        if (mediaPlayer != null) {
-            mediaPlayer.release();
-            mediaPlayer = null;
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.AssetFileDescriptor;
+import android.media.AudioManager;
+import android.media.MediaPlayer;
+import android.os.Build;
+import android.os.Vibrator;
+import android.util.Log;
+
+import java.io.Closeable;
+import java.io.IOException;
+
+import com.android.contacts.R;
+
+/**
+ * Manages beeps and vibrations for {@link CaptureActivity}.
+ */
+final class BeepManager implements MediaPlayer.OnErrorListener, Closeable {
+
+    private static final String TAG = BeepManager.class.getSimpleName();
+
+    private static final float BEEP_VOLUME = 0.10f;
+    private static final long VIBRATE_DURATION = 200L;
+
+    private final Activity activity;
+    private MediaPlayer mediaPlayer;
+    private boolean playBeep;
+    private boolean vibrate;
+
+    BeepManager(Activity activity) {
+        this.activity = activity;
+        this.mediaPlayer = null;
+        updatePrefs();
+    }
+
+    synchronized void updatePrefs() {
+        playBeep = shouldBeep(activity);
+        vibrate = false;
+        if (playBeep && mediaPlayer == null) {
+            // The volume on STREAM_SYSTEM is not adjustable, and users found it too loud,
+            // so we now play on the music stream.
+            activity.setVolumeControlStream(AudioManager.STREAM_MUSIC);
+            mediaPlayer = buildMediaPlayer(activity);
+        }
+    }
+
+    synchronized void playBeepSoundAndVibrate() {
+        if (playBeep && mediaPlayer != null) {
+            mediaPlayer.start();
+        }
+        if (vibrate) {
+            Vibrator vibrator = (Vibrator) activity.getSystemService(Context.VIBRATOR_SERVICE);
+            vibrator.vibrate(VIBRATE_DURATION);
+        }
+    }
+
+    private static boolean shouldBeep(Context activity) {
+        boolean shouldPlayBeep = true;
+        // See if sound settings overrides this
+        AudioManager audioService = (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);
+        if (audioService.getRingerMode() != AudioManager.RINGER_MODE_NORMAL) {
+            shouldPlayBeep = false;
+        }
+        return shouldPlayBeep;
+    }
+
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private MediaPlayer buildMediaPlayer(Context activity) {
+        MediaPlayer mediaPlayer = new MediaPlayer();
+        try {
+            try (AssetFileDescriptor file = activity.getResources().openRawResourceFd(R.raw.beep)) {
+                mediaPlayer.setDataSource(file.getFileDescriptor(), file.getStartOffset(), file.getLength());
+            }
+            mediaPlayer.setOnErrorListener(this);
+            mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
+            mediaPlayer.setLooping(false);
+            mediaPlayer.setVolume(BEEP_VOLUME, BEEP_VOLUME);
+            mediaPlayer.prepare();
+            return mediaPlayer;
+        } catch (IOException ioe) {
+            Log.w(TAG, ioe);
+            mediaPlayer.release();
+            return null;
+        }
+    }
+
+    @Override
+    public synchronized boolean onError(MediaPlayer mp, int what, int extra) {
+        if (what == MediaPlayer.MEDIA_ERROR_SERVER_DIED) {
+            // we are finished, so put up an appropriate error toast if required and finish
+            activity.finish();
+        } else {
+            // possibly media player error, so release and recreate
+            close();
+            updatePrefs();
+        }
+        return true;
+    }
+
+    @Override
+    public synchronized void close() {
+        if (mediaPlayer != null) {
+            mediaPlayer.release();
+            mediaPlayer = null;
+        }
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/CaptureActivity.java b/src/com/android/contacts/util/barcode/CaptureActivity.java
index afe3c36..fffdd68 100644
--- a/src/com/android/contacts/util/barcode/CaptureActivity.java
+++ b/src/com/android/contacts/util/barcode/CaptureActivity.java
@@ -1,427 +1,427 @@
-/*
- * Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.Manifest;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import android.support.v4.app.ActivityCompat;
-import android.support.v7.app.ActionBar;
-import android.support.v7.app.AlertDialog;
-import android.support.v7.app.AppCompatActivity;
-import android.support.v7.widget.Toolbar;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.SurfaceHolder;
-import android.view.SurfaceView;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.view.WindowManager;
-import android.widget.Button;
-import android.widget.FrameLayout;
-import android.widget.TextView;
-
-import com.android.contacts.activities.base.BaseActivity;
-import com.android.contacts.util.PermissionUtil;
-import com.google.zxing.BarcodeFormat;
-import com.google.zxing.DecodeHintType;
-import com.google.zxing.Result;
-import com.google.zxing.ResultMetadataType;
-
-import java.io.IOException;
-import java.util.Collection;
-import java.util.Map;
-
-import com.android.contacts.R;
-import com.android.contacts.util.barcode.CaptureActivityHandler;
-import com.android.contacts.util.barcode.FinishListener;
-import com.android.contacts.util.barcode.Intents;
-import com.android.contacts.util.barcode.ViewfinderView;
-import com.android.contacts.util.barcode.camera.CameraManager;
-import com.android.contacts.util.barcode.result.ResultHandler;
-import com.android.contacts.util.barcode.result.ResultHandlerFactory;
-import com.android.contacts.util.DisplayUtil;
-
-
-/**
- *  - Intents.Scan.WIDTH
- *  - Intents.Scan.HEIGHT
- */
-public class CaptureActivity extends BaseActivity implements SurfaceHolder.Callback {
-
-    private static final String TAG = "CaptureActivity";
-
-    private static final long DEFAULT_INTENT_RESULT_DURATION_MS = 100L;
-    private CameraManager cameraManager;
-    private boolean hasSurface;
-    private BeepManager beepManager;
-    private AmbientLightManager ambientLightManager;
-    private ViewfinderView viewfinderView;
-    private TextView statusView;
-    private Button setTorchBtn;
-    private CaptureActivityHandler handler;
-    private Collection<BarcodeFormat> decodeFormats;
-    private Map<DecodeHintType,?> decodeHints;
-    private String characterSet;
-    private Result lastResult;
-    private Result savedResultToShow;
-
-    @Override
-    protected String tag() {
-        return CaptureActivity.class.getName();
-    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_capture);
-        Log.d(TAG, "onCreate");
-        hasSurface = false;
-        beepManager = new BeepManager(this);
-        ambientLightManager = new AmbientLightManager(this);
-
-        Window window = getWindow();
-        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
-        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
-        Toolbar toolbar = findViewById(R.id.toolbar);
-        if (toolbar != null) {
-            setSupportActionBar(toolbar);
-            ActionBar ab = getSupportActionBar();
-            if (ab != null) {
-                ab.setDisplayHomeAsUpEnabled(true);
-                ab.setDisplayShowHomeEnabled(true);
-                ab.setTitle("qrcode");
-            }
-        }
-    }
-
-    ViewfinderView getViewfinderView() {
-        return viewfinderView;
-    }
-
-    public Handler getHandler() {
-        return handler;
-    }
-
-    CameraManager getCameraManager() {
-        return cameraManager;
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        // CameraManager must be initialized here, not in onCreate(). This is necessary because we don't
-        // want to open the camera driver and measure the screen size if we're going to show the help on
-        // first launch. That led to bugs where the scanning rectangle was the wrong size and partially
-        // off screen.
-        cameraManager = new CameraManager(getApplication());
-
-        viewfinderView = findViewById(R.id.viewfinder_view);
-        viewfinderView.setCameraManager(cameraManager);
-        statusView = findViewById(R.id.status_view);
-        setTorchBtn = findViewById(R.id.set_torch_btn);
-
-        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
-        int windowHeight = DisplayUtil.getScreenHeight(this);
-        int windowWidth = DisplayUtil.getScreenWidth(this);
-        int scanHeight = CameraManager.findDesiredDimensionInRange(windowHeight, CameraManager.MIN_FRAME_HEIGHT, CameraManager.MAX_FRAME_HEIGHT);
-        int topOffset = (windowHeight - scanHeight) / 3;
-        int measureWidth = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
-        int measureHeight = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
-        setTorchBtn.measure(measureWidth, measureHeight);
-        int buttonWidth = setTorchBtn.getMeasuredWidth();
-        layoutParams.setMargins((windowWidth - buttonWidth) / 2, scanHeight + topOffset + DisplayUtil.dip2px(this, getResources().getDimension(R.dimen.space_normal)), 0, 0);
-
-        handler = null;
-        beepManager.updatePrefs();
-        ambientLightManager.start(cameraManager);
-
-        Intent intent = getIntent();
-        decodeFormats = DecodeFormatManager.parseDecodeFormats(intent);
-        decodeHints = DecodeHintManager.parseDecodeHints(intent);
-        if (intent.hasExtra(Intents.Scan.WIDTH) && intent.hasExtra(Intents.Scan.HEIGHT)) {
-            int width = intent.getIntExtra(Intents.Scan.WIDTH, 0);
-            int height = intent.getIntExtra(Intents.Scan.HEIGHT, 0);
-            if (width > 0 && height > 0) {
-                cameraManager.setManualFramingRect(width, height);
-            }
-        }
-
-        if (intent.hasExtra(Intents.Scan.CAMERA_ID)) {
-            int cameraId = intent.getIntExtra(Intents.Scan.CAMERA_ID, -1);
-            if (cameraId >= 0) {
-                cameraManager.setManualCameraId(cameraId);
-            }
-        }
-
-        String customPromptMessage = intent.getStringExtra(Intents.Scan.PROMPT_MESSAGE);
-        if (customPromptMessage != null) {
-            statusView.setText(customPromptMessage);
-        }
-
-        characterSet = intent.getStringExtra(Intents.Scan.CHARACTER_SET);
-
-        SurfaceView surfaceView = findViewById(R.id.preview_view);
-        SurfaceHolder surfaceHolder = surfaceView.getHolder();
-        if (hasSurface) {
-            // The activity was paused but not stopped, so the surface still exists. Therefore
-            // surfaceCreated() won't be called, so init the camera here.
-            initCamera(surfaceHolder);
-        } else {
-            // Install the callback and wait for surfaceCreated() to init the camera.
-            surfaceHolder.addCallback(this);
-        }
-    }
-
-    // Request camera permission
-    public void requestCameraScanPermission() {
-        PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
-    }
-
-    public void handleCameraScanPermission() {
-    }
-
-    @Override
-    protected void onPause() {
-        Log.d(TAG, "onPause");
-        if (handler != null) {
-            handler.quitSynchronously();
-            handler = null;
-        }
-
-        if (ambientLightManager != null) {
-            ambientLightManager.stop();
-        }
-        if (beepManager != null) {
-            beepManager.close();
-        }
-        if (cameraManager != null) {
-            cameraManager.closeDriver();
-        }
-
-        if (!hasSurface) {
-            SurfaceView surfaceView = findViewById(R.id.preview_view);
-            SurfaceHolder surfaceHolder = surfaceView.getHolder();
-            surfaceHolder.removeCallback(this);
-        }
-        super.onPause();
-    }
-
-    /**
-     * A valid barcode has been found, so give an indication of success and show the results.
-     *
-     * @param rawResult The contents of the barcode.
-     * @param scaleFactor amount by which thumbnail was scaled
-     * @param barcode   A greyscale bitmap of the camera data which was decoded.
-     */
-    public void handleDecode(Result rawResult, Bitmap barcode, float scaleFactor) {
-        lastResult = rawResult;
-        ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler(this, rawResult);
-
-        boolean fromLiveScan = barcode != null;
-        if (fromLiveScan) {
-            // Then not from history, so beep/vibrate and we have an image to draw on
-            beepManager.playBeepSoundAndVibrate();
-        }
-
-        handleDecodeExternally(rawResult, resultHandler, barcode);
-    }
-
-    @Override
-    public void surfaceCreated(SurfaceHolder holder) {
-        Log.d(tag(), "surface created");
-        if (holder == null) {
-            Log.e(TAG, "*** WARNING *** surfaceCreated() gave us a null surface!");
-        }
-
-        if (!hasSurface) {
-            hasSurface = true;
-            initCamera(holder);
-        }
-    }
-
-    // Briefly show the contents of the barcode, then handle the result outside Barcode Scanner.
-    private void handleDecodeExternally(Result rawResult, ResultHandler resultHandler, Bitmap barcode) {
-
-        if (barcode != null) {
-            viewfinderView.drawResultBitmap(barcode);
-        }
-
-        long resultDurationMS;
-        if (getIntent() == null) {
-            resultDurationMS = DEFAULT_INTENT_RESULT_DURATION_MS;
-        } else {
-            resultDurationMS = getIntent().getLongExtra(Intents.Scan.RESULT_DISPLAY_DURATION_MS,
-                    DEFAULT_INTENT_RESULT_DURATION_MS);
-        }
-
-        // Hand back whatever action they requested - this can be changed to Intents.Scan.ACTION when
-        // the deprecated intent is retired.
-        Intent intent = new Intent(getIntent().getAction());
-        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
-        intent.putExtra(Intents.Scan.RESULT, rawResult.toString());
-        intent.putExtra(Intents.Scan.RESULT_FORMAT, rawResult.getBarcodeFormat().toString());
-        byte[] rawBytes = rawResult.getRawBytes();
-        if (rawBytes != null && rawBytes.length > 0) {
-            intent.putExtra(Intents.Scan.RESULT_BYTES, rawBytes);
-        }
-
-        Map<ResultMetadataType,?> metadata = rawResult.getResultMetadata();
-        if (metadata != null) {
-            if (metadata.containsKey(ResultMetadataType.UPC_EAN_EXTENSION)) {
-                intent.putExtra(Intents.Scan.RESULT_UPC_EAN_EXTENSION,
-                        metadata.get(ResultMetadataType.UPC_EAN_EXTENSION).toString());
-            }
-            Number orientation = (Number) metadata.get(ResultMetadataType.ORIENTATION);
-            if (orientation != null) {
-                intent.putExtra(Intents.Scan.RESULT_ORIENTATION, orientation.intValue());
-            }
-            String ecLevel = (String) metadata.get(ResultMetadataType.ERROR_CORRECTION_LEVEL);
-            if (ecLevel != null) {
-                intent.putExtra(Intents.Scan.RESULT_ERROR_CORRECTION_LEVEL, ecLevel);
-            }
-
-            @SuppressWarnings("unchecked")
-            Iterable<byte[]> byteSegments = (Iterable<byte[]>) metadata.get(ResultMetadataType.BYTE_SEGMENTS);
-            if (byteSegments != null) {
-                int i = 0;
-                for (byte[] byteSegment : byteSegments) {
-                    intent.putExtra(Intents.Scan.RESULT_BYTE_SEGMENTS_PREFIX + i, byteSegment);
-                    i++;
-                }
-            }
-        }
-        sendReplyMessage(R.id.return_scan_result, intent, resultDurationMS);
-    }
-
-    private void sendReplyMessage(int id, Object arg, long delayMS) {
-        if (handler != null) {
-            Message message = Message.obtain(handler, id, arg);
-            if (delayMS > 0L) {
-                handler.sendMessageDelayed(message, delayMS);
-            } else {
-                handler.sendMessage(message);
-            }
-        }
-    }
-
-    private void decodeOrStoreSavedBitmap(Bitmap bitmap, Result result) {
-        // Bitmap isn't used yet -- will be used soon
-        if (handler == null) {
-            savedResultToShow = result;
-        } else {
-            if (result != null) {
-                savedResultToShow = result;
-            }
-            if (savedResultToShow != null) {
-                Message message = Message.obtain(handler, R.id.decode_succeeded, savedResultToShow);
-                handler.sendMessage(message);
-            }
-            savedResultToShow = null;
-        }
-    }
-
-    private void initCamera(SurfaceHolder surfaceHolder) {
-        if (surfaceHolder == null) {
-            throw new IllegalStateException("No SurfaceHolder provided");
-        }
-
-        /*if (PermissionUtil.getNoGrantedPermission(this, PermissionUtil.CAMERA_PERMISSIONS) != null) {
-            PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
-            return;
-        }*/
-
-        if (cameraManager.isOpen()) {
-            Log.w(TAG, "initCamera() while already open -- late SurfaceView callback?");
-            return;
-        }
-
-        try {
-            cameraManager.openDriver(surfaceHolder);
-            // Creating the handler starts the preview, which can also throw a RuntimeException.
-            if (handler == null) {
-                handler = new CaptureActivityHandler(this, decodeFormats, decodeHints, characterSet, cameraManager);
-            }
-            decodeOrStoreSavedBitmap(null, null);
-        } catch (IOException ioe) {
-            Log.w(TAG, ioe.getMessage());
-            ioe.printStackTrace();
-            displayFrameworkBugMessageAndExit();
-        } catch (RuntimeException e) {
-            // Barcode Scanner has seen crashes in the wild of this variety:
-            // java.?lang.?RuntimeException: Fail to connect to camera service
-            Log.w(TAG, "Unexpected error initializing camera = " + e.getMessage());
-            displayFrameworkBugMessageAndExit();
-        }
-    }
-
-    private void displayFrameworkBugMessageAndExit() {
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle(getString(R.string.applicationLabel));
-        builder.setMessage(getString(R.string.msg_camera_framework_bug));
-        builder.setPositiveButton(R.string.button_ok, new FinishListener(this));
-        builder.setOnCancelListener(new FinishListener(this));
-        builder.show();
-    }
-
-    @Override
-    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
-        Log.d(tag(), "surface changed");
-    }
-
-    @Override
-    public void surfaceDestroyed(SurfaceHolder holder) {
-        Log.d(tag(), "surface destroyed");
-        hasSurface = false;
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_BACK:
-                setResult(RESULT_CANCELED);
-                finish();
-                return true;
-
-            case KeyEvent.KEYCODE_FOCUS:
-            case KeyEvent.KEYCODE_CAMERA:
-                // Handle these events so they don't launch the Camera app
-                return true;
-
-            // Use volume up/down to turn on light
-            case KeyEvent.KEYCODE_VOLUME_DOWN:
-                cameraManager.setTorch(false);
-                return true;
-
-            case KeyEvent.KEYCODE_VOLUME_UP:
-                cameraManager.setTorch(true);
-                return true;
-        }
-        return super.onKeyDown(keyCode, event);
-    }
-
-    public void drawViewfinder() {
-        viewfinderView.drawViewfinder();
-    }
-}
+/*
+ * Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.Manifest;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.support.v4.app.ActivityCompat;
+import android.support.v7.app.ActionBar;
+import android.support.v7.app.AlertDialog;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.Button;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+
+import com.android.contacts.activities.base.BaseActivity;
+import com.android.contacts.util.PermissionUtil;
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.Result;
+import com.google.zxing.ResultMetadataType;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Map;
+
+import com.android.contacts.R;
+import com.android.contacts.util.barcode.CaptureActivityHandler;
+import com.android.contacts.util.barcode.FinishListener;
+import com.android.contacts.util.barcode.Intents;
+import com.android.contacts.util.barcode.ViewfinderView;
+import com.android.contacts.util.barcode.camera.CameraManager;
+import com.android.contacts.util.barcode.result.ResultHandler;
+import com.android.contacts.util.barcode.result.ResultHandlerFactory;
+import com.android.contacts.util.DisplayUtil;
+
+
+/**
+ *  - Intents.Scan.WIDTH
+ *  - Intents.Scan.HEIGHT
+ */
+public class CaptureActivity extends BaseActivity implements SurfaceHolder.Callback {
+
+    private static final String TAG = "CaptureActivity";
+
+    private static final long DEFAULT_INTENT_RESULT_DURATION_MS = 100L;
+    private CameraManager cameraManager;
+    private boolean hasSurface;
+    private BeepManager beepManager;
+    private AmbientLightManager ambientLightManager;
+    private ViewfinderView viewfinderView;
+    private TextView statusView;
+    private Button setTorchBtn;
+    private CaptureActivityHandler handler;
+    private Collection<BarcodeFormat> decodeFormats;
+    private Map<DecodeHintType,?> decodeHints;
+    private String characterSet;
+    private Result lastResult;
+    private Result savedResultToShow;
+
+    @Override
+    protected String tag() {
+        return CaptureActivity.class.getName();
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_capture);
+        Log.d(TAG, "onCreate");
+        hasSurface = false;
+        beepManager = new BeepManager(this);
+        ambientLightManager = new AmbientLightManager(this);
+
+        Window window = getWindow();
+        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
+        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        if (toolbar != null) {
+            setSupportActionBar(toolbar);
+            ActionBar ab = getSupportActionBar();
+            if (ab != null) {
+                ab.setDisplayHomeAsUpEnabled(true);
+                ab.setDisplayShowHomeEnabled(true);
+                ab.setTitle("qrcode");
+            }
+        }
+    }
+
+    ViewfinderView getViewfinderView() {
+        return viewfinderView;
+    }
+
+    public Handler getHandler() {
+        return handler;
+    }
+
+    CameraManager getCameraManager() {
+        return cameraManager;
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        // CameraManager must be initialized here, not in onCreate(). This is necessary because we don't
+        // want to open the camera driver and measure the screen size if we're going to show the help on
+        // first launch. That led to bugs where the scanning rectangle was the wrong size and partially
+        // off screen.
+        cameraManager = new CameraManager(getApplication());
+
+        viewfinderView = findViewById(R.id.viewfinder_view);
+        viewfinderView.setCameraManager(cameraManager);
+        statusView = findViewById(R.id.status_view);
+        setTorchBtn = findViewById(R.id.set_torch_btn);
+
+        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+        int windowHeight = DisplayUtil.getScreenHeight(this);
+        int windowWidth = DisplayUtil.getScreenWidth(this);
+        int scanHeight = CameraManager.findDesiredDimensionInRange(windowHeight, CameraManager.MIN_FRAME_HEIGHT, CameraManager.MAX_FRAME_HEIGHT);
+        int topOffset = (windowHeight - scanHeight) / 3;
+        int measureWidth = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
+        int measureHeight = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
+        setTorchBtn.measure(measureWidth, measureHeight);
+        int buttonWidth = setTorchBtn.getMeasuredWidth();
+        layoutParams.setMargins((windowWidth - buttonWidth) / 2, scanHeight + topOffset + DisplayUtil.dip2px(this, getResources().getDimension(R.dimen.space_normal)), 0, 0);
+
+        handler = null;
+        beepManager.updatePrefs();
+        ambientLightManager.start(cameraManager);
+
+        Intent intent = getIntent();
+        decodeFormats = DecodeFormatManager.parseDecodeFormats(intent);
+        decodeHints = DecodeHintManager.parseDecodeHints(intent);
+        if (intent.hasExtra(Intents.Scan.WIDTH) && intent.hasExtra(Intents.Scan.HEIGHT)) {
+            int width = intent.getIntExtra(Intents.Scan.WIDTH, 0);
+            int height = intent.getIntExtra(Intents.Scan.HEIGHT, 0);
+            if (width > 0 && height > 0) {
+                cameraManager.setManualFramingRect(width, height);
+            }
+        }
+
+        if (intent.hasExtra(Intents.Scan.CAMERA_ID)) {
+            int cameraId = intent.getIntExtra(Intents.Scan.CAMERA_ID, -1);
+            if (cameraId >= 0) {
+                cameraManager.setManualCameraId(cameraId);
+            }
+        }
+
+        String customPromptMessage = intent.getStringExtra(Intents.Scan.PROMPT_MESSAGE);
+        if (customPromptMessage != null) {
+            statusView.setText(customPromptMessage);
+        }
+
+        characterSet = intent.getStringExtra(Intents.Scan.CHARACTER_SET);
+
+        SurfaceView surfaceView = findViewById(R.id.preview_view);
+        SurfaceHolder surfaceHolder = surfaceView.getHolder();
+        if (hasSurface) {
+            // The activity was paused but not stopped, so the surface still exists. Therefore
+            // surfaceCreated() won't be called, so init the camera here.
+            initCamera(surfaceHolder);
+        } else {
+            // Install the callback and wait for surfaceCreated() to init the camera.
+            surfaceHolder.addCallback(this);
+        }
+    }
+
+    // Request camera permission
+    public void requestCameraScanPermission() {
+        PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
+    }
+
+    public void handleCameraScanPermission() {
+    }
+
+    @Override
+    protected void onPause() {
+        Log.d(TAG, "onPause");
+        if (handler != null) {
+            handler.quitSynchronously();
+            handler = null;
+        }
+
+        if (ambientLightManager != null) {
+            ambientLightManager.stop();
+        }
+        if (beepManager != null) {
+            beepManager.close();
+        }
+        if (cameraManager != null) {
+            cameraManager.closeDriver();
+        }
+
+        if (!hasSurface) {
+            SurfaceView surfaceView = findViewById(R.id.preview_view);
+            SurfaceHolder surfaceHolder = surfaceView.getHolder();
+            surfaceHolder.removeCallback(this);
+        }
+        super.onPause();
+    }
+
+    /**
+     * A valid barcode has been found, so give an indication of success and show the results.
+     *
+     * @param rawResult The contents of the barcode.
+     * @param scaleFactor amount by which thumbnail was scaled
+     * @param barcode   A greyscale bitmap of the camera data which was decoded.
+     */
+    public void handleDecode(Result rawResult, Bitmap barcode, float scaleFactor) {
+        lastResult = rawResult;
+        ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler(this, rawResult);
+
+        boolean fromLiveScan = barcode != null;
+        if (fromLiveScan) {
+            // Then not from history, so beep/vibrate and we have an image to draw on
+            beepManager.playBeepSoundAndVibrate();
+        }
+
+        handleDecodeExternally(rawResult, resultHandler, barcode);
+    }
+
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        Log.d(tag(), "surface created");
+        if (holder == null) {
+            Log.e(TAG, "*** WARNING *** surfaceCreated() gave us a null surface!");
+        }
+
+        if (!hasSurface) {
+            hasSurface = true;
+            initCamera(holder);
+        }
+    }
+
+    // Briefly show the contents of the barcode, then handle the result outside Barcode Scanner.
+    private void handleDecodeExternally(Result rawResult, ResultHandler resultHandler, Bitmap barcode) {
+
+        if (barcode != null) {
+            viewfinderView.drawResultBitmap(barcode);
+        }
+
+        long resultDurationMS;
+        if (getIntent() == null) {
+            resultDurationMS = DEFAULT_INTENT_RESULT_DURATION_MS;
+        } else {
+            resultDurationMS = getIntent().getLongExtra(Intents.Scan.RESULT_DISPLAY_DURATION_MS,
+                    DEFAULT_INTENT_RESULT_DURATION_MS);
+        }
+
+        // Hand back whatever action they requested - this can be changed to Intents.Scan.ACTION when
+        // the deprecated intent is retired.
+        Intent intent = new Intent(getIntent().getAction());
+        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+        intent.putExtra(Intents.Scan.RESULT, rawResult.toString());
+        intent.putExtra(Intents.Scan.RESULT_FORMAT, rawResult.getBarcodeFormat().toString());
+        byte[] rawBytes = rawResult.getRawBytes();
+        if (rawBytes != null && rawBytes.length > 0) {
+            intent.putExtra(Intents.Scan.RESULT_BYTES, rawBytes);
+        }
+
+        Map<ResultMetadataType,?> metadata = rawResult.getResultMetadata();
+        if (metadata != null) {
+            if (metadata.containsKey(ResultMetadataType.UPC_EAN_EXTENSION)) {
+                intent.putExtra(Intents.Scan.RESULT_UPC_EAN_EXTENSION,
+                        metadata.get(ResultMetadataType.UPC_EAN_EXTENSION).toString());
+            }
+            Number orientation = (Number) metadata.get(ResultMetadataType.ORIENTATION);
+            if (orientation != null) {
+                intent.putExtra(Intents.Scan.RESULT_ORIENTATION, orientation.intValue());
+            }
+            String ecLevel = (String) metadata.get(ResultMetadataType.ERROR_CORRECTION_LEVEL);
+            if (ecLevel != null) {
+                intent.putExtra(Intents.Scan.RESULT_ERROR_CORRECTION_LEVEL, ecLevel);
+            }
+
+            @SuppressWarnings("unchecked")
+            Iterable<byte[]> byteSegments = (Iterable<byte[]>) metadata.get(ResultMetadataType.BYTE_SEGMENTS);
+            if (byteSegments != null) {
+                int i = 0;
+                for (byte[] byteSegment : byteSegments) {
+                    intent.putExtra(Intents.Scan.RESULT_BYTE_SEGMENTS_PREFIX + i, byteSegment);
+                    i++;
+                }
+            }
+        }
+        sendReplyMessage(R.id.return_scan_result, intent, resultDurationMS);
+    }
+
+    private void sendReplyMessage(int id, Object arg, long delayMS) {
+        if (handler != null) {
+            Message message = Message.obtain(handler, id, arg);
+            if (delayMS > 0L) {
+                handler.sendMessageDelayed(message, delayMS);
+            } else {
+                handler.sendMessage(message);
+            }
+        }
+    }
+
+    private void decodeOrStoreSavedBitmap(Bitmap bitmap, Result result) {
+        // Bitmap isn't used yet -- will be used soon
+        if (handler == null) {
+            savedResultToShow = result;
+        } else {
+            if (result != null) {
+                savedResultToShow = result;
+            }
+            if (savedResultToShow != null) {
+                Message message = Message.obtain(handler, R.id.decode_succeeded, savedResultToShow);
+                handler.sendMessage(message);
+            }
+            savedResultToShow = null;
+        }
+    }
+
+    private void initCamera(SurfaceHolder surfaceHolder) {
+        if (surfaceHolder == null) {
+            throw new IllegalStateException("No SurfaceHolder provided");
+        }
+
+        /*if (PermissionUtil.getNoGrantedPermission(this, PermissionUtil.CAMERA_PERMISSIONS) != null) {
+            PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
+            return;
+        }*/
+
+        if (cameraManager.isOpen()) {
+            Log.w(TAG, "initCamera() while already open -- late SurfaceView callback?");
+            return;
+        }
+
+        try {
+            cameraManager.openDriver(surfaceHolder);
+            // Creating the handler starts the preview, which can also throw a RuntimeException.
+            if (handler == null) {
+                handler = new CaptureActivityHandler(this, decodeFormats, decodeHints, characterSet, cameraManager);
+            }
+            decodeOrStoreSavedBitmap(null, null);
+        } catch (IOException ioe) {
+            Log.w(TAG, ioe.getMessage());
+            ioe.printStackTrace();
+            displayFrameworkBugMessageAndExit();
+        } catch (RuntimeException e) {
+            // Barcode Scanner has seen crashes in the wild of this variety:
+            // java.?lang.?RuntimeException: Fail to connect to camera service
+            Log.w(TAG, "Unexpected error initializing camera = " + e.getMessage());
+            displayFrameworkBugMessageAndExit();
+        }
+    }
+
+    private void displayFrameworkBugMessageAndExit() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(getString(R.string.applicationLabel));
+        builder.setMessage(getString(R.string.msg_camera_framework_bug));
+        builder.setPositiveButton(R.string.button_ok, new FinishListener(this));
+        builder.setOnCancelListener(new FinishListener(this));
+        builder.show();
+    }
+
+    @Override
+    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
+        Log.d(tag(), "surface changed");
+    }
+
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        Log.d(tag(), "surface destroyed");
+        hasSurface = false;
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_BACK:
+                setResult(RESULT_CANCELED);
+                finish();
+                return true;
+
+            case KeyEvent.KEYCODE_FOCUS:
+            case KeyEvent.KEYCODE_CAMERA:
+                // Handle these events so they don't launch the Camera app
+                return true;
+
+            // Use volume up/down to turn on light
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+                cameraManager.setTorch(false);
+                return true;
+
+            case KeyEvent.KEYCODE_VOLUME_UP:
+                cameraManager.setTorch(true);
+                return true;
+        }
+        return super.onKeyDown(keyCode, event);
+    }
+
+    public void drawViewfinder() {
+        viewfinderView.drawViewfinder();
+    }
+}
diff --git a/src/com/android/contacts/util/barcode/CaptureActivityHandler.java b/src/com/android/contacts/util/barcode/CaptureActivityHandler.java
index 44d761f..af4bacf 100644
--- a/src/com/android/contacts/util/barcode/CaptureActivityHandler.java
+++ b/src/com/android/contacts/util/barcode/CaptureActivityHandler.java
@@ -1,172 +1,172 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import android.provider.Browser;
-import android.util.Log;
-
-import com.android.contacts.util.barcode.camera.CameraManager;
-import com.google.zxing.BarcodeFormat;
-import com.google.zxing.DecodeHintType;
-import com.google.zxing.Result;
-
-import java.util.Collection;
-import java.util.Map;
-
-import com.android.contacts.R;
-
-
-/**
- * This class handles all the messaging which comprises the state machine for capture.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class CaptureActivityHandler extends Handler {
-
-    private static final String TAG = CaptureActivityHandler.class.getSimpleName();
-
-    private final CaptureActivity activity;
-    private final DecodeThread decodeThread;
-    private State state;
-    private final CameraManager cameraManager;
-
-    private enum State {
-        PREVIEW,
-        SUCCESS,
-        DONE
-    }
-
-    CaptureActivityHandler(CaptureActivity activity,
-                           Collection<BarcodeFormat> decodeFormats,
-                           Map<DecodeHintType, ?> baseHints,
-                           String characterSet,
-                           CameraManager cameraManager) {
-        this.activity = activity;
-        decodeThread = new DecodeThread(activity, decodeFormats, baseHints, characterSet,
-                new ViewfinderResultPointCallback(activity.getViewfinderView()));
-        decodeThread.start();
-        state = State.SUCCESS;
-
-        // Start ourselves capturing previews and decoding.
-        this.cameraManager = cameraManager;
-        cameraManager.startPreview();
-        restartPreviewAndDecode();
-    }
-
-    @Override
-    public void handleMessage(Message message) {
-        switch (message.what) {
-            case R.id.restart_preview:
-                restartPreviewAndDecode();
-                break;
-
-            case R.id.decode_succeeded:
-                state = State.SUCCESS;
-                Bundle bundle = message.getData();
-                Bitmap barcode = null;
-                float scaleFactor = 1.0f;
-                if (bundle != null) {
-                    byte[] compressedBitmap = bundle.getByteArray(DecodeThread.BARCODE_BITMAP);
-                    if (compressedBitmap != null) {
-                        barcode = BitmapFactory.decodeByteArray(compressedBitmap, 0, compressedBitmap.length, null);
-                        // Mutable copy:
-                        barcode = barcode.copy(Bitmap.Config.ARGB_8888, true);
-                    }
-                    scaleFactor = bundle.getFloat(DecodeThread.BARCODE_SCALED_FACTOR);
-                }
-                activity.handleDecode((Result) message.obj, barcode, scaleFactor);
-                break;
-
-            case R.id.decode_failed:
-                // We're decoding as fast as possible, so when one decode fails, start another.
-                state = State.PREVIEW;
-                cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
-                break;
-
-            case R.id.return_scan_result:
-                activity.setResult(Activity.RESULT_OK, (Intent) message.obj);
-                activity.finish();
-                break;
-
-            case R.id.launch_product_query:
-                String url = (String) message.obj;
-
-                Intent intent = new Intent(Intent.ACTION_VIEW);
-                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
-                intent.setData(Uri.parse(url));
-
-                ResolveInfo resolveInfo =
-                        activity.getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
-                String browserPackageName = null;
-                if (resolveInfo != null && resolveInfo.activityInfo != null) {
-                    browserPackageName = resolveInfo.activityInfo.packageName;
-                    Log.d(TAG, "Using browser in package " + browserPackageName);
-                }
-
-                // Needed for default Android browser / Chrome only apparently
-                if ("com.android.browser".equals(browserPackageName) || "com.android.chrome".equals(browserPackageName)) {
-                    intent.setPackage(browserPackageName);
-                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                    intent.putExtra(Browser.EXTRA_APPLICATION_ID, browserPackageName);
-                }
-
-                try {
-                    activity.startActivity(intent);
-                } catch (ActivityNotFoundException ignored) {
-                    Log.w(TAG, "Can't find anything to handle VIEW of URI " + url);
-                }
-                break;
-        }
-    }
-
-    public void quitSynchronously() {
-        state = State.DONE;
-        cameraManager.stopPreview();
-        Message quit = Message.obtain(decodeThread.getHandler(), R.id.quit);
-        quit.sendToTarget();
-        try {
-            // Wait at most half a second; should be enough time, and onPause() will timeout quickly
-            decodeThread.join(500L);
-        } catch (InterruptedException e) {
-            // continue
-        }
-
-        // Be absolutely sure we don't send any queued up messages
-        removeMessages(R.id.decode_succeeded);
-        removeMessages(R.id.decode_failed);
-    }
-
-    private void restartPreviewAndDecode() {
-        if (state == State.SUCCESS) {
-            state = State.PREVIEW;
-            cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
-            activity.drawViewfinder();
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.provider.Browser;
+import android.util.Log;
+
+import com.android.contacts.util.barcode.camera.CameraManager;
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.Result;
+
+import java.util.Collection;
+import java.util.Map;
+
+import com.android.contacts.R;
+
+
+/**
+ * This class handles all the messaging which comprises the state machine for capture.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class CaptureActivityHandler extends Handler {
+
+    private static final String TAG = CaptureActivityHandler.class.getSimpleName();
+
+    private final CaptureActivity activity;
+    private final DecodeThread decodeThread;
+    private State state;
+    private final CameraManager cameraManager;
+
+    private enum State {
+        PREVIEW,
+        SUCCESS,
+        DONE
+    }
+
+    CaptureActivityHandler(CaptureActivity activity,
+                           Collection<BarcodeFormat> decodeFormats,
+                           Map<DecodeHintType, ?> baseHints,
+                           String characterSet,
+                           CameraManager cameraManager) {
+        this.activity = activity;
+        decodeThread = new DecodeThread(activity, decodeFormats, baseHints, characterSet,
+                new ViewfinderResultPointCallback(activity.getViewfinderView()));
+        decodeThread.start();
+        state = State.SUCCESS;
+
+        // Start ourselves capturing previews and decoding.
+        this.cameraManager = cameraManager;
+        cameraManager.startPreview();
+        restartPreviewAndDecode();
+    }
+
+    @Override
+    public void handleMessage(Message message) {
+        switch (message.what) {
+            case R.id.restart_preview:
+                restartPreviewAndDecode();
+                break;
+
+            case R.id.decode_succeeded:
+                state = State.SUCCESS;
+                Bundle bundle = message.getData();
+                Bitmap barcode = null;
+                float scaleFactor = 1.0f;
+                if (bundle != null) {
+                    byte[] compressedBitmap = bundle.getByteArray(DecodeThread.BARCODE_BITMAP);
+                    if (compressedBitmap != null) {
+                        barcode = BitmapFactory.decodeByteArray(compressedBitmap, 0, compressedBitmap.length, null);
+                        // Mutable copy:
+                        barcode = barcode.copy(Bitmap.Config.ARGB_8888, true);
+                    }
+                    scaleFactor = bundle.getFloat(DecodeThread.BARCODE_SCALED_FACTOR);
+                }
+                activity.handleDecode((Result) message.obj, barcode, scaleFactor);
+                break;
+
+            case R.id.decode_failed:
+                // We're decoding as fast as possible, so when one decode fails, start another.
+                state = State.PREVIEW;
+                cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
+                break;
+
+            case R.id.return_scan_result:
+                activity.setResult(Activity.RESULT_OK, (Intent) message.obj);
+                activity.finish();
+                break;
+
+            case R.id.launch_product_query:
+                String url = (String) message.obj;
+
+                Intent intent = new Intent(Intent.ACTION_VIEW);
+                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+                intent.setData(Uri.parse(url));
+
+                ResolveInfo resolveInfo =
+                        activity.getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
+                String browserPackageName = null;
+                if (resolveInfo != null && resolveInfo.activityInfo != null) {
+                    browserPackageName = resolveInfo.activityInfo.packageName;
+                    Log.d(TAG, "Using browser in package " + browserPackageName);
+                }
+
+                // Needed for default Android browser / Chrome only apparently
+                if ("com.android.browser".equals(browserPackageName) || "com.android.chrome".equals(browserPackageName)) {
+                    intent.setPackage(browserPackageName);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    intent.putExtra(Browser.EXTRA_APPLICATION_ID, browserPackageName);
+                }
+
+                try {
+                    activity.startActivity(intent);
+                } catch (ActivityNotFoundException ignored) {
+                    Log.w(TAG, "Can't find anything to handle VIEW of URI " + url);
+                }
+                break;
+        }
+    }
+
+    public void quitSynchronously() {
+        state = State.DONE;
+        cameraManager.stopPreview();
+        Message quit = Message.obtain(decodeThread.getHandler(), R.id.quit);
+        quit.sendToTarget();
+        try {
+            // Wait at most half a second; should be enough time, and onPause() will timeout quickly
+            decodeThread.join(500L);
+        } catch (InterruptedException e) {
+            // continue
+        }
+
+        // Be absolutely sure we don't send any queued up messages
+        removeMessages(R.id.decode_succeeded);
+        removeMessages(R.id.decode_failed);
+    }
+
+    private void restartPreviewAndDecode() {
+        if (state == State.SUCCESS) {
+            state = State.PREVIEW;
+            cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
+            activity.drawViewfinder();
+        }
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/Contents.java b/src/com/android/contacts/util/barcode/Contents.java
index 162fc28..17aea95 100644
--- a/src/com/android/contacts/util/barcode/Contents.java
+++ b/src/com/android/contacts/util/barcode/Contents.java
@@ -1,118 +1,118 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.provider.ContactsContract;
-
-/**
- * The set of constants to use when sending Barcode Scanner an Intent which requests a barcode
- * to be encoded.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class Contents {
-  private Contents() {
-  }
-
-  /**
-   * Contains type constants used when sending Intents.
-   */
-  public static final class Type {
-    /**
-     * Plain text. Use Intent.putExtra(DATA, string). This can be used for URLs too, but string
-     * must include "http://" or "https://".
-     */
-    public static final String TEXT = "TEXT_TYPE";
-
-    /**
-     * An email type. Use Intent.putExtra(DATA, string) where string is the email address.
-     */
-    public static final String EMAIL = "EMAIL_TYPE";
-
-    /**
-     * Use Intent.putExtra(DATA, string) where string is the phone number to call.
-     */
-    public static final String PHONE = "PHONE_TYPE";
-
-    /**
-     * An SMS type. Use Intent.putExtra(DATA, string) where string is the number to SMS.
-     */
-    public static final String SMS = "SMS_TYPE";
-
-    /**
-     * A contact. Send a request to encode it as follows:
-     * {@code
-     * import android.provider.Contacts;
-     *
-     * Intent intent = new Intent(Intents.Encode.ACTION);
-     * intent.putExtra(Intents.Encode.TYPE, CONTACT);
-     * Bundle bundle = new Bundle();
-     * bundle.putString(ContactsContract.Intents.Insert.NAME, "Jenny");
-     * bundle.putString(ContactsContract.Intents.Insert.PHONE, "8675309");
-     * bundle.putString(ContactsContract.Intents.Insert.EMAIL, "jenny@the80s.com");
-     * bundle.putString(ContactsContract.Intents.Insert.POSTAL, "123 Fake St. San Francisco, CA 94102");
-     * intent.putExtra(Intents.Encode.DATA, bundle);
-     * }
-     */
-    public static final String CONTACT = "CONTACT_TYPE";
-
-    /**
-     * A geographic location. Use as follows:
-     * Bundle bundle = new Bundle();
-     * bundle.putFloat("LAT", latitude);
-     * bundle.putFloat("LONG", longitude);
-     * intent.putExtra(Intents.Encode.DATA, bundle);
-     */
-    public static final String LOCATION = "LOCATION_TYPE";
-
-    private Type() {
-    }
-  }
-
-  public static final String URL_KEY = "URL_KEY";
-
-  public static final String NOTE_KEY = "NOTE_KEY";
-
-  /**
-   * When using Type.CONTACT, these arrays provide the keys for adding or retrieving multiple
-   * phone numbers and addresses.
-   */
-  public static final String[] PHONE_KEYS = {
-      ContactsContract.Intents.Insert.PHONE,
-      ContactsContract.Intents.Insert.SECONDARY_PHONE,
-      ContactsContract.Intents.Insert.TERTIARY_PHONE
-  };
-
-  public static final String[] PHONE_TYPE_KEYS = {
-      ContactsContract.Intents.Insert.PHONE_TYPE,
-      ContactsContract.Intents.Insert.SECONDARY_PHONE_TYPE,
-      ContactsContract.Intents.Insert.TERTIARY_PHONE_TYPE
-  };
-
-  public static final String[] EMAIL_KEYS = {
-      ContactsContract.Intents.Insert.EMAIL,
-      ContactsContract.Intents.Insert.SECONDARY_EMAIL,
-      ContactsContract.Intents.Insert.TERTIARY_EMAIL
-  };
-
-  public static final String[] EMAIL_TYPE_KEYS = {
-      ContactsContract.Intents.Insert.EMAIL_TYPE,
-      ContactsContract.Intents.Insert.SECONDARY_EMAIL_TYPE,
-      ContactsContract.Intents.Insert.TERTIARY_EMAIL_TYPE
-  };
-
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.provider.ContactsContract;
+
+/**
+ * The set of constants to use when sending Barcode Scanner an Intent which requests a barcode
+ * to be encoded.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class Contents {
+  private Contents() {
+  }
+
+  /**
+   * Contains type constants used when sending Intents.
+   */
+  public static final class Type {
+    /**
+     * Plain text. Use Intent.putExtra(DATA, string). This can be used for URLs too, but string
+     * must include "http://" or "https://".
+     */
+    public static final String TEXT = "TEXT_TYPE";
+
+    /**
+     * An email type. Use Intent.putExtra(DATA, string) where string is the email address.
+     */
+    public static final String EMAIL = "EMAIL_TYPE";
+
+    /**
+     * Use Intent.putExtra(DATA, string) where string is the phone number to call.
+     */
+    public static final String PHONE = "PHONE_TYPE";
+
+    /**
+     * An SMS type. Use Intent.putExtra(DATA, string) where string is the number to SMS.
+     */
+    public static final String SMS = "SMS_TYPE";
+
+    /**
+     * A contact. Send a request to encode it as follows:
+     * {@code
+     * import android.provider.Contacts;
+     *
+     * Intent intent = new Intent(Intents.Encode.ACTION);
+     * intent.putExtra(Intents.Encode.TYPE, CONTACT);
+     * Bundle bundle = new Bundle();
+     * bundle.putString(ContactsContract.Intents.Insert.NAME, "Jenny");
+     * bundle.putString(ContactsContract.Intents.Insert.PHONE, "8675309");
+     * bundle.putString(ContactsContract.Intents.Insert.EMAIL, "jenny@the80s.com");
+     * bundle.putString(ContactsContract.Intents.Insert.POSTAL, "123 Fake St. San Francisco, CA 94102");
+     * intent.putExtra(Intents.Encode.DATA, bundle);
+     * }
+     */
+    public static final String CONTACT = "CONTACT_TYPE";
+
+    /**
+     * A geographic location. Use as follows:
+     * Bundle bundle = new Bundle();
+     * bundle.putFloat("LAT", latitude);
+     * bundle.putFloat("LONG", longitude);
+     * intent.putExtra(Intents.Encode.DATA, bundle);
+     */
+    public static final String LOCATION = "LOCATION_TYPE";
+
+    private Type() {
+    }
+  }
+
+  public static final String URL_KEY = "URL_KEY";
+
+  public static final String NOTE_KEY = "NOTE_KEY";
+
+  /**
+   * When using Type.CONTACT, these arrays provide the keys for adding or retrieving multiple
+   * phone numbers and addresses.
+   */
+  public static final String[] PHONE_KEYS = {
+      ContactsContract.Intents.Insert.PHONE,
+      ContactsContract.Intents.Insert.SECONDARY_PHONE,
+      ContactsContract.Intents.Insert.TERTIARY_PHONE
+  };
+
+  public static final String[] PHONE_TYPE_KEYS = {
+      ContactsContract.Intents.Insert.PHONE_TYPE,
+      ContactsContract.Intents.Insert.SECONDARY_PHONE_TYPE,
+      ContactsContract.Intents.Insert.TERTIARY_PHONE_TYPE
+  };
+
+  public static final String[] EMAIL_KEYS = {
+      ContactsContract.Intents.Insert.EMAIL,
+      ContactsContract.Intents.Insert.SECONDARY_EMAIL,
+      ContactsContract.Intents.Insert.TERTIARY_EMAIL
+  };
+
+  public static final String[] EMAIL_TYPE_KEYS = {
+      ContactsContract.Intents.Insert.EMAIL_TYPE,
+      ContactsContract.Intents.Insert.SECONDARY_EMAIL_TYPE,
+      ContactsContract.Intents.Insert.TERTIARY_EMAIL_TYPE
+  };
+
+}
diff --git a/src/com/android/contacts/util/barcode/DecodeFormatManager.java b/src/com/android/contacts/util/barcode/DecodeFormatManager.java
index 70f7aea..6a382d5 100644
--- a/src/com/android/contacts/util/barcode/DecodeFormatManager.java
+++ b/src/com/android/contacts/util/barcode/DecodeFormatManager.java
@@ -1,106 +1,106 @@
-/*
- * Copyright (C) 2010 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.content.Intent;
-import android.net.Uri;
-
-import com.google.zxing.BarcodeFormat;
-
-import java.util.Arrays;
-import java.util.EnumSet;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Pattern;
-
-final class DecodeFormatManager {
-
-  private static final Pattern COMMA_PATTERN = Pattern.compile(",");
-
-  static final Set<BarcodeFormat> PRODUCT_FORMATS;
-  static final Set<BarcodeFormat> INDUSTRIAL_FORMATS;
-  private static final Set<BarcodeFormat> ONE_D_FORMATS;
-  static final Set<BarcodeFormat> QR_CODE_FORMATS = EnumSet.of(BarcodeFormat.QR_CODE);
-  static final Set<BarcodeFormat> DATA_MATRIX_FORMATS = EnumSet.of(BarcodeFormat.DATA_MATRIX);
-  static final Set<BarcodeFormat> AZTEC_FORMATS = EnumSet.of(BarcodeFormat.AZTEC);
-  static final Set<BarcodeFormat> PDF417_FORMATS = EnumSet.of(BarcodeFormat.PDF_417);
-  static {
-    PRODUCT_FORMATS = EnumSet.of(BarcodeFormat.UPC_A,
-                                 BarcodeFormat.UPC_E,
-                                 BarcodeFormat.EAN_13,
-                                 BarcodeFormat.EAN_8,
-                                 BarcodeFormat.RSS_14,
-                                 BarcodeFormat.RSS_EXPANDED);
-    INDUSTRIAL_FORMATS = EnumSet.of(BarcodeFormat.CODE_39,
-                                    BarcodeFormat.CODE_93,
-                                    BarcodeFormat.CODE_128,
-                                    BarcodeFormat.ITF,
-                                    BarcodeFormat.CODABAR);
-    ONE_D_FORMATS = EnumSet.copyOf(PRODUCT_FORMATS);
-    ONE_D_FORMATS.addAll(INDUSTRIAL_FORMATS);
-  }
-  private static final Map<String,Set<BarcodeFormat>> FORMATS_FOR_MODE;
-  static {
-    FORMATS_FOR_MODE = new HashMap<>();
-    FORMATS_FOR_MODE.put(Intents.Scan.ONE_D_MODE, ONE_D_FORMATS);
-    FORMATS_FOR_MODE.put(Intents.Scan.PRODUCT_MODE, PRODUCT_FORMATS);
-    FORMATS_FOR_MODE.put(Intents.Scan.QR_CODE_MODE, QR_CODE_FORMATS);
-    FORMATS_FOR_MODE.put(Intents.Scan.DATA_MATRIX_MODE, DATA_MATRIX_FORMATS);
-    FORMATS_FOR_MODE.put(Intents.Scan.AZTEC_MODE, AZTEC_FORMATS);
-    FORMATS_FOR_MODE.put(Intents.Scan.PDF417_MODE, PDF417_FORMATS);
-  }
-
-  private DecodeFormatManager() {}
-
-  static Set<BarcodeFormat> parseDecodeFormats(Intent intent) {
-    Iterable<String> scanFormats = null;
-    CharSequence scanFormatsString = intent.getStringExtra(Intents.Scan.FORMATS);
-    if (scanFormatsString != null) {
-      scanFormats = Arrays.asList(COMMA_PATTERN.split(scanFormatsString));
-    }
-    return parseDecodeFormats(scanFormats, intent.getStringExtra(Intents.Scan.MODE));
-  }
-
-  static Set<BarcodeFormat> parseDecodeFormats(Uri inputUri) {
-    List<String> formats = inputUri.getQueryParameters(Intents.Scan.FORMATS);
-    if (formats != null && formats.size() == 1 && formats.get(0) != null) {
-      formats = Arrays.asList(COMMA_PATTERN.split(formats.get(0)));
-    }
-    return parseDecodeFormats(formats, inputUri.getQueryParameter(Intents.Scan.MODE));
-  }
-
-  private static Set<BarcodeFormat> parseDecodeFormats(Iterable<String> scanFormats, String decodeMode) {
-    if (scanFormats != null) {
-      Set<BarcodeFormat> formats = EnumSet.noneOf(BarcodeFormat.class);
-      try {
-        for (String format : scanFormats) {
-          formats.add(BarcodeFormat.valueOf(format));
-        }
-        return formats;
-      } catch (IllegalArgumentException iae) {
-        // ignore it then
-      }
-    }
-    if (decodeMode != null) {
-      return FORMATS_FOR_MODE.get(decodeMode);
-    }
-    return null;
-  }
-
-}
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.content.Intent;
+import android.net.Uri;
+
+import com.google.zxing.BarcodeFormat;
+
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+final class DecodeFormatManager {
+
+  private static final Pattern COMMA_PATTERN = Pattern.compile(",");
+
+  static final Set<BarcodeFormat> PRODUCT_FORMATS;
+  static final Set<BarcodeFormat> INDUSTRIAL_FORMATS;
+  private static final Set<BarcodeFormat> ONE_D_FORMATS;
+  static final Set<BarcodeFormat> QR_CODE_FORMATS = EnumSet.of(BarcodeFormat.QR_CODE);
+  static final Set<BarcodeFormat> DATA_MATRIX_FORMATS = EnumSet.of(BarcodeFormat.DATA_MATRIX);
+  static final Set<BarcodeFormat> AZTEC_FORMATS = EnumSet.of(BarcodeFormat.AZTEC);
+  static final Set<BarcodeFormat> PDF417_FORMATS = EnumSet.of(BarcodeFormat.PDF_417);
+  static {
+    PRODUCT_FORMATS = EnumSet.of(BarcodeFormat.UPC_A,
+                                 BarcodeFormat.UPC_E,
+                                 BarcodeFormat.EAN_13,
+                                 BarcodeFormat.EAN_8,
+                                 BarcodeFormat.RSS_14,
+                                 BarcodeFormat.RSS_EXPANDED);
+    INDUSTRIAL_FORMATS = EnumSet.of(BarcodeFormat.CODE_39,
+                                    BarcodeFormat.CODE_93,
+                                    BarcodeFormat.CODE_128,
+                                    BarcodeFormat.ITF,
+                                    BarcodeFormat.CODABAR);
+    ONE_D_FORMATS = EnumSet.copyOf(PRODUCT_FORMATS);
+    ONE_D_FORMATS.addAll(INDUSTRIAL_FORMATS);
+  }
+  private static final Map<String,Set<BarcodeFormat>> FORMATS_FOR_MODE;
+  static {
+    FORMATS_FOR_MODE = new HashMap<>();
+    FORMATS_FOR_MODE.put(Intents.Scan.ONE_D_MODE, ONE_D_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.PRODUCT_MODE, PRODUCT_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.QR_CODE_MODE, QR_CODE_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.DATA_MATRIX_MODE, DATA_MATRIX_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.AZTEC_MODE, AZTEC_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.PDF417_MODE, PDF417_FORMATS);
+  }
+
+  private DecodeFormatManager() {}
+
+  static Set<BarcodeFormat> parseDecodeFormats(Intent intent) {
+    Iterable<String> scanFormats = null;
+    CharSequence scanFormatsString = intent.getStringExtra(Intents.Scan.FORMATS);
+    if (scanFormatsString != null) {
+      scanFormats = Arrays.asList(COMMA_PATTERN.split(scanFormatsString));
+    }
+    return parseDecodeFormats(scanFormats, intent.getStringExtra(Intents.Scan.MODE));
+  }
+
+  static Set<BarcodeFormat> parseDecodeFormats(Uri inputUri) {
+    List<String> formats = inputUri.getQueryParameters(Intents.Scan.FORMATS);
+    if (formats != null && formats.size() == 1 && formats.get(0) != null) {
+      formats = Arrays.asList(COMMA_PATTERN.split(formats.get(0)));
+    }
+    return parseDecodeFormats(formats, inputUri.getQueryParameter(Intents.Scan.MODE));
+  }
+
+  private static Set<BarcodeFormat> parseDecodeFormats(Iterable<String> scanFormats, String decodeMode) {
+    if (scanFormats != null) {
+      Set<BarcodeFormat> formats = EnumSet.noneOf(BarcodeFormat.class);
+      try {
+        for (String format : scanFormats) {
+          formats.add(BarcodeFormat.valueOf(format));
+        }
+        return formats;
+      } catch (IllegalArgumentException iae) {
+        // ignore it then
+      }
+    }
+    if (decodeMode != null) {
+      return FORMATS_FOR_MODE.get(decodeMode);
+    }
+    return null;
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/DecodeHandler.java b/src/com/android/contacts/util/barcode/DecodeHandler.java
index eceafe6..1143ff5 100644
--- a/src/com/android/contacts/util/barcode/DecodeHandler.java
+++ b/src/com/android/contacts/util/barcode/DecodeHandler.java
@@ -1,129 +1,129 @@
-/*
- * Copyright (C) 2010 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.graphics.Bitmap;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.util.Log;
-
-import com.google.zxing.BinaryBitmap;
-import com.google.zxing.DecodeHintType;
-import com.google.zxing.MultiFormatReader;
-import com.google.zxing.PlanarYUVLuminanceSource;
-import com.google.zxing.ReaderException;
-import com.google.zxing.Result;
-import com.google.zxing.common.HybridBinarizer;
-
-import java.io.ByteArrayOutputStream;
-import java.util.Map;
-
-import com.android.contacts.R;
-
-final class DecodeHandler extends Handler {
-
-    private static final String TAG = DecodeHandler.class.getSimpleName();
-
-    private final CaptureActivity activity;
-    private final MultiFormatReader multiFormatReader;
-    private boolean running = true;
-
-    DecodeHandler(CaptureActivity activity, Map<DecodeHintType, Object> hints) {
-        multiFormatReader = new MultiFormatReader();
-        multiFormatReader.setHints(hints);
-        this.activity = activity;
-    }
-
-    @Override
-    public void handleMessage(Message message) {
-        if (!running) {
-            return;
-        }
-        switch (message.what) {
-            case R.id.decode:
-                decode((byte[]) message.obj, message.arg1, message.arg2);
-                break;
-
-            case R.id.quit:
-                running = false;
-                Looper.myLooper().quit();
-                break;
-        }
-    }
-
-    /**
-     * Decode the data within the viewfinder rectangle, and time how long it took. For efficiency,
-     * reuse the same reader objects from one decode to the next.
-     *
-     * @param data   The YUV preview frame.
-     * @param width  The width of the preview frame.
-     * @param height The height of the preview frame.
-     */
-    private void decode(byte[] data, int width, int height) {
-        long start = System.currentTimeMillis();
-        Result rawResult = null;
-
-        // 构造基于平面的YUV亮度源，即包含二维码区域的数据源
-        PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);
-        if (source != null) {
-            // 构造二值图像比特流，使用HybridBinarizer算法解析数据源
-            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));
-            try {
-                // 采用MultiFormatReader解析图像，可以解析多种数据格式
-                rawResult = multiFormatReader.decodeWithState(bitmap);
-            } catch (ReaderException re) {
-                // continue
-            } finally {
-                multiFormatReader.reset();
-            }
-        }
-
-        // Hanlder处理解析失败或成功的结果
-        Handler handler = activity.getHandler();
-        if (rawResult != null) {
-            // Don't log the barcode contents for security.
-            long end = System.currentTimeMillis();
-            Log.d(TAG, "Found barcode in " + (end - start) + " ms");
-            if (handler != null) {
-                Message message = Message.obtain(handler, R.id.decode_succeeded, rawResult);
-                Bundle bundle = new Bundle();
-                bundleThumbnail(source, bundle);
-                message.setData(bundle);
-                message.sendToTarget();
-            }
-        } else {
-            if (handler != null) {
-                Message message = Message.obtain(handler, R.id.decode_failed);
-                message.sendToTarget();
-            }
-        }
-    }
-
-    private static void bundleThumbnail(PlanarYUVLuminanceSource source, Bundle bundle) {
-        int[] pixels = source.renderThumbnail();
-        int width = source.getThumbnailWidth();
-        int height = source.getThumbnailHeight();
-        Bitmap bitmap = Bitmap.createBitmap(pixels, 0, width, width, height, Bitmap.Config.ARGB_8888);
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        bitmap.compress(Bitmap.CompressFormat.JPEG, 50, out);
-        bundle.putByteArray(DecodeThread.BARCODE_BITMAP, out.toByteArray());
-        bundle.putFloat(DecodeThread.BARCODE_SCALED_FACTOR, (float) width / source.getWidth());
-    }
-
-}
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.graphics.Bitmap;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.util.Log;
+
+import com.google.zxing.BinaryBitmap;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.MultiFormatReader;
+import com.google.zxing.PlanarYUVLuminanceSource;
+import com.google.zxing.ReaderException;
+import com.google.zxing.Result;
+import com.google.zxing.common.HybridBinarizer;
+
+import java.io.ByteArrayOutputStream;
+import java.util.Map;
+
+import com.android.contacts.R;
+
+final class DecodeHandler extends Handler {
+
+    private static final String TAG = DecodeHandler.class.getSimpleName();
+
+    private final CaptureActivity activity;
+    private final MultiFormatReader multiFormatReader;
+    private boolean running = true;
+
+    DecodeHandler(CaptureActivity activity, Map<DecodeHintType, Object> hints) {
+        multiFormatReader = new MultiFormatReader();
+        multiFormatReader.setHints(hints);
+        this.activity = activity;
+    }
+
+    @Override
+    public void handleMessage(Message message) {
+        if (!running) {
+            return;
+        }
+        switch (message.what) {
+            case R.id.decode:
+                decode((byte[]) message.obj, message.arg1, message.arg2);
+                break;
+
+            case R.id.quit:
+                running = false;
+                Looper.myLooper().quit();
+                break;
+        }
+    }
+
+    /**
+     * Decode the data within the viewfinder rectangle, and time how long it took. For efficiency,
+     * reuse the same reader objects from one decode to the next.
+     *
+     * @param data   The YUV preview frame.
+     * @param width  The width of the preview frame.
+     * @param height The height of the preview frame.
+     */
+    private void decode(byte[] data, int width, int height) {
+        long start = System.currentTimeMillis();
+        Result rawResult = null;
+
+        // 构造基于平面的YUV亮度源，即包含二维码区域的数据源
+        PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);
+        if (source != null) {
+            // 构造二值图像比特流，使用HybridBinarizer算法解析数据源
+            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));
+            try {
+                // 采用MultiFormatReader解析图像，可以解析多种数据格式
+                rawResult = multiFormatReader.decodeWithState(bitmap);
+            } catch (ReaderException re) {
+                // continue
+            } finally {
+                multiFormatReader.reset();
+            }
+        }
+
+        // Hanlder处理解析失败或成功的结果
+        Handler handler = activity.getHandler();
+        if (rawResult != null) {
+            // Don't log the barcode contents for security.
+            long end = System.currentTimeMillis();
+            Log.d(TAG, "Found barcode in " + (end - start) + " ms");
+            if (handler != null) {
+                Message message = Message.obtain(handler, R.id.decode_succeeded, rawResult);
+                Bundle bundle = new Bundle();
+                bundleThumbnail(source, bundle);
+                message.setData(bundle);
+                message.sendToTarget();
+            }
+        } else {
+            if (handler != null) {
+                Message message = Message.obtain(handler, R.id.decode_failed);
+                message.sendToTarget();
+            }
+        }
+    }
+
+    private static void bundleThumbnail(PlanarYUVLuminanceSource source, Bundle bundle) {
+        int[] pixels = source.renderThumbnail();
+        int width = source.getThumbnailWidth();
+        int height = source.getThumbnailHeight();
+        Bitmap bitmap = Bitmap.createBitmap(pixels, 0, width, width, height, Bitmap.Config.ARGB_8888);
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        bitmap.compress(Bitmap.CompressFormat.JPEG, 50, out);
+        bundle.putByteArray(DecodeThread.BARCODE_BITMAP, out.toByteArray());
+        bundle.putFloat(DecodeThread.BARCODE_SCALED_FACTOR, (float) width / source.getWidth());
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/DecodeHintManager.java b/src/com/android/contacts/util/barcode/DecodeHintManager.java
index 1f297c6..0b7ddba 100644
--- a/src/com/android/contacts/util/barcode/DecodeHintManager.java
+++ b/src/com/android/contacts/util/barcode/DecodeHintManager.java
@@ -1,236 +1,236 @@
-/*
- * Copyright (C) 2013 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Bundle;
-import android.util.Log;
-
-import com.google.zxing.DecodeHintType;
-
-import java.util.EnumMap;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.regex.Pattern;
-
-/**
- * @author Lachezar Dobrev
- */
-final class DecodeHintManager {
-  
-  private static final String TAG = DecodeHintManager.class.getSimpleName();
-
-  // This pattern is used in decoding integer arrays.
-  private static final Pattern COMMA = Pattern.compile(",");
-
-  private DecodeHintManager() {}
-
-  /**
-   * <p>Split a query string into a list of name-value pairs.</p>
-   * 
-   * <p>This is an alternative to the {@link Uri#getQueryParameterNames()} and
-   * {@link Uri#getQueryParameters(String)}, which are quirky and not suitable
-   * for exist-only Uri parameters.</p>
-   * 
-   * <p>This method ignores multiple parameters with the same name and returns the
-   * first one only. This is technically incorrect, but should be acceptable due
-   * to the method of processing Hints: no multiple values for a hint.</p>
-   * 
-   * @param query query to split
-   * @return name-value pairs
-   */
-  private static Map<String,String> splitQuery(String query) {
-    Map<String,String> map = new HashMap<>();
-    int pos = 0;
-    while (pos < query.length()) {
-      if (query.charAt(pos) == '&') {
-        // Skip consecutive ampersand separators.
-        pos ++;
-        continue;
-      }
-      int amp = query.indexOf('&', pos);
-      int equ = query.indexOf('=', pos);
-      if (amp < 0) {
-        // This is the last element in the query, no more ampersand elements.
-        String name;
-        String text;
-        if (equ < 0) {
-          // No equal sign
-          name = query.substring(pos);
-          name = name.replace('+', ' '); // Preemptively decode +
-          name = Uri.decode(name);
-          text = "";
-        } else {
-          // Split name and text.
-          name = query.substring(pos, equ);
-          name = name.replace('+', ' '); // Preemptively decode +
-          name = Uri.decode(name);
-          text = query.substring(equ + 1);
-          text = text.replace('+', ' '); // Preemptively decode +
-          text = Uri.decode(text);
-        }
-        if (!map.containsKey(name)) {
-          map.put(name, text);
-        }
-        break;
-      }
-      if (equ < 0 || equ > amp) {
-        // No equal sign until the &: this is a simple parameter with no value.
-        String name = query.substring(pos, amp);
-        name = name.replace('+', ' '); // Preemptively decode +
-        name = Uri.decode(name);
-        if (!map.containsKey(name)) {
-          map.put(name, "");
-        }
-        pos = amp + 1;
-        continue;
-      }
-      String name = query.substring(pos, equ);
-      name = name.replace('+', ' '); // Preemptively decode +
-      name = Uri.decode(name);
-      String text = query.substring(equ + 1, amp);
-      text = text.replace('+', ' '); // Preemptively decode +
-      text = Uri.decode(text);
-      if (!map.containsKey(name)) {
-        map.put(name, text);
-      }
-      pos = amp + 1;
-    }
-    return map;
-  }
-
-  static Map<DecodeHintType,?> parseDecodeHints(Uri inputUri) {
-    String query = inputUri.getEncodedQuery();
-    if (query == null || query.isEmpty()) {
-      return null;
-    }
-
-    // Extract parameters
-    Map<String, String> parameters = splitQuery(query);
-
-    Map<DecodeHintType, Object> hints = new EnumMap<>(DecodeHintType.class);
-
-    for (DecodeHintType hintType: DecodeHintType.values()) {
-
-      if (hintType == DecodeHintType.CHARACTER_SET ||
-          hintType == DecodeHintType.NEED_RESULT_POINT_CALLBACK ||
-          hintType == DecodeHintType.POSSIBLE_FORMATS) {
-        continue; // This hint is specified in another way
-      }
-
-      String parameterName = hintType.name();
-      String parameterText = parameters.get(parameterName);
-      if (parameterText == null) {
-        continue;
-      }
-      if (hintType.getValueType().equals(Object.class)) {
-        // This is an unspecified type of hint content. Use the value as is.
-        // TODO: Can we make a different assumption on this?
-        hints.put(hintType, parameterText);
-        continue;
-      }
-      if (hintType.getValueType().equals(Void.class)) {
-        // Void hints are just flags: use the constant specified by DecodeHintType
-        hints.put(hintType, Boolean.TRUE);
-        continue;
-      }
-      if (hintType.getValueType().equals(String.class)) {
-        // A string hint: use the decoded value.
-        hints.put(hintType, parameterText);
-        continue;
-      }
-      if (hintType.getValueType().equals(Boolean.class)) {
-        // A boolean hint: a few values for false, everything else is true.
-        // An empty parameter is simply a flag-style parameter, assuming true
-        if (parameterText.isEmpty()) {
-          hints.put(hintType, Boolean.TRUE);
-        } else if ("0".equals(parameterText) || 
-                   "false".equalsIgnoreCase(parameterText) || 
-                   "no".equalsIgnoreCase(parameterText)) {
-          hints.put(hintType, Boolean.FALSE);
-        } else {
-          hints.put(hintType, Boolean.TRUE);
-        }
-
-        continue;
-      }
-      if (hintType.getValueType().equals(int[].class)) {
-        // An integer array. Used to specify valid lengths.
-        // Strip a trailing comma as in Java style array initialisers.
-        if (!parameterText.isEmpty() && parameterText.charAt(parameterText.length() - 1) == ',') {
-          parameterText = parameterText.substring(0, parameterText.length() - 1);
-        }
-        String[] values = COMMA.split(parameterText);
-        int[] array = new int[values.length];
-        for (int i = 0; i < values.length; i++) {
-          try {
-            array[i] = Integer.parseInt(values[i]);
-          } catch (NumberFormatException ignored) {
-            Log.w(TAG, "Skipping array of integers hint " + hintType + " due to invalid numeric value: '" + values[i] + '\'');
-            array = null;
-            break;
-          }
-        }
-        if (array != null) {
-          hints.put(hintType, array);
-        }
-        continue;
-      } 
-      Log.w(TAG, "Unsupported hint type '" + hintType + "' of type " + hintType.getValueType());
-    }
-
-    Log.i(TAG, "Hints from the URI: " + hints);
-    return hints;
-  }
-
-  static Map<DecodeHintType, Object> parseDecodeHints(Intent intent) {
-    Bundle extras = intent.getExtras();
-    if (extras == null || extras.isEmpty()) {
-      return null;
-    }
-    Map<DecodeHintType,Object> hints = new EnumMap<>(DecodeHintType.class);
-
-    for (DecodeHintType hintType: DecodeHintType.values()) {
-
-      if (hintType == DecodeHintType.CHARACTER_SET ||
-          hintType == DecodeHintType.NEED_RESULT_POINT_CALLBACK ||
-          hintType == DecodeHintType.POSSIBLE_FORMATS) {
-        continue; // This hint is specified in another way
-      }
-
-      String hintName = hintType.name();
-      if (extras.containsKey(hintName)) {
-        if (hintType.getValueType().equals(Void.class)) {
-          // Void hints are just flags: use the constant specified by the DecodeHintType
-          hints.put(hintType, Boolean.TRUE);
-        } else {
-          Object hintData = extras.get(hintName);
-          if (hintType.getValueType().isInstance(hintData)) {
-            hints.put(hintType, hintData);
-          } else {
-            Log.w(TAG, "Ignoring hint " + hintType + " because it is not assignable from " + hintData);
-          }
-        }
-      }
-    }
-
-    Log.i(TAG, "Hints from the Intent: " + hints);
-    return hints;
-  }
-
-}
+/*
+ * Copyright (C) 2013 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.google.zxing.DecodeHintType;
+
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Pattern;
+
+/**
+ * @author Lachezar Dobrev
+ */
+final class DecodeHintManager {
+  
+  private static final String TAG = DecodeHintManager.class.getSimpleName();
+
+  // This pattern is used in decoding integer arrays.
+  private static final Pattern COMMA = Pattern.compile(",");
+
+  private DecodeHintManager() {}
+
+  /**
+   * <p>Split a query string into a list of name-value pairs.</p>
+   * 
+   * <p>This is an alternative to the {@link Uri#getQueryParameterNames()} and
+   * {@link Uri#getQueryParameters(String)}, which are quirky and not suitable
+   * for exist-only Uri parameters.</p>
+   * 
+   * <p>This method ignores multiple parameters with the same name and returns the
+   * first one only. This is technically incorrect, but should be acceptable due
+   * to the method of processing Hints: no multiple values for a hint.</p>
+   * 
+   * @param query query to split
+   * @return name-value pairs
+   */
+  private static Map<String,String> splitQuery(String query) {
+    Map<String,String> map = new HashMap<>();
+    int pos = 0;
+    while (pos < query.length()) {
+      if (query.charAt(pos) == '&') {
+        // Skip consecutive ampersand separators.
+        pos ++;
+        continue;
+      }
+      int amp = query.indexOf('&', pos);
+      int equ = query.indexOf('=', pos);
+      if (amp < 0) {
+        // This is the last element in the query, no more ampersand elements.
+        String name;
+        String text;
+        if (equ < 0) {
+          // No equal sign
+          name = query.substring(pos);
+          name = name.replace('+', ' '); // Preemptively decode +
+          name = Uri.decode(name);
+          text = "";
+        } else {
+          // Split name and text.
+          name = query.substring(pos, equ);
+          name = name.replace('+', ' '); // Preemptively decode +
+          name = Uri.decode(name);
+          text = query.substring(equ + 1);
+          text = text.replace('+', ' '); // Preemptively decode +
+          text = Uri.decode(text);
+        }
+        if (!map.containsKey(name)) {
+          map.put(name, text);
+        }
+        break;
+      }
+      if (equ < 0 || equ > amp) {
+        // No equal sign until the &: this is a simple parameter with no value.
+        String name = query.substring(pos, amp);
+        name = name.replace('+', ' '); // Preemptively decode +
+        name = Uri.decode(name);
+        if (!map.containsKey(name)) {
+          map.put(name, "");
+        }
+        pos = amp + 1;
+        continue;
+      }
+      String name = query.substring(pos, equ);
+      name = name.replace('+', ' '); // Preemptively decode +
+      name = Uri.decode(name);
+      String text = query.substring(equ + 1, amp);
+      text = text.replace('+', ' '); // Preemptively decode +
+      text = Uri.decode(text);
+      if (!map.containsKey(name)) {
+        map.put(name, text);
+      }
+      pos = amp + 1;
+    }
+    return map;
+  }
+
+  static Map<DecodeHintType,?> parseDecodeHints(Uri inputUri) {
+    String query = inputUri.getEncodedQuery();
+    if (query == null || query.isEmpty()) {
+      return null;
+    }
+
+    // Extract parameters
+    Map<String, String> parameters = splitQuery(query);
+
+    Map<DecodeHintType, Object> hints = new EnumMap<>(DecodeHintType.class);
+
+    for (DecodeHintType hintType: DecodeHintType.values()) {
+
+      if (hintType == DecodeHintType.CHARACTER_SET ||
+          hintType == DecodeHintType.NEED_RESULT_POINT_CALLBACK ||
+          hintType == DecodeHintType.POSSIBLE_FORMATS) {
+        continue; // This hint is specified in another way
+      }
+
+      String parameterName = hintType.name();
+      String parameterText = parameters.get(parameterName);
+      if (parameterText == null) {
+        continue;
+      }
+      if (hintType.getValueType().equals(Object.class)) {
+        // This is an unspecified type of hint content. Use the value as is.
+        // TODO: Can we make a different assumption on this?
+        hints.put(hintType, parameterText);
+        continue;
+      }
+      if (hintType.getValueType().equals(Void.class)) {
+        // Void hints are just flags: use the constant specified by DecodeHintType
+        hints.put(hintType, Boolean.TRUE);
+        continue;
+      }
+      if (hintType.getValueType().equals(String.class)) {
+        // A string hint: use the decoded value.
+        hints.put(hintType, parameterText);
+        continue;
+      }
+      if (hintType.getValueType().equals(Boolean.class)) {
+        // A boolean hint: a few values for false, everything else is true.
+        // An empty parameter is simply a flag-style parameter, assuming true
+        if (parameterText.isEmpty()) {
+          hints.put(hintType, Boolean.TRUE);
+        } else if ("0".equals(parameterText) || 
+                   "false".equalsIgnoreCase(parameterText) || 
+                   "no".equalsIgnoreCase(parameterText)) {
+          hints.put(hintType, Boolean.FALSE);
+        } else {
+          hints.put(hintType, Boolean.TRUE);
+        }
+
+        continue;
+      }
+      if (hintType.getValueType().equals(int[].class)) {
+        // An integer array. Used to specify valid lengths.
+        // Strip a trailing comma as in Java style array initialisers.
+        if (!parameterText.isEmpty() && parameterText.charAt(parameterText.length() - 1) == ',') {
+          parameterText = parameterText.substring(0, parameterText.length() - 1);
+        }
+        String[] values = COMMA.split(parameterText);
+        int[] array = new int[values.length];
+        for (int i = 0; i < values.length; i++) {
+          try {
+            array[i] = Integer.parseInt(values[i]);
+          } catch (NumberFormatException ignored) {
+            Log.w(TAG, "Skipping array of integers hint " + hintType + " due to invalid numeric value: '" + values[i] + '\'');
+            array = null;
+            break;
+          }
+        }
+        if (array != null) {
+          hints.put(hintType, array);
+        }
+        continue;
+      } 
+      Log.w(TAG, "Unsupported hint type '" + hintType + "' of type " + hintType.getValueType());
+    }
+
+    Log.i(TAG, "Hints from the URI: " + hints);
+    return hints;
+  }
+
+  static Map<DecodeHintType, Object> parseDecodeHints(Intent intent) {
+    Bundle extras = intent.getExtras();
+    if (extras == null || extras.isEmpty()) {
+      return null;
+    }
+    Map<DecodeHintType,Object> hints = new EnumMap<>(DecodeHintType.class);
+
+    for (DecodeHintType hintType: DecodeHintType.values()) {
+
+      if (hintType == DecodeHintType.CHARACTER_SET ||
+          hintType == DecodeHintType.NEED_RESULT_POINT_CALLBACK ||
+          hintType == DecodeHintType.POSSIBLE_FORMATS) {
+        continue; // This hint is specified in another way
+      }
+
+      String hintName = hintType.name();
+      if (extras.containsKey(hintName)) {
+        if (hintType.getValueType().equals(Void.class)) {
+          // Void hints are just flags: use the constant specified by the DecodeHintType
+          hints.put(hintType, Boolean.TRUE);
+        } else {
+          Object hintData = extras.get(hintName);
+          if (hintType.getValueType().isInstance(hintData)) {
+            hints.put(hintType, hintData);
+          } else {
+            Log.w(TAG, "Ignoring hint " + hintType + " because it is not assignable from " + hintData);
+          }
+        }
+      }
+    }
+
+    Log.i(TAG, "Hints from the Intent: " + hints);
+    return hints;
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/DecodeThread.java b/src/com/android/contacts/util/barcode/DecodeThread.java
index 376902f..eb1e888 100644
--- a/src/com/android/contacts/util/barcode/DecodeThread.java
+++ b/src/com/android/contacts/util/barcode/DecodeThread.java
@@ -1,113 +1,113 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.content.SharedPreferences;
-import android.os.Handler;
-import android.os.Looper;
-import android.preference.PreferenceManager;
-import android.util.Log;
-
-import com.google.zxing.BarcodeFormat;
-import com.google.zxing.DecodeHintType;
-import com.google.zxing.ResultPointCallback;
-
-import java.util.Collection;
-import java.util.EnumMap;
-import java.util.EnumSet;
-import java.util.Map;
-import java.util.concurrent.CountDownLatch;
-
-/**
- * This thread does all the heavy lifting of decoding the images.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-final class DecodeThread extends Thread {
-
-    public static final String BARCODE_BITMAP = "barcode_bitmap";
-    public static final String BARCODE_SCALED_FACTOR = "barcode_scaled_factor";
-
-    private final CaptureActivity activity;
-    private final Map<DecodeHintType, Object> hints;
-    private Handler handler;
-    private final CountDownLatch handlerInitLatch;
-
-    DecodeThread(CaptureActivity activity,
-                 Collection<BarcodeFormat> decodeFormats,
-                 Map<DecodeHintType, ?> baseHints,
-                 String characterSet,
-                 ResultPointCallback resultPointCallback) {
-
-        this.activity = activity;
-        handlerInitLatch = new CountDownLatch(1);
-
-        hints = new EnumMap<>(DecodeHintType.class);
-        if (baseHints != null) {
-            hints.putAll(baseHints);
-        }
-
-        // The prefs can't change while the thread is running, so pick them up once here.
-        if (decodeFormats == null || decodeFormats.isEmpty()) {
-            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
-            decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
-
-            // 一维码: 商品
-            decodeFormats.addAll(DecodeFormatManager.PRODUCT_FORMATS);
-
-            // 一维码: 工业
-            decodeFormats.addAll(DecodeFormatManager.INDUSTRIAL_FORMATS);
-
-            // 二维码
-            decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);
-
-            // Data Matrix
-            decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);
-
-            // Aztec
-            decodeFormats.addAll(DecodeFormatManager.AZTEC_FORMATS);
-
-            // PDF417
-            decodeFormats.addAll(DecodeFormatManager.PDF417_FORMATS);
-        }
-        hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
-
-        if (characterSet != null) {
-            hints.put(DecodeHintType.CHARACTER_SET, characterSet);
-        }
-        hints.put(DecodeHintType.NEED_RESULT_POINT_CALLBACK, resultPointCallback);
-        Log.i("DecodeThread", "Hints: " + hints);
-    }
-
-    Handler getHandler() {
-        try {
-            handlerInitLatch.await();
-        } catch (InterruptedException ie) {
-            // continue?
-        }
-        return handler;
-    }
-
-    @Override
-    public void run() {
-        Looper.prepare();
-        handler = new DecodeHandler(activity, hints);
-        handlerInitLatch.countDown();
-        Looper.loop();
-    }
-
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.content.SharedPreferences;
+import android.os.Handler;
+import android.os.Looper;
+import android.preference.PreferenceManager;
+import android.util.Log;
+
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.ResultPointCallback;
+
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * This thread does all the heavy lifting of decoding the images.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+final class DecodeThread extends Thread {
+
+    public static final String BARCODE_BITMAP = "barcode_bitmap";
+    public static final String BARCODE_SCALED_FACTOR = "barcode_scaled_factor";
+
+    private final CaptureActivity activity;
+    private final Map<DecodeHintType, Object> hints;
+    private Handler handler;
+    private final CountDownLatch handlerInitLatch;
+
+    DecodeThread(CaptureActivity activity,
+                 Collection<BarcodeFormat> decodeFormats,
+                 Map<DecodeHintType, ?> baseHints,
+                 String characterSet,
+                 ResultPointCallback resultPointCallback) {
+
+        this.activity = activity;
+        handlerInitLatch = new CountDownLatch(1);
+
+        hints = new EnumMap<>(DecodeHintType.class);
+        if (baseHints != null) {
+            hints.putAll(baseHints);
+        }
+
+        // The prefs can't change while the thread is running, so pick them up once here.
+        if (decodeFormats == null || decodeFormats.isEmpty()) {
+            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
+            decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
+
+            // 一维码: 商品
+            decodeFormats.addAll(DecodeFormatManager.PRODUCT_FORMATS);
+
+            // 一维码: 工业
+            decodeFormats.addAll(DecodeFormatManager.INDUSTRIAL_FORMATS);
+
+            // 二维码
+            decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);
+
+            // Data Matrix
+            decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);
+
+            // Aztec
+            decodeFormats.addAll(DecodeFormatManager.AZTEC_FORMATS);
+
+            // PDF417
+            decodeFormats.addAll(DecodeFormatManager.PDF417_FORMATS);
+        }
+        hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
+
+        if (characterSet != null) {
+            hints.put(DecodeHintType.CHARACTER_SET, characterSet);
+        }
+        hints.put(DecodeHintType.NEED_RESULT_POINT_CALLBACK, resultPointCallback);
+        Log.i("DecodeThread", "Hints: " + hints);
+    }
+
+    Handler getHandler() {
+        try {
+            handlerInitLatch.await();
+        } catch (InterruptedException ie) {
+            // continue?
+        }
+        return handler;
+    }
+
+    @Override
+    public void run() {
+        Looper.prepare();
+        handler = new DecodeHandler(activity, hints);
+        handlerInitLatch.countDown();
+        Looper.loop();
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/FinishListener.java b/src/com/android/contacts/util/barcode/FinishListener.java
index 40a9766..835fa23 100644
--- a/src/com/android/contacts/util/barcode/FinishListener.java
+++ b/src/com/android/contacts/util/barcode/FinishListener.java
@@ -1,49 +1,49 @@
-/*
- * Copyright (C) 2010 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.app.Activity;
-import android.content.DialogInterface;
-
-/**
- * Simple listener used to exit the app in a few cases.
- *
- * @author Sean Owen
- */
-public final class FinishListener implements DialogInterface.OnClickListener, DialogInterface.OnCancelListener {
-
-  private final Activity activityToFinish;
-
-  public FinishListener(Activity activityToFinish) {
-    this.activityToFinish = activityToFinish;
-  }
-
-  @Override
-  public void onCancel(DialogInterface dialogInterface) {
-    run();
-  }
-
-  @Override
-  public void onClick(DialogInterface dialogInterface, int i) {
-    run();
-  }
-
-  private void run() {
-    activityToFinish.finish();
-  }
-
-}
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.app.Activity;
+import android.content.DialogInterface;
+
+/**
+ * Simple listener used to exit the app in a few cases.
+ *
+ * @author Sean Owen
+ */
+public final class FinishListener implements DialogInterface.OnClickListener, DialogInterface.OnCancelListener {
+
+  private final Activity activityToFinish;
+
+  public FinishListener(Activity activityToFinish) {
+    this.activityToFinish = activityToFinish;
+  }
+
+  @Override
+  public void onCancel(DialogInterface dialogInterface) {
+    run();
+  }
+
+  @Override
+  public void onClick(DialogInterface dialogInterface, int i) {
+    run();
+  }
+
+  private void run() {
+    activityToFinish.finish();
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/Intents.java b/src/com/android/contacts/util/barcode/Intents.java
index 23625de..2993a95 100644
--- a/src/com/android/contacts/util/barcode/Intents.java
+++ b/src/com/android/contacts/util/barcode/Intents.java
@@ -1,231 +1,231 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-/**
- * This class provides the constants to use when sending an Intent to Barcode Scanner.
- * These strings are effectively API and cannot be changed.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class Intents {
-  private Intents() {
-  }
-
-  /**
-   * Constants related to the {@link Scan#ACTION} Intent.
-   */
-  public static final class Scan {
-    /**
-     * Send this intent to open the Barcodes app in scanning mode, find a barcode, and return
-     * the results.
-     */
-    public static final String ACTION = "com.njzhikejia.mabaojia.SCAN";
-
-    /**
-     * By default, sending this will decode all barcodes that we understand. However it
-     * may be useful to limit scanning to certain formats. Use
-     * {@link android.content.Intent#putExtra(String, String)} with one of the values below.
-     *
-     * Setting this is effectively shorthand for setting explicit formats with {@link #FORMATS}.
-     * It is overridden by that setting.
-     */
-    public static final String MODE = "SCAN_MODE";
-
-    /**
-     * Decode only UPC and EAN barcodes. This is the right choice for shopping apps which get
-     * prices, reviews, etc. for products.
-     */
-    public static final String PRODUCT_MODE = "PRODUCT_MODE";
-
-    /**
-     * Decode only 1D barcodes.
-     */
-    public static final String ONE_D_MODE = "ONE_D_MODE";
-
-    /**
-     * Decode only QR codes.
-     */
-    public static final String QR_CODE_MODE = "QR_CODE_MODE";
-
-    /**
-     * Decode only Data Matrix codes.
-     */
-    public static final String DATA_MATRIX_MODE = "DATA_MATRIX_MODE";
-
-    /**
-     * Decode only Aztec.
-     */
-    public static final String AZTEC_MODE = "AZTEC_MODE";
-
-    /**
-     * Decode only PDF417.
-     */
-    public static final String PDF417_MODE = "PDF417_MODE";
-
-    /**
-     * Comma-separated list of formats to scan for. The values must match the names of
-     * {@link com.google.zxing.BarcodeFormat}s, e.g. {@link com.google.zxing.BarcodeFormat#EAN_13}.
-     * Example: "EAN_13,EAN_8,QR_CODE". This overrides {@link #MODE}.
-     */
-    public static final String FORMATS = "SCAN_FORMATS";
-
-    /**
-     * Optional parameter to specify the id of the camera from which to recognize barcodes.
-     * Overrides the default camera that would otherwise would have been selected.
-     * If provided, should be an int.
-     */
-    public static final String CAMERA_ID = "SCAN_CAMERA_ID";
-
-    /**
-     * @see com.google.zxing.DecodeHintType#CHARACTER_SET
-     */
-    public static final String CHARACTER_SET = "CHARACTER_SET";
-
-    /**
-     * Optional parameters to specify the width and height of the scanning rectangle in pixels.
-     * The app will try to honor these, but will clamp them to the size of the preview frame.
-     * You should specify both or neither, and pass the size as an int.
-     */
-    public static final String WIDTH = "SCAN_WIDTH";
-    public static final String HEIGHT = "SCAN_HEIGHT";
-
-    /**
-     * Desired duration in milliseconds for which to pause after a successful scan before
-     * returning to the calling intent. Specified as a long, not an integer!
-     * For example: 1000L, not 1000.
-     */
-    public static final String RESULT_DISPLAY_DURATION_MS = "RESULT_DISPLAY_DURATION_MS";
-
-    /**
-     * Prompt to show on-screen when scanning by intent. Specified as a {@link String}.
-     */
-    public static final String PROMPT_MESSAGE = "PROMPT_MESSAGE";
-
-    /**
-     * If a barcode is found, Barcodes returns {@link android.app.Activity#RESULT_OK} to
-     * {@link android.app.Activity#onActivityResult(int, int, android.content.Intent)}
-     * of the app which requested the scan via
-     * {@link android.app.Activity#startActivityForResult(android.content.Intent, int)}
-     * The barcodes contents can be retrieved with
-     * {@link android.content.Intent#getStringExtra(String)}.
-     * If the user presses Back, the result code will be {@link android.app.Activity#RESULT_CANCELED}.
-     */
-    public static final String RESULT = "SCAN_RESULT";
-
-    /**
-     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_FORMAT}
-     * to determine which barcode format was found.
-     * See {@link com.google.zxing.BarcodeFormat} for possible values.
-     */
-    public static final String RESULT_FORMAT = "SCAN_RESULT_FORMAT";
-
-    /**
-     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_UPC_EAN_EXTENSION}
-     * to return the content of any UPC extension barcode that was also found. Only applicable
-     * to {@link com.google.zxing.BarcodeFormat#UPC_A} and {@link com.google.zxing.BarcodeFormat#EAN_13}
-     * formats.
-     */
-    public static final String RESULT_UPC_EAN_EXTENSION = "SCAN_RESULT_UPC_EAN_EXTENSION";
-
-    /**
-     * Call {@link android.content.Intent#getByteArrayExtra(String)} with {@link #RESULT_BYTES}
-     * to get a {@code byte[]} of raw bytes in the barcode, if available.
-     */
-    public static final String RESULT_BYTES = "SCAN_RESULT_BYTES";
-
-    /**
-     * Key for the value of {@link com.google.zxing.ResultMetadataType#ORIENTATION}, if available.
-     * Call {@link android.content.Intent#getIntArrayExtra(String)} with {@link #RESULT_ORIENTATION}.
-     */
-    public static final String RESULT_ORIENTATION = "SCAN_RESULT_ORIENTATION";
-
-    /**
-     * Key for the value of {@link com.google.zxing.ResultMetadataType#ERROR_CORRECTION_LEVEL}, if available.
-     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_ERROR_CORRECTION_LEVEL}.
-     */
-    public static final String RESULT_ERROR_CORRECTION_LEVEL = "SCAN_RESULT_ERROR_CORRECTION_LEVEL";
-
-    /**
-     * Prefix for keys that map to the values of {@link com.google.zxing.ResultMetadataType#BYTE_SEGMENTS},
-     * if available. The actual values will be set under a series of keys formed by adding 0, 1, 2, ...
-     * to this prefix. So the first byte segment is under key "SCAN_RESULT_BYTE_SEGMENTS_0" for example.
-     * Call {@link android.content.Intent#getByteArrayExtra(String)} with these keys.
-     */
-    public static final String RESULT_BYTE_SEGMENTS_PREFIX = "SCAN_RESULT_BYTE_SEGMENTS_";
-
-    /**
-     * Setting this to false will not save scanned codes in the history. Specified as a {@code boolean}.
-     */
-    public static final String SAVE_HISTORY = "SAVE_HISTORY";
-
-    private Scan() {
-    }
-  }
-
-  /**
-   * Constants related to the scan history and retrieving history items.
-   */
-  public static final class History {
-
-    public static final String ITEM_NUMBER = "ITEM_NUMBER";
-
-    private History() {
-    }
-  }
-
-  /**
-   * Constants related to the {@link Encode#ACTION} Intent.
-   */
-  public static final class Encode {
-    /**
-     * Send this intent to encode a piece of data as a QR code and display it full screen, so
-     * that another person can scan the barcode from your screen.
-     */
-    public static final String ACTION = "com.google.zxing.client.android.ENCODE";
-
-    /**
-     * The data to encode. Use {@link android.content.Intent#putExtra(String, String)} or
-     * {@link android.content.Intent#putExtra(String, android.os.Bundle)},
-     * depending on the type and format specified. Non-QR Code formats should
-     * just use a String here. For QR Code, see Contents for details.
-     */
-    public static final String DATA = "ENCODE_DATA";
-
-    /**
-     * The type of data being supplied if the format is QR Code. Use
-     * {@link android.content.Intent#putExtra(String, String)} with one of {@link Contents.Type}.
-     */
-    public static final String TYPE = "ENCODE_TYPE";
-
-    /**
-     * The barcode format to be displayed. If this isn't specified or is blank,
-     * it defaults to QR Code. Use {@link android.content.Intent#putExtra(String, String)}, where
-     * format is one of {@link com.google.zxing.BarcodeFormat}.
-     */
-    public static final String FORMAT = "ENCODE_FORMAT";
-
-    /**
-     * Normally the contents of the barcode are displayed to the user in a TextView. Setting this
-     * boolean to false will hide that TextView, showing only the encode barcode.
-     */
-    public static final String SHOW_CONTENTS = "ENCODE_SHOW_CONTENTS";
-
-    private Encode() {
-    }
-  }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+/**
+ * This class provides the constants to use when sending an Intent to Barcode Scanner.
+ * These strings are effectively API and cannot be changed.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class Intents {
+  private Intents() {
+  }
+
+  /**
+   * Constants related to the {@link Scan#ACTION} Intent.
+   */
+  public static final class Scan {
+    /**
+     * Send this intent to open the Barcodes app in scanning mode, find a barcode, and return
+     * the results.
+     */
+    public static final String ACTION = "com.njzhikejia.mabaojia.SCAN";
+
+    /**
+     * By default, sending this will decode all barcodes that we understand. However it
+     * may be useful to limit scanning to certain formats. Use
+     * {@link android.content.Intent#putExtra(String, String)} with one of the values below.
+     *
+     * Setting this is effectively shorthand for setting explicit formats with {@link #FORMATS}.
+     * It is overridden by that setting.
+     */
+    public static final String MODE = "SCAN_MODE";
+
+    /**
+     * Decode only UPC and EAN barcodes. This is the right choice for shopping apps which get
+     * prices, reviews, etc. for products.
+     */
+    public static final String PRODUCT_MODE = "PRODUCT_MODE";
+
+    /**
+     * Decode only 1D barcodes.
+     */
+    public static final String ONE_D_MODE = "ONE_D_MODE";
+
+    /**
+     * Decode only QR codes.
+     */
+    public static final String QR_CODE_MODE = "QR_CODE_MODE";
+
+    /**
+     * Decode only Data Matrix codes.
+     */
+    public static final String DATA_MATRIX_MODE = "DATA_MATRIX_MODE";
+
+    /**
+     * Decode only Aztec.
+     */
+    public static final String AZTEC_MODE = "AZTEC_MODE";
+
+    /**
+     * Decode only PDF417.
+     */
+    public static final String PDF417_MODE = "PDF417_MODE";
+
+    /**
+     * Comma-separated list of formats to scan for. The values must match the names of
+     * {@link com.google.zxing.BarcodeFormat}s, e.g. {@link com.google.zxing.BarcodeFormat#EAN_13}.
+     * Example: "EAN_13,EAN_8,QR_CODE". This overrides {@link #MODE}.
+     */
+    public static final String FORMATS = "SCAN_FORMATS";
+
+    /**
+     * Optional parameter to specify the id of the camera from which to recognize barcodes.
+     * Overrides the default camera that would otherwise would have been selected.
+     * If provided, should be an int.
+     */
+    public static final String CAMERA_ID = "SCAN_CAMERA_ID";
+
+    /**
+     * @see com.google.zxing.DecodeHintType#CHARACTER_SET
+     */
+    public static final String CHARACTER_SET = "CHARACTER_SET";
+
+    /**
+     * Optional parameters to specify the width and height of the scanning rectangle in pixels.
+     * The app will try to honor these, but will clamp them to the size of the preview frame.
+     * You should specify both or neither, and pass the size as an int.
+     */
+    public static final String WIDTH = "SCAN_WIDTH";
+    public static final String HEIGHT = "SCAN_HEIGHT";
+
+    /**
+     * Desired duration in milliseconds for which to pause after a successful scan before
+     * returning to the calling intent. Specified as a long, not an integer!
+     * For example: 1000L, not 1000.
+     */
+    public static final String RESULT_DISPLAY_DURATION_MS = "RESULT_DISPLAY_DURATION_MS";
+
+    /**
+     * Prompt to show on-screen when scanning by intent. Specified as a {@link String}.
+     */
+    public static final String PROMPT_MESSAGE = "PROMPT_MESSAGE";
+
+    /**
+     * If a barcode is found, Barcodes returns {@link android.app.Activity#RESULT_OK} to
+     * {@link android.app.Activity#onActivityResult(int, int, android.content.Intent)}
+     * of the app which requested the scan via
+     * {@link android.app.Activity#startActivityForResult(android.content.Intent, int)}
+     * The barcodes contents can be retrieved with
+     * {@link android.content.Intent#getStringExtra(String)}.
+     * If the user presses Back, the result code will be {@link android.app.Activity#RESULT_CANCELED}.
+     */
+    public static final String RESULT = "SCAN_RESULT";
+
+    /**
+     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_FORMAT}
+     * to determine which barcode format was found.
+     * See {@link com.google.zxing.BarcodeFormat} for possible values.
+     */
+    public static final String RESULT_FORMAT = "SCAN_RESULT_FORMAT";
+
+    /**
+     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_UPC_EAN_EXTENSION}
+     * to return the content of any UPC extension barcode that was also found. Only applicable
+     * to {@link com.google.zxing.BarcodeFormat#UPC_A} and {@link com.google.zxing.BarcodeFormat#EAN_13}
+     * formats.
+     */
+    public static final String RESULT_UPC_EAN_EXTENSION = "SCAN_RESULT_UPC_EAN_EXTENSION";
+
+    /**
+     * Call {@link android.content.Intent#getByteArrayExtra(String)} with {@link #RESULT_BYTES}
+     * to get a {@code byte[]} of raw bytes in the barcode, if available.
+     */
+    public static final String RESULT_BYTES = "SCAN_RESULT_BYTES";
+
+    /**
+     * Key for the value of {@link com.google.zxing.ResultMetadataType#ORIENTATION}, if available.
+     * Call {@link android.content.Intent#getIntArrayExtra(String)} with {@link #RESULT_ORIENTATION}.
+     */
+    public static final String RESULT_ORIENTATION = "SCAN_RESULT_ORIENTATION";
+
+    /**
+     * Key for the value of {@link com.google.zxing.ResultMetadataType#ERROR_CORRECTION_LEVEL}, if available.
+     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_ERROR_CORRECTION_LEVEL}.
+     */
+    public static final String RESULT_ERROR_CORRECTION_LEVEL = "SCAN_RESULT_ERROR_CORRECTION_LEVEL";
+
+    /**
+     * Prefix for keys that map to the values of {@link com.google.zxing.ResultMetadataType#BYTE_SEGMENTS},
+     * if available. The actual values will be set under a series of keys formed by adding 0, 1, 2, ...
+     * to this prefix. So the first byte segment is under key "SCAN_RESULT_BYTE_SEGMENTS_0" for example.
+     * Call {@link android.content.Intent#getByteArrayExtra(String)} with these keys.
+     */
+    public static final String RESULT_BYTE_SEGMENTS_PREFIX = "SCAN_RESULT_BYTE_SEGMENTS_";
+
+    /**
+     * Setting this to false will not save scanned codes in the history. Specified as a {@code boolean}.
+     */
+    public static final String SAVE_HISTORY = "SAVE_HISTORY";
+
+    private Scan() {
+    }
+  }
+
+  /**
+   * Constants related to the scan history and retrieving history items.
+   */
+  public static final class History {
+
+    public static final String ITEM_NUMBER = "ITEM_NUMBER";
+
+    private History() {
+    }
+  }
+
+  /**
+   * Constants related to the {@link Encode#ACTION} Intent.
+   */
+  public static final class Encode {
+    /**
+     * Send this intent to encode a piece of data as a QR code and display it full screen, so
+     * that another person can scan the barcode from your screen.
+     */
+    public static final String ACTION = "com.google.zxing.client.android.ENCODE";
+
+    /**
+     * The data to encode. Use {@link android.content.Intent#putExtra(String, String)} or
+     * {@link android.content.Intent#putExtra(String, android.os.Bundle)},
+     * depending on the type and format specified. Non-QR Code formats should
+     * just use a String here. For QR Code, see Contents for details.
+     */
+    public static final String DATA = "ENCODE_DATA";
+
+    /**
+     * The type of data being supplied if the format is QR Code. Use
+     * {@link android.content.Intent#putExtra(String, String)} with one of {@link Contents.Type}.
+     */
+    public static final String TYPE = "ENCODE_TYPE";
+
+    /**
+     * The barcode format to be displayed. If this isn't specified or is blank,
+     * it defaults to QR Code. Use {@link android.content.Intent#putExtra(String, String)}, where
+     * format is one of {@link com.google.zxing.BarcodeFormat}.
+     */
+    public static final String FORMAT = "ENCODE_FORMAT";
+
+    /**
+     * Normally the contents of the barcode are displayed to the user in a TextView. Setting this
+     * boolean to false will hide that TextView, showing only the encode barcode.
+     */
+    public static final String SHOW_CONTENTS = "ENCODE_SHOW_CONTENTS";
+
+    private Encode() {
+    }
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/LocaleManager.java b/src/com/android/contacts/util/barcode/LocaleManager.java
index 085835c..af99c68 100644
--- a/src/com/android/contacts/util/barcode/LocaleManager.java
+++ b/src/com/android/contacts/util/barcode/LocaleManager.java
@@ -1,185 +1,185 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.content.Context;
-
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
-
-/**
- * Handles any locale-specific logic for the client.
- *
- * @author Sean Owen
- */
-public final class LocaleManager {
-
-  private static final String DEFAULT_TLD = "com";
-  private static final String DEFAULT_COUNTRY = "US";
-  private static final String DEFAULT_LANGUAGE = "en";
-
-  /**
-   * Locales (well, countries) where Google web search is available.
-   * These should be kept in sync with our translations.
-   */
-  private static final Map<String,String> GOOGLE_COUNTRY_TLD;
-  static {
-    GOOGLE_COUNTRY_TLD = new HashMap<>();
-    GOOGLE_COUNTRY_TLD.put("AR", "com.ar"); // ARGENTINA
-    GOOGLE_COUNTRY_TLD.put("AU", "com.au"); // AUSTRALIA
-    GOOGLE_COUNTRY_TLD.put("BR", "com.br"); // BRAZIL
-    GOOGLE_COUNTRY_TLD.put("BG", "bg"); // BULGARIA
-    GOOGLE_COUNTRY_TLD.put(Locale.CANADA.getCountry(), "ca");
-    GOOGLE_COUNTRY_TLD.put(Locale.CHINA.getCountry(), "cn");
-    GOOGLE_COUNTRY_TLD.put("CZ", "cz"); // CZECH REPUBLIC
-    GOOGLE_COUNTRY_TLD.put("DK", "dk"); // DENMARK
-    GOOGLE_COUNTRY_TLD.put("FI", "fi"); // FINLAND
-    GOOGLE_COUNTRY_TLD.put(Locale.FRANCE.getCountry(), "fr");
-    GOOGLE_COUNTRY_TLD.put(Locale.GERMANY.getCountry(), "de");
-    GOOGLE_COUNTRY_TLD.put("GR", "gr"); // GREECE
-    GOOGLE_COUNTRY_TLD.put("HU", "hu"); // HUNGARY
-    GOOGLE_COUNTRY_TLD.put("ID", "co.id"); // INDONESIA
-    GOOGLE_COUNTRY_TLD.put("IL", "co.il"); // ISRAEL
-    GOOGLE_COUNTRY_TLD.put(Locale.ITALY.getCountry(), "it");
-    GOOGLE_COUNTRY_TLD.put(Locale.JAPAN.getCountry(), "co.jp");
-    GOOGLE_COUNTRY_TLD.put(Locale.KOREA.getCountry(), "co.kr");
-    GOOGLE_COUNTRY_TLD.put("NL", "nl"); // NETHERLANDS
-    GOOGLE_COUNTRY_TLD.put("PL", "pl"); // POLAND
-    GOOGLE_COUNTRY_TLD.put("PT", "pt"); // PORTUGAL
-    GOOGLE_COUNTRY_TLD.put("RO", "ro"); // ROMANIA    
-    GOOGLE_COUNTRY_TLD.put("RU", "ru"); // RUSSIA
-    GOOGLE_COUNTRY_TLD.put("SK", "sk"); // SLOVAK REPUBLIC
-    GOOGLE_COUNTRY_TLD.put("SI", "si"); // SLOVENIA
-    GOOGLE_COUNTRY_TLD.put("ES", "es"); // SPAIN
-    GOOGLE_COUNTRY_TLD.put("SE", "se"); // SWEDEN
-    GOOGLE_COUNTRY_TLD.put("CH", "ch"); // SWITZERLAND    
-    GOOGLE_COUNTRY_TLD.put(Locale.TAIWAN.getCountry(), "tw");
-    GOOGLE_COUNTRY_TLD.put("TR", "com.tr"); // TURKEY
-    GOOGLE_COUNTRY_TLD.put("UA", "com.ua"); // UKRAINE
-    GOOGLE_COUNTRY_TLD.put(Locale.UK.getCountry(), "co.uk");
-    GOOGLE_COUNTRY_TLD.put(Locale.US.getCountry(), "com");
-  }
-
-  /**
-   * Google Product Search for mobile is available in fewer countries than web search. See here:
-   * http://support.google.com/merchants/bin/answer.py?hl=en-GB&answer=160619
-   */
-  private static final Map<String,String> GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD;
-  static {
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD = new HashMap<>();
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("AU", "com.au"); // AUSTRALIA
-    //GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.CHINA.getCountry(), "cn");
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.FRANCE.getCountry(), "fr");
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.GERMANY.getCountry(), "de");
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.ITALY.getCountry(), "it");
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.JAPAN.getCountry(), "co.jp");
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("NL", "nl"); // NETHERLANDS
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("ES", "es"); // SPAIN
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("CH", "ch"); // SWITZERLAND
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.UK.getCountry(), "co.uk");
-    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.US.getCountry(), "com");
-  }
-
-  /**
-   * Book search is offered everywhere that web search is available.
-   */
-  private static final Map<String,String> GOOGLE_BOOK_SEARCH_COUNTRY_TLD = GOOGLE_COUNTRY_TLD;
-
-  private static final Collection<String> TRANSLATED_HELP_ASSET_LANGUAGES =
-      Arrays.asList("de", "en", "es", "fr", "it", "ja", "ko", "nl", "pt", "ru", "uk", "zh-rCN", "zh-rTW", "zh-rHK");
-
-  private LocaleManager() {}
-
-  /**
-   * @param context application's {@link Context}
-   * @return country-specific TLD suffix appropriate for the current default locale
-   *  (e.g. "co.uk" for the United Kingdom)
-   */
-  public static String getCountryTLD(Context context) {
-    return doGetTLD(GOOGLE_COUNTRY_TLD, context);
-  }
-
-  /**
-   * The same as above, but specifically for Google Product Search.
-   *
-   * @param context application's {@link Context}
-   * @return The top-level domain to use.
-   */
-  public static String getProductSearchCountryTLD(Context context) {
-    return doGetTLD(GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD, context);
-  }
-
-  /**
-   * The same as above, but specifically for Google Book Search.
-   *
-   * @param context application's {@link Context}
-   * @return The top-level domain to use.
-   */
-  public static String getBookSearchCountryTLD(Context context) {
-    return doGetTLD(GOOGLE_BOOK_SEARCH_COUNTRY_TLD, context);
-  }
-
-  /**
-   * Does a given URL point to Google Book Search, regardless of domain.
-   *
-   * @param url The address to check.
-   * @return True if this is a Book Search URL.
-   */
-  public static boolean isBookSearchUrl(String url) {
-    return url.startsWith("http://google.com/books") || url.startsWith("http://books.google.");
-  }
-
-  private static String getSystemCountry() {
-    Locale locale = Locale.getDefault();
-    return locale == null ? DEFAULT_COUNTRY : locale.getCountry();
-  }
-
-  private static String getSystemLanguage() {
-    Locale locale = Locale.getDefault();
-    if (locale == null) {
-      return DEFAULT_LANGUAGE;
-    }
-    String language = locale.getLanguage();
-    // Special case Chinese
-    if (Locale.SIMPLIFIED_CHINESE.getLanguage().equals(language)) {
-      return language + "-r" + getSystemCountry();
-    }
-    return language;
-  }
-
-  static String getTranslatedAssetLanguage() {
-    String language = getSystemLanguage();
-    return TRANSLATED_HELP_ASSET_LANGUAGES.contains(language) ? language : DEFAULT_LANGUAGE;
-  }
-
-  private static String doGetTLD(Map<String,String> map, Context context) {
-    String tld = map.get(getCountry(context));
-    return tld == null ? DEFAULT_TLD : tld;
-  }
-
-  private static String getCountry(Context context) {
-    String countryOverride = "-";
-    if (!countryOverride.isEmpty() && !"-".equals(countryOverride)) {
-      return countryOverride;
-    }
-    return getSystemCountry();
-  }
-
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.content.Context;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * Handles any locale-specific logic for the client.
+ *
+ * @author Sean Owen
+ */
+public final class LocaleManager {
+
+  private static final String DEFAULT_TLD = "com";
+  private static final String DEFAULT_COUNTRY = "US";
+  private static final String DEFAULT_LANGUAGE = "en";
+
+  /**
+   * Locales (well, countries) where Google web search is available.
+   * These should be kept in sync with our translations.
+   */
+  private static final Map<String,String> GOOGLE_COUNTRY_TLD;
+  static {
+    GOOGLE_COUNTRY_TLD = new HashMap<>();
+    GOOGLE_COUNTRY_TLD.put("AR", "com.ar"); // ARGENTINA
+    GOOGLE_COUNTRY_TLD.put("AU", "com.au"); // AUSTRALIA
+    GOOGLE_COUNTRY_TLD.put("BR", "com.br"); // BRAZIL
+    GOOGLE_COUNTRY_TLD.put("BG", "bg"); // BULGARIA
+    GOOGLE_COUNTRY_TLD.put(Locale.CANADA.getCountry(), "ca");
+    GOOGLE_COUNTRY_TLD.put(Locale.CHINA.getCountry(), "cn");
+    GOOGLE_COUNTRY_TLD.put("CZ", "cz"); // CZECH REPUBLIC
+    GOOGLE_COUNTRY_TLD.put("DK", "dk"); // DENMARK
+    GOOGLE_COUNTRY_TLD.put("FI", "fi"); // FINLAND
+    GOOGLE_COUNTRY_TLD.put(Locale.FRANCE.getCountry(), "fr");
+    GOOGLE_COUNTRY_TLD.put(Locale.GERMANY.getCountry(), "de");
+    GOOGLE_COUNTRY_TLD.put("GR", "gr"); // GREECE
+    GOOGLE_COUNTRY_TLD.put("HU", "hu"); // HUNGARY
+    GOOGLE_COUNTRY_TLD.put("ID", "co.id"); // INDONESIA
+    GOOGLE_COUNTRY_TLD.put("IL", "co.il"); // ISRAEL
+    GOOGLE_COUNTRY_TLD.put(Locale.ITALY.getCountry(), "it");
+    GOOGLE_COUNTRY_TLD.put(Locale.JAPAN.getCountry(), "co.jp");
+    GOOGLE_COUNTRY_TLD.put(Locale.KOREA.getCountry(), "co.kr");
+    GOOGLE_COUNTRY_TLD.put("NL", "nl"); // NETHERLANDS
+    GOOGLE_COUNTRY_TLD.put("PL", "pl"); // POLAND
+    GOOGLE_COUNTRY_TLD.put("PT", "pt"); // PORTUGAL
+    GOOGLE_COUNTRY_TLD.put("RO", "ro"); // ROMANIA    
+    GOOGLE_COUNTRY_TLD.put("RU", "ru"); // RUSSIA
+    GOOGLE_COUNTRY_TLD.put("SK", "sk"); // SLOVAK REPUBLIC
+    GOOGLE_COUNTRY_TLD.put("SI", "si"); // SLOVENIA
+    GOOGLE_COUNTRY_TLD.put("ES", "es"); // SPAIN
+    GOOGLE_COUNTRY_TLD.put("SE", "se"); // SWEDEN
+    GOOGLE_COUNTRY_TLD.put("CH", "ch"); // SWITZERLAND    
+    GOOGLE_COUNTRY_TLD.put(Locale.TAIWAN.getCountry(), "tw");
+    GOOGLE_COUNTRY_TLD.put("TR", "com.tr"); // TURKEY
+    GOOGLE_COUNTRY_TLD.put("UA", "com.ua"); // UKRAINE
+    GOOGLE_COUNTRY_TLD.put(Locale.UK.getCountry(), "co.uk");
+    GOOGLE_COUNTRY_TLD.put(Locale.US.getCountry(), "com");
+  }
+
+  /**
+   * Google Product Search for mobile is available in fewer countries than web search. See here:
+   * http://support.google.com/merchants/bin/answer.py?hl=en-GB&answer=160619
+   */
+  private static final Map<String,String> GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD;
+  static {
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD = new HashMap<>();
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("AU", "com.au"); // AUSTRALIA
+    //GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.CHINA.getCountry(), "cn");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.FRANCE.getCountry(), "fr");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.GERMANY.getCountry(), "de");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.ITALY.getCountry(), "it");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.JAPAN.getCountry(), "co.jp");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("NL", "nl"); // NETHERLANDS
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("ES", "es"); // SPAIN
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("CH", "ch"); // SWITZERLAND
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.UK.getCountry(), "co.uk");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.US.getCountry(), "com");
+  }
+
+  /**
+   * Book search is offered everywhere that web search is available.
+   */
+  private static final Map<String,String> GOOGLE_BOOK_SEARCH_COUNTRY_TLD = GOOGLE_COUNTRY_TLD;
+
+  private static final Collection<String> TRANSLATED_HELP_ASSET_LANGUAGES =
+      Arrays.asList("de", "en", "es", "fr", "it", "ja", "ko", "nl", "pt", "ru", "uk", "zh-rCN", "zh-rTW", "zh-rHK");
+
+  private LocaleManager() {}
+
+  /**
+   * @param context application's {@link Context}
+   * @return country-specific TLD suffix appropriate for the current default locale
+   *  (e.g. "co.uk" for the United Kingdom)
+   */
+  public static String getCountryTLD(Context context) {
+    return doGetTLD(GOOGLE_COUNTRY_TLD, context);
+  }
+
+  /**
+   * The same as above, but specifically for Google Product Search.
+   *
+   * @param context application's {@link Context}
+   * @return The top-level domain to use.
+   */
+  public static String getProductSearchCountryTLD(Context context) {
+    return doGetTLD(GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD, context);
+  }
+
+  /**
+   * The same as above, but specifically for Google Book Search.
+   *
+   * @param context application's {@link Context}
+   * @return The top-level domain to use.
+   */
+  public static String getBookSearchCountryTLD(Context context) {
+    return doGetTLD(GOOGLE_BOOK_SEARCH_COUNTRY_TLD, context);
+  }
+
+  /**
+   * Does a given URL point to Google Book Search, regardless of domain.
+   *
+   * @param url The address to check.
+   * @return True if this is a Book Search URL.
+   */
+  public static boolean isBookSearchUrl(String url) {
+    return url.startsWith("http://google.com/books") || url.startsWith("http://books.google.");
+  }
+
+  private static String getSystemCountry() {
+    Locale locale = Locale.getDefault();
+    return locale == null ? DEFAULT_COUNTRY : locale.getCountry();
+  }
+
+  private static String getSystemLanguage() {
+    Locale locale = Locale.getDefault();
+    if (locale == null) {
+      return DEFAULT_LANGUAGE;
+    }
+    String language = locale.getLanguage();
+    // Special case Chinese
+    if (Locale.SIMPLIFIED_CHINESE.getLanguage().equals(language)) {
+      return language + "-r" + getSystemCountry();
+    }
+    return language;
+  }
+
+  static String getTranslatedAssetLanguage() {
+    String language = getSystemLanguage();
+    return TRANSLATED_HELP_ASSET_LANGUAGES.contains(language) ? language : DEFAULT_LANGUAGE;
+  }
+
+  private static String doGetTLD(Map<String,String> map, Context context) {
+    String tld = map.get(getCountry(context));
+    return tld == null ? DEFAULT_TLD : tld;
+  }
+
+  private static String getCountry(Context context) {
+    String countryOverride = "-";
+    if (!countryOverride.isEmpty() && !"-".equals(countryOverride)) {
+      return countryOverride;
+    }
+    return getSystemCountry();
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/ViewfinderResultPointCallback.java b/src/com/android/contacts/util/barcode/ViewfinderResultPointCallback.java
index ec77bc4..2b4e6eb 100644
--- a/src/com/android/contacts/util/barcode/ViewfinderResultPointCallback.java
+++ b/src/com/android/contacts/util/barcode/ViewfinderResultPointCallback.java
@@ -1,35 +1,35 @@
-/*
- * Copyright (C) 2009 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import com.google.zxing.ResultPoint;
-import com.google.zxing.ResultPointCallback;
-
-final class ViewfinderResultPointCallback implements ResultPointCallback {
-
-    private final ViewfinderView viewfinderView;
-
-    ViewfinderResultPointCallback(ViewfinderView viewfinderView) {
-        this.viewfinderView = viewfinderView;
-    }
-
-    @Override
-    public void foundPossibleResultPoint(ResultPoint point) {
-        viewfinderView.addPossibleResultPoint(point);
-    }
-
-}
+/*
+ * Copyright (C) 2009 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import com.google.zxing.ResultPoint;
+import com.google.zxing.ResultPointCallback;
+
+final class ViewfinderResultPointCallback implements ResultPointCallback {
+
+    private final ViewfinderView viewfinderView;
+
+    ViewfinderResultPointCallback(ViewfinderView viewfinderView) {
+        this.viewfinderView = viewfinderView;
+    }
+
+    @Override
+    public void foundPossibleResultPoint(ResultPoint point) {
+        viewfinderView.addPossibleResultPoint(point);
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/ViewfinderView.java b/src/com/android/contacts/util/barcode/ViewfinderView.java
index 33680b6..e1ebb58 100644
--- a/src/com/android/contacts/util/barcode/ViewfinderView.java
+++ b/src/com/android/contacts/util/barcode/ViewfinderView.java
@@ -1,191 +1,191 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode;
-
-import android.annotation.SuppressLint;
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.Rect;
-import android.util.AttributeSet;
-import android.view.View;
-
-import com.android.contacts.util.barcode.camera.CameraManager;
-import com.google.zxing.ResultPoint;
-
-import java.util.Collection;
-import java.util.HashSet;
-
-import com.android.contacts.R;
-
-
-/**
- * This view is overlaid on top of the camera preview. It adds the viewfinder rectangle and partial
- * transparency outside it, as well as the laser scanner animation and result points.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class ViewfinderView extends View {
-    private CameraManager cameraManager;
-
-    private static final long ANIMATION_DELAY = 10L;
-    private static final int OPAQUE = 0xFF;
-
-    private int ScreenRate;
-    private static final int CORNER_WIDTH = 10;
-    private static final int MIDDLE_LINE_WIDTH = 4;
-    private static final int MIDDLE_LINE_PADDING = 5;
-    private static final int SPEEN_DISTANCE = 5;
-    private static float density;
-
-    private Paint paint;
-    private int slideTop;
-    private int slideBottom;
-
-    private Bitmap resultBitmap;
-    private final int maskColor;
-    private final int resultColor;
-
-    private final int resultPointColor;
-    private Collection<ResultPoint> possibleResultPoints;
-    private Collection<ResultPoint> lastPossibleResultPoints;
-
-    boolean isFirst;
-
-    public ViewfinderView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-
-        density = context.getResources().getDisplayMetrics().density;
-        ScreenRate = (int)(20 * density);
-
-        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
-        Resources resources = getResources();
-        maskColor = resources.getColor(R.color.viewfinder_mask);
-        resultColor = resources.getColor(R.color.result_view);
-
-        resultPointColor = resources.getColor(R.color.possible_result_points);
-        possibleResultPoints = new HashSet<ResultPoint>(5);
-    }
-
-    public void setCameraManager(CameraManager cameraManager) {
-        this.cameraManager = cameraManager;
-    }
-
-    @SuppressLint("DrawAllocation")
-    @Override
-    public void onDraw(Canvas canvas) {
-        if (cameraManager == null) {
-            return; // not ready yet, early draw before done configuring
-        }
-        Rect frame = cameraManager.getFramingRect();
-        if (frame == null) {
-            return;
-        }
-
-        if(!isFirst){
-            isFirst = true;
-            slideTop = frame.top;
-            slideBottom = frame.bottom;
-        }
-
-        int width = canvas.getWidth();
-        int height = canvas.getHeight();
-
-        paint.setColor(resultBitmap != null ? resultColor : maskColor);
-
-        canvas.drawRect(0, 0, width, frame.top, paint);
-        canvas.drawRect(0, frame.top, frame.left, frame.bottom + 1, paint);
-        canvas.drawRect(frame.right + 1, frame.top, width, frame.bottom + 1,
-                paint);
-        canvas.drawRect(0, frame.bottom + 1, width, height, paint);
-
-        if (resultBitmap == null) {
-            paint.setColor(getResources().getColor(R.color.colorAccent));
-            canvas.drawRect(frame.left, frame.top, frame.left + ScreenRate,
-                    frame.top + CORNER_WIDTH, paint);
-            canvas.drawRect(frame.left, frame.top, frame.left + CORNER_WIDTH, frame.top
-                    + ScreenRate, paint);
-            canvas.drawRect(frame.right - ScreenRate, frame.top, frame.right,
-                    frame.top + CORNER_WIDTH, paint);
-            canvas.drawRect(frame.right - CORNER_WIDTH, frame.top, frame.right, frame.top
-                    + ScreenRate, paint);
-            canvas.drawRect(frame.left, frame.bottom - CORNER_WIDTH, frame.left
-                    + ScreenRate, frame.bottom, paint);
-            canvas.drawRect(frame.left, frame.bottom - ScreenRate,
-                    frame.left + CORNER_WIDTH, frame.bottom, paint);
-            canvas.drawRect(frame.right - ScreenRate, frame.bottom - CORNER_WIDTH,
-                    frame.right, frame.bottom, paint);
-            canvas.drawRect(frame.right - CORNER_WIDTH, frame.bottom - ScreenRate,
-                    frame.right, frame.bottom, paint);
-
-            slideTop += SPEEN_DISTANCE;
-            if(slideTop >= frame.bottom){
-                slideTop = frame.top;
-            }
-            Paint linePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-            linePaint.setColor(getResources().getColor(R.color.colorAccent));
-            canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2, frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, linePaint);
-
-            Collection<ResultPoint> currentPossible = possibleResultPoints;
-            Collection<ResultPoint> currentLast = lastPossibleResultPoints;
-            if (currentPossible.isEmpty()) {
-                lastPossibleResultPoints = null;
-            } else {
-                possibleResultPoints = new HashSet<ResultPoint>(5);
-                lastPossibleResultPoints = currentPossible;
-                paint.setAlpha(OPAQUE);
-                paint.setColor(resultPointColor);
-                for (ResultPoint point : currentPossible) {
-                    canvas.drawCircle(frame.left + point.getX(), frame.top
-                            + point.getY(), 6.0f, paint);
-                }
-            }
-            if (currentLast != null) {
-                paint.setAlpha(OPAQUE / 2);
-                paint.setColor(resultPointColor);
-                for (ResultPoint point : currentLast) {
-                    canvas.drawCircle(frame.left + point.getX(), frame.top
-                            + point.getY(), 3.0f, paint);
-                }
-            }
-
-            postInvalidateDelayed(ANIMATION_DELAY, frame.left, frame.top,
-                    frame.right, frame.bottom);
-        }
-    }
-
-    public void drawViewfinder() {
-        resultBitmap = null;
-        invalidate();
-    }
-
-    /**
-     * Draw a bitmap with the result points highlighted instead of the live scanning display.
-     *
-     * @param barcode An image of the decoded barcode.
-     */
-    public void drawResultBitmap(Bitmap barcode) {
-        resultBitmap = barcode;
-        invalidate();
-    }
-
-    public void addPossibleResultPoint(ResultPoint point) {
-        possibleResultPoints.add(point);
-    }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.util.AttributeSet;
+import android.view.View;
+
+import com.android.contacts.util.barcode.camera.CameraManager;
+import com.google.zxing.ResultPoint;
+
+import java.util.Collection;
+import java.util.HashSet;
+
+import com.android.contacts.R;
+
+
+/**
+ * This view is overlaid on top of the camera preview. It adds the viewfinder rectangle and partial
+ * transparency outside it, as well as the laser scanner animation and result points.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ViewfinderView extends View {
+    private CameraManager cameraManager;
+
+    private static final long ANIMATION_DELAY = 10L;
+    private static final int OPAQUE = 0xFF;
+
+    private int ScreenRate;
+    private static final int CORNER_WIDTH = 10;
+    private static final int MIDDLE_LINE_WIDTH = 4;
+    private static final int MIDDLE_LINE_PADDING = 5;
+    private static final int SPEEN_DISTANCE = 5;
+    private static float density;
+
+    private Paint paint;
+    private int slideTop;
+    private int slideBottom;
+
+    private Bitmap resultBitmap;
+    private final int maskColor;
+    private final int resultColor;
+
+    private final int resultPointColor;
+    private Collection<ResultPoint> possibleResultPoints;
+    private Collection<ResultPoint> lastPossibleResultPoints;
+
+    boolean isFirst;
+
+    public ViewfinderView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        density = context.getResources().getDisplayMetrics().density;
+        ScreenRate = (int)(20 * density);
+
+        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        Resources resources = getResources();
+        maskColor = resources.getColor(R.color.viewfinder_mask);
+        resultColor = resources.getColor(R.color.result_view);
+
+        resultPointColor = resources.getColor(R.color.possible_result_points);
+        possibleResultPoints = new HashSet<ResultPoint>(5);
+    }
+
+    public void setCameraManager(CameraManager cameraManager) {
+        this.cameraManager = cameraManager;
+    }
+
+    @SuppressLint("DrawAllocation")
+    @Override
+    public void onDraw(Canvas canvas) {
+        if (cameraManager == null) {
+            return; // not ready yet, early draw before done configuring
+        }
+        Rect frame = cameraManager.getFramingRect();
+        if (frame == null) {
+            return;
+        }
+
+        if(!isFirst){
+            isFirst = true;
+            slideTop = frame.top;
+            slideBottom = frame.bottom;
+        }
+
+        int width = canvas.getWidth();
+        int height = canvas.getHeight();
+
+        paint.setColor(resultBitmap != null ? resultColor : maskColor);
+
+        canvas.drawRect(0, 0, width, frame.top, paint);
+        canvas.drawRect(0, frame.top, frame.left, frame.bottom + 1, paint);
+        canvas.drawRect(frame.right + 1, frame.top, width, frame.bottom + 1,
+                paint);
+        canvas.drawRect(0, frame.bottom + 1, width, height, paint);
+
+        if (resultBitmap == null) {
+            paint.setColor(getResources().getColor(R.color.colorAccent));
+            canvas.drawRect(frame.left, frame.top, frame.left + ScreenRate,
+                    frame.top + CORNER_WIDTH, paint);
+            canvas.drawRect(frame.left, frame.top, frame.left + CORNER_WIDTH, frame.top
+                    + ScreenRate, paint);
+            canvas.drawRect(frame.right - ScreenRate, frame.top, frame.right,
+                    frame.top + CORNER_WIDTH, paint);
+            canvas.drawRect(frame.right - CORNER_WIDTH, frame.top, frame.right, frame.top
+                    + ScreenRate, paint);
+            canvas.drawRect(frame.left, frame.bottom - CORNER_WIDTH, frame.left
+                    + ScreenRate, frame.bottom, paint);
+            canvas.drawRect(frame.left, frame.bottom - ScreenRate,
+                    frame.left + CORNER_WIDTH, frame.bottom, paint);
+            canvas.drawRect(frame.right - ScreenRate, frame.bottom - CORNER_WIDTH,
+                    frame.right, frame.bottom, paint);
+            canvas.drawRect(frame.right - CORNER_WIDTH, frame.bottom - ScreenRate,
+                    frame.right, frame.bottom, paint);
+
+            slideTop += SPEEN_DISTANCE;
+            if(slideTop >= frame.bottom){
+                slideTop = frame.top;
+            }
+            Paint linePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            linePaint.setColor(getResources().getColor(R.color.colorAccent));
+            canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2, frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, linePaint);
+
+            Collection<ResultPoint> currentPossible = possibleResultPoints;
+            Collection<ResultPoint> currentLast = lastPossibleResultPoints;
+            if (currentPossible.isEmpty()) {
+                lastPossibleResultPoints = null;
+            } else {
+                possibleResultPoints = new HashSet<ResultPoint>(5);
+                lastPossibleResultPoints = currentPossible;
+                paint.setAlpha(OPAQUE);
+                paint.setColor(resultPointColor);
+                for (ResultPoint point : currentPossible) {
+                    canvas.drawCircle(frame.left + point.getX(), frame.top
+                            + point.getY(), 6.0f, paint);
+                }
+            }
+            if (currentLast != null) {
+                paint.setAlpha(OPAQUE / 2);
+                paint.setColor(resultPointColor);
+                for (ResultPoint point : currentLast) {
+                    canvas.drawCircle(frame.left + point.getX(), frame.top
+                            + point.getY(), 3.0f, paint);
+                }
+            }
+
+            postInvalidateDelayed(ANIMATION_DELAY, frame.left, frame.top,
+                    frame.right, frame.bottom);
+        }
+    }
+
+    public void drawViewfinder() {
+        resultBitmap = null;
+        invalidate();
+    }
+
+    /**
+     * Draw a bitmap with the result points highlighted instead of the live scanning display.
+     *
+     * @param barcode An image of the decoded barcode.
+     */
+    public void drawResultBitmap(Bitmap barcode) {
+        resultBitmap = barcode;
+        invalidate();
+    }
+
+    public void addPossibleResultPoint(ResultPoint point) {
+        possibleResultPoints.add(point);
+    }
+}
diff --git a/src/com/android/contacts/util/barcode/camera/AutoFocusManager.java b/src/com/android/contacts/util/barcode/camera/AutoFocusManager.java
index 594cf43..048fa00 100644
--- a/src/com/android/contacts/util/barcode/camera/AutoFocusManager.java
+++ b/src/com/android/contacts/util/barcode/camera/AutoFocusManager.java
@@ -1,130 +1,130 @@
-/*
- * Copyright (C) 2012 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.camera;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.hardware.Camera;
-import android.os.AsyncTask;
-import android.preference.PreferenceManager;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.concurrent.RejectedExecutionException;
-
-
-final class AutoFocusManager implements Camera.AutoFocusCallback {
-
-    private static final String TAG = AutoFocusManager.class.getSimpleName();
-
-    private static final long AUTO_FOCUS_INTERVAL_MS = 1000L;
-    private static final Collection<String> FOCUS_MODES_CALLING_AF;
-
-    static {
-        FOCUS_MODES_CALLING_AF = new ArrayList<>(2);
-        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_AUTO);
-        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_MACRO);
-    }
-
-    private boolean stopped;
-    private boolean focusing;
-    private final boolean useAutoFocus;
-    private final Camera camera;
-    private AsyncTask<?, ?, ?> outstandingTask;
-
-    AutoFocusManager(Context context, Camera camera) {
-        this.camera = camera;
-        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(context);
-        String currentFocusMode = camera.getParameters().getFocusMode();
-        useAutoFocus = FOCUS_MODES_CALLING_AF.contains(currentFocusMode);
-        Log.i(TAG, "Current focus mode '" + currentFocusMode + "'; use auto focus? " + useAutoFocus);
-        start();
-    }
-
-    @Override
-    public synchronized void onAutoFocus(boolean success, Camera theCamera) {
-        focusing = false;
-        autoFocusAgainLater();
-    }
-
-    private synchronized void autoFocusAgainLater() {
-        if (!stopped && outstandingTask == null) {
-            AutoFocusTask newTask = new AutoFocusTask();
-            try {
-                newTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-                outstandingTask = newTask;
-            } catch (RejectedExecutionException ree) {
-                Log.w(TAG, "Could not request auto focus", ree);
-            }
-        }
-    }
-
-    synchronized void start() {
-        if (useAutoFocus) {
-            outstandingTask = null;
-            if (!stopped && !focusing) {
-                try {
-                    camera.autoFocus(this);
-                    focusing = true;
-                } catch (RuntimeException re) {
-                    // Have heard RuntimeException reported in Android 4.0.x+; continue?
-                    Log.w(TAG, "Unexpected exception while focusing", re);
-                    // Try again later to keep cycle going
-                    autoFocusAgainLater();
-                }
-            }
-        }
-    }
-
-    private synchronized void cancelOutstandingTask() {
-        if (outstandingTask != null) {
-            if (outstandingTask.getStatus() != AsyncTask.Status.FINISHED) {
-                outstandingTask.cancel(true);
-            }
-            outstandingTask = null;
-        }
-    }
-
-    synchronized void stop() {
-        stopped = true;
-        if (useAutoFocus) {
-            cancelOutstandingTask();
-            // Doesn't hurt to call this even if not focusing
-            try {
-                camera.cancelAutoFocus();
-            } catch (RuntimeException re) {
-                // Have heard RuntimeException reported in Android 4.0.x+; continue?
-                Log.w(TAG, "Unexpected exception while cancelling focusing", re);
-            }
-        }
-    }
-
-    private final class AutoFocusTask extends AsyncTask<Object, Object, Object> {
-        @Override
-        protected Object doInBackground(Object... voids) {
-            try {
-                Thread.sleep(AUTO_FOCUS_INTERVAL_MS);
-            } catch (InterruptedException e) {
-                // continue
-            }
-            start();
-            return null;
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2012 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.hardware.Camera;
+import android.os.AsyncTask;
+import android.preference.PreferenceManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.concurrent.RejectedExecutionException;
+
+
+final class AutoFocusManager implements Camera.AutoFocusCallback {
+
+    private static final String TAG = AutoFocusManager.class.getSimpleName();
+
+    private static final long AUTO_FOCUS_INTERVAL_MS = 1000L;
+    private static final Collection<String> FOCUS_MODES_CALLING_AF;
+
+    static {
+        FOCUS_MODES_CALLING_AF = new ArrayList<>(2);
+        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_AUTO);
+        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_MACRO);
+    }
+
+    private boolean stopped;
+    private boolean focusing;
+    private final boolean useAutoFocus;
+    private final Camera camera;
+    private AsyncTask<?, ?, ?> outstandingTask;
+
+    AutoFocusManager(Context context, Camera camera) {
+        this.camera = camera;
+        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(context);
+        String currentFocusMode = camera.getParameters().getFocusMode();
+        useAutoFocus = FOCUS_MODES_CALLING_AF.contains(currentFocusMode);
+        Log.i(TAG, "Current focus mode '" + currentFocusMode + "'; use auto focus? " + useAutoFocus);
+        start();
+    }
+
+    @Override
+    public synchronized void onAutoFocus(boolean success, Camera theCamera) {
+        focusing = false;
+        autoFocusAgainLater();
+    }
+
+    private synchronized void autoFocusAgainLater() {
+        if (!stopped && outstandingTask == null) {
+            AutoFocusTask newTask = new AutoFocusTask();
+            try {
+                newTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+                outstandingTask = newTask;
+            } catch (RejectedExecutionException ree) {
+                Log.w(TAG, "Could not request auto focus", ree);
+            }
+        }
+    }
+
+    synchronized void start() {
+        if (useAutoFocus) {
+            outstandingTask = null;
+            if (!stopped && !focusing) {
+                try {
+                    camera.autoFocus(this);
+                    focusing = true;
+                } catch (RuntimeException re) {
+                    // Have heard RuntimeException reported in Android 4.0.x+; continue?
+                    Log.w(TAG, "Unexpected exception while focusing", re);
+                    // Try again later to keep cycle going
+                    autoFocusAgainLater();
+                }
+            }
+        }
+    }
+
+    private synchronized void cancelOutstandingTask() {
+        if (outstandingTask != null) {
+            if (outstandingTask.getStatus() != AsyncTask.Status.FINISHED) {
+                outstandingTask.cancel(true);
+            }
+            outstandingTask = null;
+        }
+    }
+
+    synchronized void stop() {
+        stopped = true;
+        if (useAutoFocus) {
+            cancelOutstandingTask();
+            // Doesn't hurt to call this even if not focusing
+            try {
+                camera.cancelAutoFocus();
+            } catch (RuntimeException re) {
+                // Have heard RuntimeException reported in Android 4.0.x+; continue?
+                Log.w(TAG, "Unexpected exception while cancelling focusing", re);
+            }
+        }
+    }
+
+    private final class AutoFocusTask extends AsyncTask<Object, Object, Object> {
+        @Override
+        protected Object doInBackground(Object... voids) {
+            try {
+                Thread.sleep(AUTO_FOCUS_INTERVAL_MS);
+            } catch (InterruptedException e) {
+                // continue
+            }
+            start();
+            return null;
+        }
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/CameraConfigurationManager.java b/src/com/android/contacts/util/barcode/camera/CameraConfigurationManager.java
index 8f0a8ec..205a244 100644
--- a/src/com/android/contacts/util/barcode/camera/CameraConfigurationManager.java
+++ b/src/com/android/contacts/util/barcode/camera/CameraConfigurationManager.java
@@ -1,223 +1,223 @@
-/*
- * Copyright (C) 2010 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.camera;
-
-import android.content.Context;
-import android.graphics.Point;
-import android.hardware.Camera;
-import android.util.Log;
-import android.view.Display;
-import android.view.Surface;
-import android.view.WindowManager;
-
-import com.android.contacts.util.barcode.camera.open.CameraFacing;
-import com.android.contacts.util.barcode.camera.open.OpenCamera;
-
-
-/**
- * A class which deals with reading, parsing, and setting the camera parameters which are used to
- * configure the camera hardware.
- */
-final class CameraConfigurationManager {
-
-    private static final String TAG = "CameraConfiguration";
-
-    private final Context context;
-    private int cwNeededRotation;
-    private int cwRotationFromDisplayToCamera;
-    private Point screenResolution;
-    private Point cameraResolution;
-    private Point bestPreviewSize;
-    private Point previewSizeOnScreen;
-
-    CameraConfigurationManager(Context context) {
-        this.context = context;
-    }
-
-    /**
-     * Reads, one time, values from the camera that are needed by the app.
-     */
-    void initFromCameraParameters(OpenCamera camera) {
-        Camera.Parameters parameters = camera.getCamera().getParameters();
-        WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-        Display display = manager.getDefaultDisplay();
-
-        // 判断屏幕方向，是否有需要从自然角度旋转到显示器角度
-        int displayRotation = display.getRotation();
-        int cwRotationFromNaturalToDisplay;
-        switch (displayRotation) {
-            case Surface.ROTATION_0:
-                cwRotationFromNaturalToDisplay = 0;
-                break;
-            case Surface.ROTATION_90:
-                cwRotationFromNaturalToDisplay = 90;
-                break;
-            case Surface.ROTATION_180:
-                cwRotationFromNaturalToDisplay = 180;
-                break;
-            case Surface.ROTATION_270:
-                cwRotationFromNaturalToDisplay = 270;
-                break;
-            default:
-                // Have seen this return incorrect values like -90
-                if (displayRotation % 90 == 0) {
-                    cwRotationFromNaturalToDisplay = (360 + displayRotation) % 360;
-                } else {
-                    throw new IllegalArgumentException("Bad rotation: " + displayRotation);
-                }
-        }
-        Log.i(TAG, "Display at: " + cwRotationFromNaturalToDisplay);
-
-        // 判断相机的方向，根据前后摄像机判断是否有需要旋转
-        int cwRotationFromNaturalToCamera = camera.getOrientation();
-        Log.i(TAG, "Camera at: " + cwRotationFromNaturalToCamera);
-
-        // Still not 100% sure about this. But acts like we need to flip this:
-        if (camera.getFacing() == CameraFacing.FRONT) {
-            cwRotationFromNaturalToCamera = (360 - cwRotationFromNaturalToCamera) % 360;
-            Log.i(TAG, "Front camera overriden to: " + cwRotationFromNaturalToCamera);
-        }
-
-        // 根据屏幕方向和相机方向判断是否有需要进行旋转
-        cwRotationFromDisplayToCamera =
-                (360 + cwRotationFromNaturalToCamera - cwRotationFromNaturalToDisplay) % 360;
-        Log.i(TAG, "Final display orientation: " + cwRotationFromDisplayToCamera);
-        if (camera.getFacing() == CameraFacing.FRONT) {
-            Log.i(TAG, "Compensating rotation for front camera");
-            cwNeededRotation = (360 - cwRotationFromDisplayToCamera) % 360;
-        } else {
-            cwNeededRotation = cwRotationFromDisplayToCamera;
-        }
-        Log.i(TAG, "Clockwise rotation from display to camera: " + cwNeededRotation);
-
-        Point theScreenResolution = new Point();
-        display.getSize(theScreenResolution);
-        screenResolution = theScreenResolution;
-        Log.i(TAG, "Screen resolution in current orientation: " + screenResolution);
-
-        // 寻找最佳的预览宽高值
-        cameraResolution = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);
-        Log.i(TAG, "Camera resolution: " + cameraResolution);
-        bestPreviewSize = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);
-        Log.i(TAG, "Best available preview size: " + bestPreviewSize);
-
-        boolean isScreenPortrait = screenResolution.x < screenResolution.y;
-        boolean isPreviewSizePortrait = bestPreviewSize.x < bestPreviewSize.y;
-
-        if (isScreenPortrait == isPreviewSizePortrait) {
-            previewSizeOnScreen = bestPreviewSize;
-        } else {
-            previewSizeOnScreen = new Point(bestPreviewSize.y, bestPreviewSize.x);
-        }
-        Log.i(TAG, "Preview size on screen: " + previewSizeOnScreen);
-    }
-
-    void setDesiredCameraParameters(OpenCamera camera, boolean safeMode) {
-
-        Camera theCamera = camera.getCamera();
-        Camera.Parameters parameters = theCamera.getParameters();
-
-        if (parameters == null) {
-            Log.w(TAG, "Device error: no camera parameters are available. Proceeding without configuration.");
-            return;
-        }
-
-        Log.i(TAG, "Initial camera parameters: " + parameters.flatten());
-
-        if (safeMode) {
-            Log.w(TAG, "In camera config safe mode -- most settings will not be honored");
-        }
-
-        initializeTorch(parameters);
-
-        // 设置对焦功能
-        CameraConfigurationUtils.setFocus(parameters, true, true, safeMode);
-
-        if (!safeMode) {
-            // 不需要进行条形码场景匹配
-            CameraConfigurationUtils.setBarcodeSceneMode(parameters);
-
-            // 不使用距离测量
-            CameraConfigurationUtils.setVideoStabilization(parameters);
-            CameraConfigurationUtils.setFocusArea(parameters);
-            CameraConfigurationUtils.setMetering(parameters);
-        }
-
-        //parameters.setPreviewSize(bestPreviewSize.x, bestPreviewSize.y);
-
-        //theCamera.setParameters(parameters);
-
-        theCamera.setDisplayOrientation(cwRotationFromDisplayToCamera);
-
-        Camera.Parameters afterParameters = theCamera.getParameters();
-        Camera.Size afterSize = afterParameters.getPreviewSize();
-        if (afterSize != null && (bestPreviewSize.x != afterSize.width || bestPreviewSize.y != afterSize.height)) {
-            Log.w(TAG, "Camera said it supported preview size " + bestPreviewSize.x + 'x' + bestPreviewSize.y +
-                    ", but after setting it, preview size is " + afterSize.width + 'x' + afterSize.height);
-            bestPreviewSize.x = afterSize.width;
-            bestPreviewSize.y = afterSize.height;
-        }
-    }
-
-    Point getBestPreviewSize() {
-        return bestPreviewSize;
-    }
-
-    Point getPreviewSizeOnScreen() {
-        return previewSizeOnScreen;
-    }
-
-    Point getCameraResolution() {
-        return cameraResolution;
-    }
-
-    Point getScreenResolution() {
-        return screenResolution;
-    }
-
-    int getCWNeededRotation() {
-        return cwNeededRotation;
-    }
-
-    boolean getTorchState(Camera camera) {
-        if (camera != null) {
-            Camera.Parameters parameters = camera.getParameters();
-            if (parameters != null) {
-                String flashMode = parameters.getFlashMode();
-                return flashMode != null &&
-                        (Camera.Parameters.FLASH_MODE_ON.equals(flashMode) ||
-                                Camera.Parameters.FLASH_MODE_TORCH.equals(flashMode));
-            }
-        }
-        return false;
-    }
-
-    void setTorch(Camera camera, boolean newSetting) {
-        Camera.Parameters parameters = camera.getParameters();
-        doSetTorch(parameters, newSetting);
-        camera.setParameters(parameters);
-    }
-
-    private void initializeTorch(Camera.Parameters parameters) {
-        doSetTorch(parameters, false);
-    }
-
-    private void doSetTorch(Camera.Parameters parameters, boolean newSetting) {
-        CameraConfigurationUtils.setTorch(parameters, newSetting);
-    }
-
-}
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.hardware.Camera;
+import android.util.Log;
+import android.view.Display;
+import android.view.Surface;
+import android.view.WindowManager;
+
+import com.android.contacts.util.barcode.camera.open.CameraFacing;
+import com.android.contacts.util.barcode.camera.open.OpenCamera;
+
+
+/**
+ * A class which deals with reading, parsing, and setting the camera parameters which are used to
+ * configure the camera hardware.
+ */
+final class CameraConfigurationManager {
+
+    private static final String TAG = "CameraConfiguration";
+
+    private final Context context;
+    private int cwNeededRotation;
+    private int cwRotationFromDisplayToCamera;
+    private Point screenResolution;
+    private Point cameraResolution;
+    private Point bestPreviewSize;
+    private Point previewSizeOnScreen;
+
+    CameraConfigurationManager(Context context) {
+        this.context = context;
+    }
+
+    /**
+     * Reads, one time, values from the camera that are needed by the app.
+     */
+    void initFromCameraParameters(OpenCamera camera) {
+        Camera.Parameters parameters = camera.getCamera().getParameters();
+        WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = manager.getDefaultDisplay();
+
+        // 判断屏幕方向，是否有需要从自然角度旋转到显示器角度
+        int displayRotation = display.getRotation();
+        int cwRotationFromNaturalToDisplay;
+        switch (displayRotation) {
+            case Surface.ROTATION_0:
+                cwRotationFromNaturalToDisplay = 0;
+                break;
+            case Surface.ROTATION_90:
+                cwRotationFromNaturalToDisplay = 90;
+                break;
+            case Surface.ROTATION_180:
+                cwRotationFromNaturalToDisplay = 180;
+                break;
+            case Surface.ROTATION_270:
+                cwRotationFromNaturalToDisplay = 270;
+                break;
+            default:
+                // Have seen this return incorrect values like -90
+                if (displayRotation % 90 == 0) {
+                    cwRotationFromNaturalToDisplay = (360 + displayRotation) % 360;
+                } else {
+                    throw new IllegalArgumentException("Bad rotation: " + displayRotation);
+                }
+        }
+        Log.i(TAG, "Display at: " + cwRotationFromNaturalToDisplay);
+
+        // 判断相机的方向，根据前后摄像机判断是否有需要旋转
+        int cwRotationFromNaturalToCamera = camera.getOrientation();
+        Log.i(TAG, "Camera at: " + cwRotationFromNaturalToCamera);
+
+        // Still not 100% sure about this. But acts like we need to flip this:
+        if (camera.getFacing() == CameraFacing.FRONT) {
+            cwRotationFromNaturalToCamera = (360 - cwRotationFromNaturalToCamera) % 360;
+            Log.i(TAG, "Front camera overriden to: " + cwRotationFromNaturalToCamera);
+        }
+
+        // 根据屏幕方向和相机方向判断是否有需要进行旋转
+        cwRotationFromDisplayToCamera =
+                (360 + cwRotationFromNaturalToCamera - cwRotationFromNaturalToDisplay) % 360;
+        Log.i(TAG, "Final display orientation: " + cwRotationFromDisplayToCamera);
+        if (camera.getFacing() == CameraFacing.FRONT) {
+            Log.i(TAG, "Compensating rotation for front camera");
+            cwNeededRotation = (360 - cwRotationFromDisplayToCamera) % 360;
+        } else {
+            cwNeededRotation = cwRotationFromDisplayToCamera;
+        }
+        Log.i(TAG, "Clockwise rotation from display to camera: " + cwNeededRotation);
+
+        Point theScreenResolution = new Point();
+        display.getSize(theScreenResolution);
+        screenResolution = theScreenResolution;
+        Log.i(TAG, "Screen resolution in current orientation: " + screenResolution);
+
+        // 寻找最佳的预览宽高值
+        cameraResolution = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);
+        Log.i(TAG, "Camera resolution: " + cameraResolution);
+        bestPreviewSize = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);
+        Log.i(TAG, "Best available preview size: " + bestPreviewSize);
+
+        boolean isScreenPortrait = screenResolution.x < screenResolution.y;
+        boolean isPreviewSizePortrait = bestPreviewSize.x < bestPreviewSize.y;
+
+        if (isScreenPortrait == isPreviewSizePortrait) {
+            previewSizeOnScreen = bestPreviewSize;
+        } else {
+            previewSizeOnScreen = new Point(bestPreviewSize.y, bestPreviewSize.x);
+        }
+        Log.i(TAG, "Preview size on screen: " + previewSizeOnScreen);
+    }
+
+    void setDesiredCameraParameters(OpenCamera camera, boolean safeMode) {
+
+        Camera theCamera = camera.getCamera();
+        Camera.Parameters parameters = theCamera.getParameters();
+
+        if (parameters == null) {
+            Log.w(TAG, "Device error: no camera parameters are available. Proceeding without configuration.");
+            return;
+        }
+
+        Log.i(TAG, "Initial camera parameters: " + parameters.flatten());
+
+        if (safeMode) {
+            Log.w(TAG, "In camera config safe mode -- most settings will not be honored");
+        }
+
+        initializeTorch(parameters);
+
+        // 设置对焦功能
+        CameraConfigurationUtils.setFocus(parameters, true, true, safeMode);
+
+        if (!safeMode) {
+            // 不需要进行条形码场景匹配
+            CameraConfigurationUtils.setBarcodeSceneMode(parameters);
+
+            // 不使用距离测量
+            CameraConfigurationUtils.setVideoStabilization(parameters);
+            CameraConfigurationUtils.setFocusArea(parameters);
+            CameraConfigurationUtils.setMetering(parameters);
+        }
+
+        //parameters.setPreviewSize(bestPreviewSize.x, bestPreviewSize.y);
+
+        //theCamera.setParameters(parameters);
+
+        theCamera.setDisplayOrientation(cwRotationFromDisplayToCamera);
+
+        Camera.Parameters afterParameters = theCamera.getParameters();
+        Camera.Size afterSize = afterParameters.getPreviewSize();
+        if (afterSize != null && (bestPreviewSize.x != afterSize.width || bestPreviewSize.y != afterSize.height)) {
+            Log.w(TAG, "Camera said it supported preview size " + bestPreviewSize.x + 'x' + bestPreviewSize.y +
+                    ", but after setting it, preview size is " + afterSize.width + 'x' + afterSize.height);
+            bestPreviewSize.x = afterSize.width;
+            bestPreviewSize.y = afterSize.height;
+        }
+    }
+
+    Point getBestPreviewSize() {
+        return bestPreviewSize;
+    }
+
+    Point getPreviewSizeOnScreen() {
+        return previewSizeOnScreen;
+    }
+
+    Point getCameraResolution() {
+        return cameraResolution;
+    }
+
+    Point getScreenResolution() {
+        return screenResolution;
+    }
+
+    int getCWNeededRotation() {
+        return cwNeededRotation;
+    }
+
+    boolean getTorchState(Camera camera) {
+        if (camera != null) {
+            Camera.Parameters parameters = camera.getParameters();
+            if (parameters != null) {
+                String flashMode = parameters.getFlashMode();
+                return flashMode != null &&
+                        (Camera.Parameters.FLASH_MODE_ON.equals(flashMode) ||
+                                Camera.Parameters.FLASH_MODE_TORCH.equals(flashMode));
+            }
+        }
+        return false;
+    }
+
+    void setTorch(Camera camera, boolean newSetting) {
+        Camera.Parameters parameters = camera.getParameters();
+        doSetTorch(parameters, newSetting);
+        camera.setParameters(parameters);
+    }
+
+    private void initializeTorch(Camera.Parameters parameters) {
+        doSetTorch(parameters, false);
+    }
+
+    private void doSetTorch(Camera.Parameters parameters, boolean newSetting) {
+        CameraConfigurationUtils.setTorch(parameters, newSetting);
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/CameraConfigurationUtils.java b/src/com/android/contacts/util/barcode/camera/CameraConfigurationUtils.java
index c7f6132..2c1e25e 100644
--- a/src/com/android/contacts/util/barcode/camera/CameraConfigurationUtils.java
+++ b/src/com/android/contacts/util/barcode/camera/CameraConfigurationUtils.java
@@ -1,455 +1,455 @@
-/*
- * Copyright (C) 2014 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.camera;
-
-import android.annotation.TargetApi;
-import android.graphics.Point;
-import android.graphics.Rect;
-import android.hardware.Camera;
-import android.os.Build;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.regex.Pattern;
-
-/**
- * Utility methods for configuring the Android camera.
- *
- * @author Sean Owen
- */
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
-public final class CameraConfigurationUtils {
-
-    private static final String TAG = "CameraConfiguration";
-
-    private static final Pattern SEMICOLON = Pattern.compile(";");
-
-    private static final int MIN_PREVIEW_PIXELS = 480 * 320; // normal screen
-    private static final float MAX_EXPOSURE_COMPENSATION = 1.5f;
-    private static final float MIN_EXPOSURE_COMPENSATION = 0.0f;
-    private static final double MAX_ASPECT_DISTORTION = 0.15;
-    private static final int MIN_FPS = 10;
-    private static final int MAX_FPS = 20;
-    private static final int AREA_PER_1000 = 400;
-
-    private CameraConfigurationUtils() {
-    }
-
-    public static void setFocus(Camera.Parameters parameters,
-                                boolean autoFocus,
-                                boolean disableContinuous,
-                                boolean safeMode) {
-        List<String> supportedFocusModes = parameters.getSupportedFocusModes();
-        String focusMode = null;
-        if (autoFocus) {
-            if (safeMode || disableContinuous) {
-                focusMode = findSettableValue("focus mode",
-                        supportedFocusModes,
-                        Camera.Parameters.FOCUS_MODE_AUTO);
-            } else {
-                focusMode = findSettableValue("focus mode",
-                        supportedFocusModes,
-                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,
-                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO,
-                        Camera.Parameters.FOCUS_MODE_AUTO);
-            }
-        }
-        // Maybe selected auto-focus but not available, so fall through here:
-        if (!safeMode && focusMode == null) {
-            focusMode = findSettableValue("focus mode",
-                    supportedFocusModes,
-                    Camera.Parameters.FOCUS_MODE_MACRO,
-                    Camera.Parameters.FOCUS_MODE_EDOF);
-        }
-        if (focusMode != null) {
-            if (focusMode.equals(parameters.getFocusMode())) {
-                Log.i(TAG, "Focus mode already set to " + focusMode);
-            } else {
-                parameters.setFocusMode(focusMode);
-            }
-        }
-    }
-
-    public static void setTorch(Camera.Parameters parameters, boolean on) {
-        List<String> supportedFlashModes = parameters.getSupportedFlashModes();
-        String flashMode;
-        if (on) {
-            flashMode = findSettableValue("flash mode",
-                    supportedFlashModes,
-                    Camera.Parameters.FLASH_MODE_TORCH,
-                    Camera.Parameters.FLASH_MODE_ON);
-        } else {
-            flashMode = findSettableValue("flash mode",
-                    supportedFlashModes,
-                    Camera.Parameters.FLASH_MODE_OFF);
-        }
-        if (flashMode != null) {
-            if (flashMode.equals(parameters.getFlashMode())) {
-                Log.i(TAG, "Flash mode already set to " + flashMode);
-            } else {
-                Log.i(TAG, "Setting flash mode to " + flashMode);
-                parameters.setFlashMode(flashMode);
-            }
-        }
-    }
-
-    public static void setBestExposure(Camera.Parameters parameters, boolean lightOn) {
-        int minExposure = parameters.getMinExposureCompensation();
-        int maxExposure = parameters.getMaxExposureCompensation();
-        float step = parameters.getExposureCompensationStep();
-        if ((minExposure != 0 || maxExposure != 0) && step > 0.0f) {
-            // Set low when light is on
-            float targetCompensation = lightOn ? MIN_EXPOSURE_COMPENSATION : MAX_EXPOSURE_COMPENSATION;
-            int compensationSteps = Math.round(targetCompensation / step);
-            float actualCompensation = step * compensationSteps;
-            // Clamp value:
-            compensationSteps = Math.max(Math.min(compensationSteps, maxExposure), minExposure);
-            if (parameters.getExposureCompensation() == compensationSteps) {
-                Log.i(TAG, "Exposure compensation already set to " + compensationSteps + " / " + actualCompensation);
-            } else {
-                Log.i(TAG, "Setting exposure compensation to " + compensationSteps + " / " + actualCompensation);
-                parameters.setExposureCompensation(compensationSteps);
-            }
-        } else {
-            Log.i(TAG, "Camera does not support exposure compensation");
-        }
-    }
-
-    public static void setBestPreviewFPS(Camera.Parameters parameters) {
-        setBestPreviewFPS(parameters, MIN_FPS, MAX_FPS);
-    }
-
-    public static void setBestPreviewFPS(Camera.Parameters parameters, int minFPS, int maxFPS) {
-        List<int[]> supportedPreviewFpsRanges = parameters.getSupportedPreviewFpsRange();
-        Log.i(TAG, "Supported FPS ranges: " + toString(supportedPreviewFpsRanges));
-        if (supportedPreviewFpsRanges != null && !supportedPreviewFpsRanges.isEmpty()) {
-            int[] suitableFPSRange = null;
-            for (int[] fpsRange : supportedPreviewFpsRanges) {
-                int thisMin = fpsRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX];
-                int thisMax = fpsRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX];
-                if (thisMin >= minFPS * 1000 && thisMax <= maxFPS * 1000) {
-                    suitableFPSRange = fpsRange;
-                    break;
-                }
-            }
-            if (suitableFPSRange == null) {
-                Log.i(TAG, "No suitable FPS range?");
-            } else {
-                int[] currentFpsRange = new int[2];
-                parameters.getPreviewFpsRange(currentFpsRange);
-                if (Arrays.equals(currentFpsRange, suitableFPSRange)) {
-                    Log.i(TAG, "FPS range already set to " + Arrays.toString(suitableFPSRange));
-                } else {
-                    Log.i(TAG, "Setting FPS range to " + Arrays.toString(suitableFPSRange));
-                    parameters.setPreviewFpsRange(suitableFPSRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX],
-                            suitableFPSRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]);
-                }
-            }
-        }
-    }
-
-    public static void setFocusArea(Camera.Parameters parameters) {
-        if (parameters.getMaxNumFocusAreas() > 0) {
-            Log.i(TAG, "Old focus areas: " + toString(parameters.getFocusAreas()));
-            List<Camera.Area> middleArea = buildMiddleArea(AREA_PER_1000);
-            Log.i(TAG, "Setting focus area to : " + toString(middleArea));
-            parameters.setFocusAreas(middleArea);
-        } else {
-            Log.i(TAG, "Device does not support focus areas");
-        }
-    }
-
-    public static void setMetering(Camera.Parameters parameters) {
-        if (parameters.getMaxNumMeteringAreas() > 0) {
-            Log.i(TAG, "Old metering areas: " + parameters.getMeteringAreas());
-            List<Camera.Area> middleArea = buildMiddleArea(AREA_PER_1000);
-            Log.i(TAG, "Setting metering area to : " + toString(middleArea));
-            parameters.setMeteringAreas(middleArea);
-        } else {
-            Log.i(TAG, "Device does not support metering areas");
-        }
-    }
-
-    private static List<Camera.Area> buildMiddleArea(int areaPer1000) {
-        return Collections.singletonList(
-                new Camera.Area(new Rect(-areaPer1000, -areaPer1000, areaPer1000, areaPer1000), 1));
-    }
-
-    public static void setVideoStabilization(Camera.Parameters parameters) {
-        if (parameters.isVideoStabilizationSupported()) {
-            if (parameters.getVideoStabilization()) {
-                Log.i(TAG, "Video stabilization already enabled");
-            } else {
-                Log.i(TAG, "Enabling video stabilization...");
-                parameters.setVideoStabilization(true);
-            }
-        } else {
-            Log.i(TAG, "This device does not support video stabilization");
-        }
-    }
-
-    public static void setBarcodeSceneMode(Camera.Parameters parameters) {
-        if (Camera.Parameters.SCENE_MODE_BARCODE.equals(parameters.getSceneMode())) {
-            Log.i(TAG, "Barcode scene mode already set");
-            return;
-        }
-        String sceneMode = findSettableValue("scene mode",
-                parameters.getSupportedSceneModes(),
-                Camera.Parameters.SCENE_MODE_BARCODE);
-        if (sceneMode != null) {
-            parameters.setSceneMode(sceneMode);
-        }
-    }
-
-    public static void setZoom(Camera.Parameters parameters, double targetZoomRatio) {
-        if (parameters.isZoomSupported()) {
-            Integer zoom = indexOfClosestZoom(parameters, targetZoomRatio);
-            if (zoom == null) {
-                return;
-            }
-            if (parameters.getZoom() == zoom) {
-                Log.i(TAG, "Zoom is already set to " + zoom);
-            } else {
-                Log.i(TAG, "Setting zoom to " + zoom);
-                parameters.setZoom(zoom);
-            }
-        } else {
-            Log.i(TAG, "Zoom is not supported");
-        }
-    }
-
-    private static Integer indexOfClosestZoom(Camera.Parameters parameters, double targetZoomRatio) {
-        List<Integer> ratios = parameters.getZoomRatios();
-        Log.i(TAG, "Zoom ratios: " + ratios);
-        int maxZoom = parameters.getMaxZoom();
-        if (ratios == null || ratios.isEmpty() || ratios.size() != maxZoom + 1) {
-            Log.w(TAG, "Invalid zoom ratios!");
-            return null;
-        }
-        double target100 = 100.0 * targetZoomRatio;
-        double smallestDiff = Double.POSITIVE_INFINITY;
-        int closestIndex = 0;
-        for (int i = 0; i < ratios.size(); i++) {
-            double diff = Math.abs(ratios.get(i) - target100);
-            if (diff < smallestDiff) {
-                smallestDiff = diff;
-                closestIndex = i;
-            }
-        }
-        Log.i(TAG, "Chose zoom ratio of " + (ratios.get(closestIndex) / 100.0));
-        return closestIndex;
-    }
-
-    public static void setInvertColor(Camera.Parameters parameters) {
-        if (Camera.Parameters.EFFECT_NEGATIVE.equals(parameters.getColorEffect())) {
-            Log.i(TAG, "Negative effect already set");
-            return;
-        }
-        String colorMode = findSettableValue("color effect",
-                parameters.getSupportedColorEffects(),
-                Camera.Parameters.EFFECT_NEGATIVE);
-        if (colorMode != null) {
-            parameters.setColorEffect(colorMode);
-        }
-    }
-
-    public static Point findBestPreviewSizeValue(Camera.Parameters parameters, Point screenResolution) {
-
-        // 获取当前手机支持的屏幕预览尺寸
-        List<Camera.Size> rawSupportedSizes = parameters.getSupportedPreviewSizes();
-        if (rawSupportedSizes == null) {
-            Log.w(TAG, "Device returned no supported preview sizes; using default");
-            Camera.Size defaultSize = parameters.getPreviewSize();
-            if (defaultSize == null) {
-                throw new IllegalStateException("Parameters contained no preview size!");
-            }
-            return new Point(defaultSize.width, defaultSize.height);
-        }
-
-        // Sort by size, descending
-        // 对这些尺寸根据像素值（即宽乘高的值）进行从小到大排序
-        List<Camera.Size> supportedPreviewSizes = new ArrayList<>(rawSupportedSizes);
-        Collections.sort(supportedPreviewSizes, new Comparator<Camera.Size>() {
-            @Override
-            public int compare(Camera.Size a, Camera.Size b) {
-                int aPixels = a.height * a.width;
-                int bPixels = b.height * b.width;
-                if (bPixels < aPixels) {
-                    return -1;
-                }
-                if (bPixels > aPixels) {
-                    return 1;
-                }
-                return 0;
-            }
-        });
-
-        if (Log.isLoggable(TAG, Log.INFO)) {
-            StringBuilder previewSizesString = new StringBuilder();
-            for (Camera.Size supportedPreviewSize : supportedPreviewSizes) {
-                previewSizesString.append(supportedPreviewSize.width).append('x')
-                        .append(supportedPreviewSize.height).append(' ');
-            }
-            Log.i(TAG, "Supported preview sizes: " + previewSizesString);
-        }
-
-        double screenAspectRatio = screenResolution.x / (double) screenResolution.y;
-
-        // Remove sizes that are unsuitable
-        Iterator<Camera.Size> it = supportedPreviewSizes.iterator();
-        while (it.hasNext()) {
-            Camera.Size supportedPreviewSize = it.next();
-            int realWidth = supportedPreviewSize.width;
-            int realHeight = supportedPreviewSize.height;
-
-            // 首先把不符合最小预览像素值的尺寸排除
-            if (realWidth * realHeight < MIN_PREVIEW_PIXELS) {
-                it.remove();
-                continue;
-            }
-
-            boolean isCandidatePortrait = realWidth < realHeight;
-            int maybeFlippedWidth = isCandidatePortrait ? realHeight : realWidth;
-            int maybeFlippedHeight = isCandidatePortrait ? realWidth : realHeight;
-            double aspectRatio = maybeFlippedWidth / (double) maybeFlippedHeight;
-            double distortion = Math.abs(aspectRatio - screenAspectRatio);
-
-            // 根据宽高比判断是否满足最大误差要求（默认最大值为0.15，即宽高比默认不能超过给定比例的15%）
-            if (distortion > MAX_ASPECT_DISTORTION) {
-                it.remove();
-                continue;
-            }
-
-            if (maybeFlippedWidth == screenResolution.x && maybeFlippedHeight == screenResolution.y) {
-                Point exactPoint = new Point(realWidth, realHeight);
-                Log.i(TAG, "Found preview size exactly matching screen size: " + exactPoint);
-                return exactPoint;
-            }
-        }
-
-        // If no exact match, use largest preview size. This was not a great idea on older devices because
-        // of the additional computation needed. We're likely to get here on newer Android 4+ devices, where
-        // the CPU is much more powerful.
-        // 如果没有精确匹配到合适的尺寸，则使用最大的尺寸，这样设置便是预览图像可能产生拉伸的根本原因
-        if (!supportedPreviewSizes.isEmpty()) {
-            Camera.Size largestPreview = supportedPreviewSizes.get(0);
-            Point largestSize = new Point(largestPreview.width, largestPreview.height);
-            Log.i(TAG, "Using largest suitable preview size: " + largestSize);
-            return largestSize;
-        }
-
-        // If there is nothing at all suitable, return current preview size
-        // 如果没有找到合适的尺寸，就返回默认设定的尺寸
-        Camera.Size defaultPreview = parameters.getPreviewSize();
-        if (defaultPreview == null) {
-            throw new IllegalStateException("Parameters contained no preview size!");
-        }
-        Point defaultSize = new Point(defaultPreview.width, defaultPreview.height);
-        Log.i(TAG, "No suitable preview sizes, using default: " + defaultSize);
-        return defaultSize;
-    }
-
-    private static String findSettableValue(String name,
-                                            Collection<String> supportedValues,
-                                            String... desiredValues) {
-        Log.i(TAG, "Requesting " + name + " value from among: " + Arrays.toString(desiredValues));
-        Log.i(TAG, "Supported " + name + " values: " + supportedValues);
-        if (supportedValues != null) {
-            for (String desiredValue : desiredValues) {
-                if (supportedValues.contains(desiredValue)) {
-                    Log.i(TAG, "Can set " + name + " to: " + desiredValue);
-                    return desiredValue;
-                }
-            }
-        }
-        Log.i(TAG, "No supported values match");
-        return null;
-    }
-
-    private static String toString(Collection<int[]> arrays) {
-        if (arrays == null || arrays.isEmpty()) {
-            return "[]";
-        }
-        StringBuilder buffer = new StringBuilder();
-        buffer.append('[');
-        Iterator<int[]> it = arrays.iterator();
-        while (it.hasNext()) {
-            buffer.append(Arrays.toString(it.next()));
-            if (it.hasNext()) {
-                buffer.append(", ");
-            }
-        }
-        buffer.append(']');
-        return buffer.toString();
-    }
-
-    private static String toString(Iterable<Camera.Area> areas) {
-        if (areas == null) {
-            return null;
-        }
-        StringBuilder result = new StringBuilder();
-        for (Camera.Area area : areas) {
-            result.append(area.rect).append(':').append(area.weight).append(' ');
-        }
-        return result.toString();
-    }
-
-    public static String collectStats(Camera.Parameters parameters) {
-        return collectStats(parameters.flatten());
-    }
-
-    public static String collectStats(CharSequence flattenedParams) {
-        StringBuilder result = new StringBuilder(1000);
-
-        result.append("BOARD=").append(Build.BOARD).append('\n');
-        result.append("BRAND=").append(Build.BRAND).append('\n');
-        result.append("CPU_ABI=").append(Build.CPU_ABI).append('\n');
-        result.append("DEVICE=").append(Build.DEVICE).append('\n');
-        result.append("DISPLAY=").append(Build.DISPLAY).append('\n');
-        result.append("FINGERPRINT=").append(Build.FINGERPRINT).append('\n');
-        result.append("HOST=").append(Build.HOST).append('\n');
-        result.append("ID=").append(Build.ID).append('\n');
-        result.append("MANUFACTURER=").append(Build.MANUFACTURER).append('\n');
-        result.append("MODEL=").append(Build.MODEL).append('\n');
-        result.append("PRODUCT=").append(Build.PRODUCT).append('\n');
-        result.append("TAGS=").append(Build.TAGS).append('\n');
-        result.append("TIME=").append(Build.TIME).append('\n');
-        result.append("TYPE=").append(Build.TYPE).append('\n');
-        result.append("USER=").append(Build.USER).append('\n');
-        result.append("VERSION.CODENAME=").append(Build.VERSION.CODENAME).append('\n');
-        result.append("VERSION.INCREMENTAL=").append(Build.VERSION.INCREMENTAL).append('\n');
-        result.append("VERSION.RELEASE=").append(Build.VERSION.RELEASE).append('\n');
-        result.append("VERSION.SDK_INT=").append(Build.VERSION.SDK_INT).append('\n');
-
-        if (flattenedParams != null) {
-            String[] params = SEMICOLON.split(flattenedParams);
-            Arrays.sort(params);
-            for (String param : params) {
-                result.append(param).append('\n');
-            }
-        }
-
-        return result.toString();
-    }
-
-}
+/*
+ * Copyright (C) 2014 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera;
+
+import android.annotation.TargetApi;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.hardware.Camera;
+import android.os.Build;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.regex.Pattern;
+
+/**
+ * Utility methods for configuring the Android camera.
+ *
+ * @author Sean Owen
+ */
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+public final class CameraConfigurationUtils {
+
+    private static final String TAG = "CameraConfiguration";
+
+    private static final Pattern SEMICOLON = Pattern.compile(";");
+
+    private static final int MIN_PREVIEW_PIXELS = 480 * 320; // normal screen
+    private static final float MAX_EXPOSURE_COMPENSATION = 1.5f;
+    private static final float MIN_EXPOSURE_COMPENSATION = 0.0f;
+    private static final double MAX_ASPECT_DISTORTION = 0.15;
+    private static final int MIN_FPS = 10;
+    private static final int MAX_FPS = 20;
+    private static final int AREA_PER_1000 = 400;
+
+    private CameraConfigurationUtils() {
+    }
+
+    public static void setFocus(Camera.Parameters parameters,
+                                boolean autoFocus,
+                                boolean disableContinuous,
+                                boolean safeMode) {
+        List<String> supportedFocusModes = parameters.getSupportedFocusModes();
+        String focusMode = null;
+        if (autoFocus) {
+            if (safeMode || disableContinuous) {
+                focusMode = findSettableValue("focus mode",
+                        supportedFocusModes,
+                        Camera.Parameters.FOCUS_MODE_AUTO);
+            } else {
+                focusMode = findSettableValue("focus mode",
+                        supportedFocusModes,
+                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,
+                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO,
+                        Camera.Parameters.FOCUS_MODE_AUTO);
+            }
+        }
+        // Maybe selected auto-focus but not available, so fall through here:
+        if (!safeMode && focusMode == null) {
+            focusMode = findSettableValue("focus mode",
+                    supportedFocusModes,
+                    Camera.Parameters.FOCUS_MODE_MACRO,
+                    Camera.Parameters.FOCUS_MODE_EDOF);
+        }
+        if (focusMode != null) {
+            if (focusMode.equals(parameters.getFocusMode())) {
+                Log.i(TAG, "Focus mode already set to " + focusMode);
+            } else {
+                parameters.setFocusMode(focusMode);
+            }
+        }
+    }
+
+    public static void setTorch(Camera.Parameters parameters, boolean on) {
+        List<String> supportedFlashModes = parameters.getSupportedFlashModes();
+        String flashMode;
+        if (on) {
+            flashMode = findSettableValue("flash mode",
+                    supportedFlashModes,
+                    Camera.Parameters.FLASH_MODE_TORCH,
+                    Camera.Parameters.FLASH_MODE_ON);
+        } else {
+            flashMode = findSettableValue("flash mode",
+                    supportedFlashModes,
+                    Camera.Parameters.FLASH_MODE_OFF);
+        }
+        if (flashMode != null) {
+            if (flashMode.equals(parameters.getFlashMode())) {
+                Log.i(TAG, "Flash mode already set to " + flashMode);
+            } else {
+                Log.i(TAG, "Setting flash mode to " + flashMode);
+                parameters.setFlashMode(flashMode);
+            }
+        }
+    }
+
+    public static void setBestExposure(Camera.Parameters parameters, boolean lightOn) {
+        int minExposure = parameters.getMinExposureCompensation();
+        int maxExposure = parameters.getMaxExposureCompensation();
+        float step = parameters.getExposureCompensationStep();
+        if ((minExposure != 0 || maxExposure != 0) && step > 0.0f) {
+            // Set low when light is on
+            float targetCompensation = lightOn ? MIN_EXPOSURE_COMPENSATION : MAX_EXPOSURE_COMPENSATION;
+            int compensationSteps = Math.round(targetCompensation / step);
+            float actualCompensation = step * compensationSteps;
+            // Clamp value:
+            compensationSteps = Math.max(Math.min(compensationSteps, maxExposure), minExposure);
+            if (parameters.getExposureCompensation() == compensationSteps) {
+                Log.i(TAG, "Exposure compensation already set to " + compensationSteps + " / " + actualCompensation);
+            } else {
+                Log.i(TAG, "Setting exposure compensation to " + compensationSteps + " / " + actualCompensation);
+                parameters.setExposureCompensation(compensationSteps);
+            }
+        } else {
+            Log.i(TAG, "Camera does not support exposure compensation");
+        }
+    }
+
+    public static void setBestPreviewFPS(Camera.Parameters parameters) {
+        setBestPreviewFPS(parameters, MIN_FPS, MAX_FPS);
+    }
+
+    public static void setBestPreviewFPS(Camera.Parameters parameters, int minFPS, int maxFPS) {
+        List<int[]> supportedPreviewFpsRanges = parameters.getSupportedPreviewFpsRange();
+        Log.i(TAG, "Supported FPS ranges: " + toString(supportedPreviewFpsRanges));
+        if (supportedPreviewFpsRanges != null && !supportedPreviewFpsRanges.isEmpty()) {
+            int[] suitableFPSRange = null;
+            for (int[] fpsRange : supportedPreviewFpsRanges) {
+                int thisMin = fpsRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX];
+                int thisMax = fpsRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX];
+                if (thisMin >= minFPS * 1000 && thisMax <= maxFPS * 1000) {
+                    suitableFPSRange = fpsRange;
+                    break;
+                }
+            }
+            if (suitableFPSRange == null) {
+                Log.i(TAG, "No suitable FPS range?");
+            } else {
+                int[] currentFpsRange = new int[2];
+                parameters.getPreviewFpsRange(currentFpsRange);
+                if (Arrays.equals(currentFpsRange, suitableFPSRange)) {
+                    Log.i(TAG, "FPS range already set to " + Arrays.toString(suitableFPSRange));
+                } else {
+                    Log.i(TAG, "Setting FPS range to " + Arrays.toString(suitableFPSRange));
+                    parameters.setPreviewFpsRange(suitableFPSRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX],
+                            suitableFPSRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]);
+                }
+            }
+        }
+    }
+
+    public static void setFocusArea(Camera.Parameters parameters) {
+        if (parameters.getMaxNumFocusAreas() > 0) {
+            Log.i(TAG, "Old focus areas: " + toString(parameters.getFocusAreas()));
+            List<Camera.Area> middleArea = buildMiddleArea(AREA_PER_1000);
+            Log.i(TAG, "Setting focus area to : " + toString(middleArea));
+            parameters.setFocusAreas(middleArea);
+        } else {
+            Log.i(TAG, "Device does not support focus areas");
+        }
+    }
+
+    public static void setMetering(Camera.Parameters parameters) {
+        if (parameters.getMaxNumMeteringAreas() > 0) {
+            Log.i(TAG, "Old metering areas: " + parameters.getMeteringAreas());
+            List<Camera.Area> middleArea = buildMiddleArea(AREA_PER_1000);
+            Log.i(TAG, "Setting metering area to : " + toString(middleArea));
+            parameters.setMeteringAreas(middleArea);
+        } else {
+            Log.i(TAG, "Device does not support metering areas");
+        }
+    }
+
+    private static List<Camera.Area> buildMiddleArea(int areaPer1000) {
+        return Collections.singletonList(
+                new Camera.Area(new Rect(-areaPer1000, -areaPer1000, areaPer1000, areaPer1000), 1));
+    }
+
+    public static void setVideoStabilization(Camera.Parameters parameters) {
+        if (parameters.isVideoStabilizationSupported()) {
+            if (parameters.getVideoStabilization()) {
+                Log.i(TAG, "Video stabilization already enabled");
+            } else {
+                Log.i(TAG, "Enabling video stabilization...");
+                parameters.setVideoStabilization(true);
+            }
+        } else {
+            Log.i(TAG, "This device does not support video stabilization");
+        }
+    }
+
+    public static void setBarcodeSceneMode(Camera.Parameters parameters) {
+        if (Camera.Parameters.SCENE_MODE_BARCODE.equals(parameters.getSceneMode())) {
+            Log.i(TAG, "Barcode scene mode already set");
+            return;
+        }
+        String sceneMode = findSettableValue("scene mode",
+                parameters.getSupportedSceneModes(),
+                Camera.Parameters.SCENE_MODE_BARCODE);
+        if (sceneMode != null) {
+            parameters.setSceneMode(sceneMode);
+        }
+    }
+
+    public static void setZoom(Camera.Parameters parameters, double targetZoomRatio) {
+        if (parameters.isZoomSupported()) {
+            Integer zoom = indexOfClosestZoom(parameters, targetZoomRatio);
+            if (zoom == null) {
+                return;
+            }
+            if (parameters.getZoom() == zoom) {
+                Log.i(TAG, "Zoom is already set to " + zoom);
+            } else {
+                Log.i(TAG, "Setting zoom to " + zoom);
+                parameters.setZoom(zoom);
+            }
+        } else {
+            Log.i(TAG, "Zoom is not supported");
+        }
+    }
+
+    private static Integer indexOfClosestZoom(Camera.Parameters parameters, double targetZoomRatio) {
+        List<Integer> ratios = parameters.getZoomRatios();
+        Log.i(TAG, "Zoom ratios: " + ratios);
+        int maxZoom = parameters.getMaxZoom();
+        if (ratios == null || ratios.isEmpty() || ratios.size() != maxZoom + 1) {
+            Log.w(TAG, "Invalid zoom ratios!");
+            return null;
+        }
+        double target100 = 100.0 * targetZoomRatio;
+        double smallestDiff = Double.POSITIVE_INFINITY;
+        int closestIndex = 0;
+        for (int i = 0; i < ratios.size(); i++) {
+            double diff = Math.abs(ratios.get(i) - target100);
+            if (diff < smallestDiff) {
+                smallestDiff = diff;
+                closestIndex = i;
+            }
+        }
+        Log.i(TAG, "Chose zoom ratio of " + (ratios.get(closestIndex) / 100.0));
+        return closestIndex;
+    }
+
+    public static void setInvertColor(Camera.Parameters parameters) {
+        if (Camera.Parameters.EFFECT_NEGATIVE.equals(parameters.getColorEffect())) {
+            Log.i(TAG, "Negative effect already set");
+            return;
+        }
+        String colorMode = findSettableValue("color effect",
+                parameters.getSupportedColorEffects(),
+                Camera.Parameters.EFFECT_NEGATIVE);
+        if (colorMode != null) {
+            parameters.setColorEffect(colorMode);
+        }
+    }
+
+    public static Point findBestPreviewSizeValue(Camera.Parameters parameters, Point screenResolution) {
+
+        // 获取当前手机支持的屏幕预览尺寸
+        List<Camera.Size> rawSupportedSizes = parameters.getSupportedPreviewSizes();
+        if (rawSupportedSizes == null) {
+            Log.w(TAG, "Device returned no supported preview sizes; using default");
+            Camera.Size defaultSize = parameters.getPreviewSize();
+            if (defaultSize == null) {
+                throw new IllegalStateException("Parameters contained no preview size!");
+            }
+            return new Point(defaultSize.width, defaultSize.height);
+        }
+
+        // Sort by size, descending
+        // 对这些尺寸根据像素值（即宽乘高的值）进行从小到大排序
+        List<Camera.Size> supportedPreviewSizes = new ArrayList<>(rawSupportedSizes);
+        Collections.sort(supportedPreviewSizes, new Comparator<Camera.Size>() {
+            @Override
+            public int compare(Camera.Size a, Camera.Size b) {
+                int aPixels = a.height * a.width;
+                int bPixels = b.height * b.width;
+                if (bPixels < aPixels) {
+                    return -1;
+                }
+                if (bPixels > aPixels) {
+                    return 1;
+                }
+                return 0;
+            }
+        });
+
+        if (Log.isLoggable(TAG, Log.INFO)) {
+            StringBuilder previewSizesString = new StringBuilder();
+            for (Camera.Size supportedPreviewSize : supportedPreviewSizes) {
+                previewSizesString.append(supportedPreviewSize.width).append('x')
+                        .append(supportedPreviewSize.height).append(' ');
+            }
+            Log.i(TAG, "Supported preview sizes: " + previewSizesString);
+        }
+
+        double screenAspectRatio = screenResolution.x / (double) screenResolution.y;
+
+        // Remove sizes that are unsuitable
+        Iterator<Camera.Size> it = supportedPreviewSizes.iterator();
+        while (it.hasNext()) {
+            Camera.Size supportedPreviewSize = it.next();
+            int realWidth = supportedPreviewSize.width;
+            int realHeight = supportedPreviewSize.height;
+
+            // 首先把不符合最小预览像素值的尺寸排除
+            if (realWidth * realHeight < MIN_PREVIEW_PIXELS) {
+                it.remove();
+                continue;
+            }
+
+            boolean isCandidatePortrait = realWidth < realHeight;
+            int maybeFlippedWidth = isCandidatePortrait ? realHeight : realWidth;
+            int maybeFlippedHeight = isCandidatePortrait ? realWidth : realHeight;
+            double aspectRatio = maybeFlippedWidth / (double) maybeFlippedHeight;
+            double distortion = Math.abs(aspectRatio - screenAspectRatio);
+
+            // 根据宽高比判断是否满足最大误差要求（默认最大值为0.15，即宽高比默认不能超过给定比例的15%）
+            if (distortion > MAX_ASPECT_DISTORTION) {
+                it.remove();
+                continue;
+            }
+
+            if (maybeFlippedWidth == screenResolution.x && maybeFlippedHeight == screenResolution.y) {
+                Point exactPoint = new Point(realWidth, realHeight);
+                Log.i(TAG, "Found preview size exactly matching screen size: " + exactPoint);
+                return exactPoint;
+            }
+        }
+
+        // If no exact match, use largest preview size. This was not a great idea on older devices because
+        // of the additional computation needed. We're likely to get here on newer Android 4+ devices, where
+        // the CPU is much more powerful.
+        // 如果没有精确匹配到合适的尺寸，则使用最大的尺寸，这样设置便是预览图像可能产生拉伸的根本原因
+        if (!supportedPreviewSizes.isEmpty()) {
+            Camera.Size largestPreview = supportedPreviewSizes.get(0);
+            Point largestSize = new Point(largestPreview.width, largestPreview.height);
+            Log.i(TAG, "Using largest suitable preview size: " + largestSize);
+            return largestSize;
+        }
+
+        // If there is nothing at all suitable, return current preview size
+        // 如果没有找到合适的尺寸，就返回默认设定的尺寸
+        Camera.Size defaultPreview = parameters.getPreviewSize();
+        if (defaultPreview == null) {
+            throw new IllegalStateException("Parameters contained no preview size!");
+        }
+        Point defaultSize = new Point(defaultPreview.width, defaultPreview.height);
+        Log.i(TAG, "No suitable preview sizes, using default: " + defaultSize);
+        return defaultSize;
+    }
+
+    private static String findSettableValue(String name,
+                                            Collection<String> supportedValues,
+                                            String... desiredValues) {
+        Log.i(TAG, "Requesting " + name + " value from among: " + Arrays.toString(desiredValues));
+        Log.i(TAG, "Supported " + name + " values: " + supportedValues);
+        if (supportedValues != null) {
+            for (String desiredValue : desiredValues) {
+                if (supportedValues.contains(desiredValue)) {
+                    Log.i(TAG, "Can set " + name + " to: " + desiredValue);
+                    return desiredValue;
+                }
+            }
+        }
+        Log.i(TAG, "No supported values match");
+        return null;
+    }
+
+    private static String toString(Collection<int[]> arrays) {
+        if (arrays == null || arrays.isEmpty()) {
+            return "[]";
+        }
+        StringBuilder buffer = new StringBuilder();
+        buffer.append('[');
+        Iterator<int[]> it = arrays.iterator();
+        while (it.hasNext()) {
+            buffer.append(Arrays.toString(it.next()));
+            if (it.hasNext()) {
+                buffer.append(", ");
+            }
+        }
+        buffer.append(']');
+        return buffer.toString();
+    }
+
+    private static String toString(Iterable<Camera.Area> areas) {
+        if (areas == null) {
+            return null;
+        }
+        StringBuilder result = new StringBuilder();
+        for (Camera.Area area : areas) {
+            result.append(area.rect).append(':').append(area.weight).append(' ');
+        }
+        return result.toString();
+    }
+
+    public static String collectStats(Camera.Parameters parameters) {
+        return collectStats(parameters.flatten());
+    }
+
+    public static String collectStats(CharSequence flattenedParams) {
+        StringBuilder result = new StringBuilder(1000);
+
+        result.append("BOARD=").append(Build.BOARD).append('\n');
+        result.append("BRAND=").append(Build.BRAND).append('\n');
+        result.append("CPU_ABI=").append(Build.CPU_ABI).append('\n');
+        result.append("DEVICE=").append(Build.DEVICE).append('\n');
+        result.append("DISPLAY=").append(Build.DISPLAY).append('\n');
+        result.append("FINGERPRINT=").append(Build.FINGERPRINT).append('\n');
+        result.append("HOST=").append(Build.HOST).append('\n');
+        result.append("ID=").append(Build.ID).append('\n');
+        result.append("MANUFACTURER=").append(Build.MANUFACTURER).append('\n');
+        result.append("MODEL=").append(Build.MODEL).append('\n');
+        result.append("PRODUCT=").append(Build.PRODUCT).append('\n');
+        result.append("TAGS=").append(Build.TAGS).append('\n');
+        result.append("TIME=").append(Build.TIME).append('\n');
+        result.append("TYPE=").append(Build.TYPE).append('\n');
+        result.append("USER=").append(Build.USER).append('\n');
+        result.append("VERSION.CODENAME=").append(Build.VERSION.CODENAME).append('\n');
+        result.append("VERSION.INCREMENTAL=").append(Build.VERSION.INCREMENTAL).append('\n');
+        result.append("VERSION.RELEASE=").append(Build.VERSION.RELEASE).append('\n');
+        result.append("VERSION.SDK_INT=").append(Build.VERSION.SDK_INT).append('\n');
+
+        if (flattenedParams != null) {
+            String[] params = SEMICOLON.split(flattenedParams);
+            Arrays.sort(params);
+            for (String param : params) {
+                result.append(param).append('\n');
+            }
+        }
+
+        return result.toString();
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/CameraManager.java b/src/com/android/contacts/util/barcode/camera/CameraManager.java
index 669165d..696ffa3 100644
--- a/src/com/android/contacts/util/barcode/camera/CameraManager.java
+++ b/src/com/android/contacts/util/barcode/camera/CameraManager.java
@@ -1,350 +1,350 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.camera;
-
-import android.content.Context;
-import android.graphics.Point;
-import android.graphics.Rect;
-import android.hardware.Camera;
-import android.os.Handler;
-import android.util.Log;
-import android.view.SurfaceHolder;
-
-import com.android.contacts.util.barcode.camera.open.OpenCamera;
-import com.android.contacts.util.barcode.camera.open.OpenCameraInterface;
-import com.google.zxing.PlanarYUVLuminanceSource;
-
-import java.io.IOException;
-
-
-/**
- * This object wraps the Camera service object and expects to be the only one talking to it. The
- * implementation encapsulates the steps needed to take preview-sized images, which are used for
- * both preview and decoding.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class CameraManager {
-
-    private static final String TAG = CameraManager.class.getSimpleName();
-
-    private static final int MIN_FRAME_WIDTH = 240;
-    public static final int MIN_FRAME_HEIGHT = 240;
-    private static final int MAX_FRAME_WIDTH = 1200; // = 5/8 * 1920
-    public static final int MAX_FRAME_HEIGHT = 675; // = 5/8 * 1080
-
-    private final Context context;
-    private final CameraConfigurationManager configManager;
-    private OpenCamera camera;
-    private AutoFocusManager autoFocusManager;
-    private Rect framingRect;
-    private Rect framingRectInPreview;
-    private boolean initialized;
-    private boolean previewing;
-    private int requestedCameraId = OpenCameraInterface.NO_REQUESTED_CAMERA;
-    private int requestedFramingRectWidth;
-    private int requestedFramingRectHeight;
-    /**
-     * Preview frames are delivered here, which we pass on to the registered handler. Make sure to
-     * clear the handler so it will only receive one message.
-     */
-    private final PreviewCallback previewCallback;
-
-    public CameraManager(Context context) {
-        this.context = context;
-        this.configManager = new CameraConfigurationManager(context);
-        previewCallback = new PreviewCallback(configManager);
-    }
-
-    /**
-     * Opens the camera driver and initializes the hardware parameters.
-     *
-     * @param holder The surface object which the camera will draw preview frames into.
-     * @throws IOException Indicates the camera driver failed to open.
-     */
-    public synchronized void openDriver(SurfaceHolder holder) throws IOException {
-        OpenCamera theCamera = camera;
-        if (theCamera == null) {
-            theCamera = OpenCameraInterface.open(requestedCameraId);
-            if (theCamera == null) {
-                throw new IOException("Camera.open() failed to return object from driver");
-            }
-            camera = theCamera;
-        }
-
-        if (!initialized) {
-            initialized = true;
-            configManager.initFromCameraParameters(theCamera);
-            if (requestedFramingRectWidth > 0 && requestedFramingRectHeight > 0) {
-                setManualFramingRect(requestedFramingRectWidth, requestedFramingRectHeight);
-                requestedFramingRectWidth = 0;
-                requestedFramingRectHeight = 0;
-            }
-        }
-
-        Camera cameraObject = theCamera.getCamera();
-        Camera.Parameters parameters = cameraObject.getParameters();
-        String parametersFlattened = parameters == null ? null : parameters.flatten(); // Save these, temporarily
-        try {
-            configManager.setDesiredCameraParameters(theCamera, false);
-        } catch (RuntimeException re) {
-            // Driver failed
-            Log.w(TAG, "Camera rejected parameters. Setting only minimal safe-mode parameters");
-            Log.i(TAG, "Resetting to saved camera params: " + parametersFlattened);
-            // Reset:
-            if (parametersFlattened != null) {
-                parameters = cameraObject.getParameters();
-                parameters.unflatten(parametersFlattened);
-                try {
-                    cameraObject.setParameters(parameters);
-                    configManager.setDesiredCameraParameters(theCamera, true);
-                } catch (RuntimeException re2) {
-                    // Well, darn. Give up
-                    Log.w(TAG, "Camera rejected even safe-mode parameters! No configuration");
-                }
-            }
-        }
-        cameraObject.setPreviewDisplay(holder);
-
-    }
-
-    public synchronized boolean isOpen() {
-        return camera != null;
-    }
-
-    /**
-     * Closes the camera driver if still in use.
-     */
-    public synchronized void closeDriver() {
-        if (camera != null) {
-            camera.getCamera().release();
-            camera = null;
-            // Make sure to clear these each time we close the camera, so that any scanning rect
-            // requested by intent is forgotten.
-            framingRect = null;
-            framingRectInPreview = null;
-        }
-    }
-
-    /**
-     * Asks the camera hardware to begin drawing preview frames to the screen.
-     */
-    public synchronized void startPreview() {
-        OpenCamera theCamera = camera;
-        if (theCamera != null && !previewing) {
-            theCamera.getCamera().startPreview();
-            previewing = true;
-            autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());
-        }
-    }
-
-    /**
-     * Tells the camera to stop drawing preview frames.
-     */
-    public synchronized void stopPreview() {
-        if (autoFocusManager != null) {
-            autoFocusManager.stop();
-            autoFocusManager = null;
-        }
-        if (camera != null && previewing) {
-            camera.getCamera().stopPreview();
-            previewCallback.setHandler(null, 0);
-            previewing = false;
-        }
-    }
-
-    /**
-     * Convenience method for CaptureActivity
-     *
-     * @param newSetting if {@code true}, light should be turned on if currently off. And vice versa.
-     */
-    public synchronized void setTorch(boolean newSetting) {
-        OpenCamera theCamera = camera;
-        if (theCamera != null) {
-            if (newSetting != configManager.getTorchState(theCamera.getCamera())) {
-                boolean wasAutoFocusManager = autoFocusManager != null;
-                if (wasAutoFocusManager) {
-                    autoFocusManager.stop();
-                    autoFocusManager = null;
-                }
-                configManager.setTorch(theCamera.getCamera(), newSetting);
-                if (wasAutoFocusManager) {
-                    autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());
-                    autoFocusManager.start();
-                }
-            }
-        }
-    }
-
-    public synchronized boolean getTorch() {
-        OpenCamera theCamera = camera;
-        return theCamera != null && configManager.getTorchState(theCamera.getCamera());
-    }
-
-    /**
-     * A single preview frame will be returned to the handler supplied. The data will arrive as byte[]
-     * in the message.obj field, with width and height encoded as message.arg1 and message.arg2,
-     * respectively.
-     *
-     * @param handler The handler to send the message to.
-     * @param message The what field of the message to be sent.
-     */
-    public synchronized void requestPreviewFrame(Handler handler, int message) {
-        OpenCamera theCamera = camera;
-        if (theCamera != null && previewing) {
-            previewCallback.setHandler(handler, message);
-            theCamera.getCamera().setOneShotPreviewCallback(previewCallback);
-        }
-    }
-
-    /**
-     * Calculates the framing rect which the UI should draw to show the user where to place the
-     * barcode. This target helps with alignment as well as forces the user to hold the device
-     * far enough away to ensure the image will be in focus.
-     *
-     * @return The rectangle to draw on screen in window coordinates.
-     */
-    public synchronized Rect getFramingRect() {
-        if (framingRect == null) {
-            if (camera == null) {
-                return null;
-            }
-
-            // 获取屏幕的尺寸像素
-            Point screenResolution = configManager.getScreenResolution();
-            if (screenResolution == null) {
-                // Called early, before init even finished
-                return null;
-            }
-
-            int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);
-            //int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
-            int height = width;
-            int leftOffset = (screenResolution.x - width) / 2;
-            int topOffset = (screenResolution.y - height) / 3;
-            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);
-            Log.d(TAG, "Calculated framing rect: " + framingRect);
-        }
-        return framingRect;
-    }
-
-    public static int findDesiredDimensionInRange(int resolution, int hardMin, int hardMax) {
-        int dim = 5 * resolution / 8; // Target 5/8 of each dimension
-        if (dim < hardMin) {
-            return hardMin;
-        }
-        if (dim > hardMax) {
-            return hardMax;
-        }
-        return dim;
-    }
-
-    /**
-     * Like {@link #getFramingRect} but coordinates are in terms of the preview frame,
-     * not UI / screen.
-     *
-     * @return {@link Rect} expressing barcode scan area in terms of the preview size
-     */
-    public synchronized Rect getFramingRectInPreview() {
-        if (framingRectInPreview == null) {
-            Rect framingRect = getFramingRect();
-            if (framingRect == null) {
-                return null;
-            }
-
-            // 获取相机分辨率和屏幕分辨率
-            Rect rect = new Rect(framingRect);
-            Point cameraResolution = configManager.getCameraResolution();
-            Point screenResolution = configManager.getScreenResolution();
-            if (cameraResolution == null || screenResolution == null) {
-                // Called early, before init even finished
-                return null;
-            }
-
-            // 根据相机分辨率和屏幕分辨率的比例对屏幕中央聚焦框进行调整
-            rect.left = rect.left * cameraResolution.x / screenResolution.x;
-            rect.right = rect.right * cameraResolution.x / screenResolution.x;
-            rect.top = rect.top * cameraResolution.y / screenResolution.y;
-            rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;
-            framingRectInPreview = rect;
-        }
-        return framingRectInPreview;
-    }
-
-
-    /**
-     * Allows third party apps to specify the camera ID, rather than determine
-     * it automatically based on available cameras and their orientation.
-     *
-     * @param cameraId camera ID of the camera to use. A negative value means "no preference".
-     */
-    public synchronized void setManualCameraId(int cameraId) {
-        requestedCameraId = cameraId;
-    }
-
-    /**
-     * Allows third party apps to specify the scanning rectangle dimensions, rather than determine
-     * them automatically based on screen resolution.
-     *
-     * @param width  The width in pixels to scan.
-     * @param height The height in pixels to scan.
-     */
-    public synchronized void setManualFramingRect(int width, int height) {
-        if (initialized) {
-            Point screenResolution = configManager.getScreenResolution();
-            if (width > screenResolution.x) {
-                width = screenResolution.x;
-            }
-            if (height > screenResolution.y) {
-                height = screenResolution.y;
-            }
-            int leftOffset = (screenResolution.x - width) / 2;
-            int topOffset = (screenResolution.y - height) / 2;
-            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);
-            Log.d(TAG, "Calculated manual framing rect: " + framingRect);
-            framingRectInPreview = null;
-        } else {
-            requestedFramingRectWidth = width;
-            requestedFramingRectHeight = height;
-        }
-    }
-
-    /**
-     * A factory method to build the appropriate LuminanceSource object based on the format
-     * of the preview buffers, as described by Camera.Parameters.
-     *
-     * @param data   A preview frame.
-     * @param width  The width of the image.
-     * @param height The height of the image.
-     * @return A PlanarYUVLuminanceSource instance.
-     */
-    public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int height) {
-        // 取得预览框内的矩形
-//        Rect rect = getFramingRectInPreview();
-//        if (rect == null) {
-//            return null;
-//        }
-//
-//        // Go ahead and assume it's YUV rather than die.
-//        return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,
-//                rect.width(), rect.height(), false);
-
-        // 直接返回整幅图像的数据，而不计算聚焦框大小。
-        return new PlanarYUVLuminanceSource(data, width, height, 0, 0, width, height, false);
-    }
-
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.hardware.Camera;
+import android.os.Handler;
+import android.util.Log;
+import android.view.SurfaceHolder;
+
+import com.android.contacts.util.barcode.camera.open.OpenCamera;
+import com.android.contacts.util.barcode.camera.open.OpenCameraInterface;
+import com.google.zxing.PlanarYUVLuminanceSource;
+
+import java.io.IOException;
+
+
+/**
+ * This object wraps the Camera service object and expects to be the only one talking to it. The
+ * implementation encapsulates the steps needed to take preview-sized images, which are used for
+ * both preview and decoding.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class CameraManager {
+
+    private static final String TAG = CameraManager.class.getSimpleName();
+
+    private static final int MIN_FRAME_WIDTH = 240;
+    public static final int MIN_FRAME_HEIGHT = 240;
+    private static final int MAX_FRAME_WIDTH = 1200; // = 5/8 * 1920
+    public static final int MAX_FRAME_HEIGHT = 675; // = 5/8 * 1080
+
+    private final Context context;
+    private final CameraConfigurationManager configManager;
+    private OpenCamera camera;
+    private AutoFocusManager autoFocusManager;
+    private Rect framingRect;
+    private Rect framingRectInPreview;
+    private boolean initialized;
+    private boolean previewing;
+    private int requestedCameraId = OpenCameraInterface.NO_REQUESTED_CAMERA;
+    private int requestedFramingRectWidth;
+    private int requestedFramingRectHeight;
+    /**
+     * Preview frames are delivered here, which we pass on to the registered handler. Make sure to
+     * clear the handler so it will only receive one message.
+     */
+    private final PreviewCallback previewCallback;
+
+    public CameraManager(Context context) {
+        this.context = context;
+        this.configManager = new CameraConfigurationManager(context);
+        previewCallback = new PreviewCallback(configManager);
+    }
+
+    /**
+     * Opens the camera driver and initializes the hardware parameters.
+     *
+     * @param holder The surface object which the camera will draw preview frames into.
+     * @throws IOException Indicates the camera driver failed to open.
+     */
+    public synchronized void openDriver(SurfaceHolder holder) throws IOException {
+        OpenCamera theCamera = camera;
+        if (theCamera == null) {
+            theCamera = OpenCameraInterface.open(requestedCameraId);
+            if (theCamera == null) {
+                throw new IOException("Camera.open() failed to return object from driver");
+            }
+            camera = theCamera;
+        }
+
+        if (!initialized) {
+            initialized = true;
+            configManager.initFromCameraParameters(theCamera);
+            if (requestedFramingRectWidth > 0 && requestedFramingRectHeight > 0) {
+                setManualFramingRect(requestedFramingRectWidth, requestedFramingRectHeight);
+                requestedFramingRectWidth = 0;
+                requestedFramingRectHeight = 0;
+            }
+        }
+
+        Camera cameraObject = theCamera.getCamera();
+        Camera.Parameters parameters = cameraObject.getParameters();
+        String parametersFlattened = parameters == null ? null : parameters.flatten(); // Save these, temporarily
+        try {
+            configManager.setDesiredCameraParameters(theCamera, false);
+        } catch (RuntimeException re) {
+            // Driver failed
+            Log.w(TAG, "Camera rejected parameters. Setting only minimal safe-mode parameters");
+            Log.i(TAG, "Resetting to saved camera params: " + parametersFlattened);
+            // Reset:
+            if (parametersFlattened != null) {
+                parameters = cameraObject.getParameters();
+                parameters.unflatten(parametersFlattened);
+                try {
+                    cameraObject.setParameters(parameters);
+                    configManager.setDesiredCameraParameters(theCamera, true);
+                } catch (RuntimeException re2) {
+                    // Well, darn. Give up
+                    Log.w(TAG, "Camera rejected even safe-mode parameters! No configuration");
+                }
+            }
+        }
+        cameraObject.setPreviewDisplay(holder);
+
+    }
+
+    public synchronized boolean isOpen() {
+        return camera != null;
+    }
+
+    /**
+     * Closes the camera driver if still in use.
+     */
+    public synchronized void closeDriver() {
+        if (camera != null) {
+            camera.getCamera().release();
+            camera = null;
+            // Make sure to clear these each time we close the camera, so that any scanning rect
+            // requested by intent is forgotten.
+            framingRect = null;
+            framingRectInPreview = null;
+        }
+    }
+
+    /**
+     * Asks the camera hardware to begin drawing preview frames to the screen.
+     */
+    public synchronized void startPreview() {
+        OpenCamera theCamera = camera;
+        if (theCamera != null && !previewing) {
+            theCamera.getCamera().startPreview();
+            previewing = true;
+            autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());
+        }
+    }
+
+    /**
+     * Tells the camera to stop drawing preview frames.
+     */
+    public synchronized void stopPreview() {
+        if (autoFocusManager != null) {
+            autoFocusManager.stop();
+            autoFocusManager = null;
+        }
+        if (camera != null && previewing) {
+            camera.getCamera().stopPreview();
+            previewCallback.setHandler(null, 0);
+            previewing = false;
+        }
+    }
+
+    /**
+     * Convenience method for CaptureActivity
+     *
+     * @param newSetting if {@code true}, light should be turned on if currently off. And vice versa.
+     */
+    public synchronized void setTorch(boolean newSetting) {
+        OpenCamera theCamera = camera;
+        if (theCamera != null) {
+            if (newSetting != configManager.getTorchState(theCamera.getCamera())) {
+                boolean wasAutoFocusManager = autoFocusManager != null;
+                if (wasAutoFocusManager) {
+                    autoFocusManager.stop();
+                    autoFocusManager = null;
+                }
+                configManager.setTorch(theCamera.getCamera(), newSetting);
+                if (wasAutoFocusManager) {
+                    autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());
+                    autoFocusManager.start();
+                }
+            }
+        }
+    }
+
+    public synchronized boolean getTorch() {
+        OpenCamera theCamera = camera;
+        return theCamera != null && configManager.getTorchState(theCamera.getCamera());
+    }
+
+    /**
+     * A single preview frame will be returned to the handler supplied. The data will arrive as byte[]
+     * in the message.obj field, with width and height encoded as message.arg1 and message.arg2,
+     * respectively.
+     *
+     * @param handler The handler to send the message to.
+     * @param message The what field of the message to be sent.
+     */
+    public synchronized void requestPreviewFrame(Handler handler, int message) {
+        OpenCamera theCamera = camera;
+        if (theCamera != null && previewing) {
+            previewCallback.setHandler(handler, message);
+            theCamera.getCamera().setOneShotPreviewCallback(previewCallback);
+        }
+    }
+
+    /**
+     * Calculates the framing rect which the UI should draw to show the user where to place the
+     * barcode. This target helps with alignment as well as forces the user to hold the device
+     * far enough away to ensure the image will be in focus.
+     *
+     * @return The rectangle to draw on screen in window coordinates.
+     */
+    public synchronized Rect getFramingRect() {
+        if (framingRect == null) {
+            if (camera == null) {
+                return null;
+            }
+
+            // 获取屏幕的尺寸像素
+            Point screenResolution = configManager.getScreenResolution();
+            if (screenResolution == null) {
+                // Called early, before init even finished
+                return null;
+            }
+
+            int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);
+            //int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
+            int height = width;
+            int leftOffset = (screenResolution.x - width) / 2;
+            int topOffset = (screenResolution.y - height) / 3;
+            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);
+            Log.d(TAG, "Calculated framing rect: " + framingRect);
+        }
+        return framingRect;
+    }
+
+    public static int findDesiredDimensionInRange(int resolution, int hardMin, int hardMax) {
+        int dim = 5 * resolution / 8; // Target 5/8 of each dimension
+        if (dim < hardMin) {
+            return hardMin;
+        }
+        if (dim > hardMax) {
+            return hardMax;
+        }
+        return dim;
+    }
+
+    /**
+     * Like {@link #getFramingRect} but coordinates are in terms of the preview frame,
+     * not UI / screen.
+     *
+     * @return {@link Rect} expressing barcode scan area in terms of the preview size
+     */
+    public synchronized Rect getFramingRectInPreview() {
+        if (framingRectInPreview == null) {
+            Rect framingRect = getFramingRect();
+            if (framingRect == null) {
+                return null;
+            }
+
+            // 获取相机分辨率和屏幕分辨率
+            Rect rect = new Rect(framingRect);
+            Point cameraResolution = configManager.getCameraResolution();
+            Point screenResolution = configManager.getScreenResolution();
+            if (cameraResolution == null || screenResolution == null) {
+                // Called early, before init even finished
+                return null;
+            }
+
+            // 根据相机分辨率和屏幕分辨率的比例对屏幕中央聚焦框进行调整
+            rect.left = rect.left * cameraResolution.x / screenResolution.x;
+            rect.right = rect.right * cameraResolution.x / screenResolution.x;
+            rect.top = rect.top * cameraResolution.y / screenResolution.y;
+            rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;
+            framingRectInPreview = rect;
+        }
+        return framingRectInPreview;
+    }
+
+
+    /**
+     * Allows third party apps to specify the camera ID, rather than determine
+     * it automatically based on available cameras and their orientation.
+     *
+     * @param cameraId camera ID of the camera to use. A negative value means "no preference".
+     */
+    public synchronized void setManualCameraId(int cameraId) {
+        requestedCameraId = cameraId;
+    }
+
+    /**
+     * Allows third party apps to specify the scanning rectangle dimensions, rather than determine
+     * them automatically based on screen resolution.
+     *
+     * @param width  The width in pixels to scan.
+     * @param height The height in pixels to scan.
+     */
+    public synchronized void setManualFramingRect(int width, int height) {
+        if (initialized) {
+            Point screenResolution = configManager.getScreenResolution();
+            if (width > screenResolution.x) {
+                width = screenResolution.x;
+            }
+            if (height > screenResolution.y) {
+                height = screenResolution.y;
+            }
+            int leftOffset = (screenResolution.x - width) / 2;
+            int topOffset = (screenResolution.y - height) / 2;
+            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);
+            Log.d(TAG, "Calculated manual framing rect: " + framingRect);
+            framingRectInPreview = null;
+        } else {
+            requestedFramingRectWidth = width;
+            requestedFramingRectHeight = height;
+        }
+    }
+
+    /**
+     * A factory method to build the appropriate LuminanceSource object based on the format
+     * of the preview buffers, as described by Camera.Parameters.
+     *
+     * @param data   A preview frame.
+     * @param width  The width of the image.
+     * @param height The height of the image.
+     * @return A PlanarYUVLuminanceSource instance.
+     */
+    public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int height) {
+        // 取得预览框内的矩形
+//        Rect rect = getFramingRectInPreview();
+//        if (rect == null) {
+//            return null;
+//        }
+//
+//        // Go ahead and assume it's YUV rather than die.
+//        return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,
+//                rect.width(), rect.height(), false);
+
+        // 直接返回整幅图像的数据，而不计算聚焦框大小。
+        return new PlanarYUVLuminanceSource(data, width, height, 0, 0, width, height, false);
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/PreviewCallback.java b/src/com/android/contacts/util/barcode/camera/PreviewCallback.java
index 2c33d5b..c47aeb4 100644
--- a/src/com/android/contacts/util/barcode/camera/PreviewCallback.java
+++ b/src/com/android/contacts/util/barcode/camera/PreviewCallback.java
@@ -1,56 +1,56 @@
-/*
- * Copyright (C) 2010 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.camera;
-
-import android.graphics.Point;
-import android.hardware.Camera;
-import android.os.Handler;
-import android.os.Message;
-import android.util.Log;
-
-final class PreviewCallback implements Camera.PreviewCallback {
-
-    private static final String TAG = PreviewCallback.class.getSimpleName();
-
-    private final CameraConfigurationManager configManager;
-    private Handler previewHandler;
-    private int previewMessage;
-
-    PreviewCallback(CameraConfigurationManager configManager) {
-        this.configManager = configManager;
-    }
-
-    void setHandler(Handler previewHandler, int previewMessage) {
-        this.previewHandler = previewHandler;
-        this.previewMessage = previewMessage;
-    }
-
-    @Override
-    public void onPreviewFrame(byte[] data, Camera camera) {
-        Point cameraResolution = configManager.getCameraResolution();
-        Handler thePreviewHandler = previewHandler;
-        if (cameraResolution != null && thePreviewHandler != null) {
-            Message message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.x,
-                    cameraResolution.y, data);
-            message.sendToTarget();
-            previewHandler = null;
-        } else {
-            Log.d(TAG, "Got preview callback, but no handler or resolution available");
-        }
-    }
-
-}
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera;
+
+import android.graphics.Point;
+import android.hardware.Camera;
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+
+final class PreviewCallback implements Camera.PreviewCallback {
+
+    private static final String TAG = PreviewCallback.class.getSimpleName();
+
+    private final CameraConfigurationManager configManager;
+    private Handler previewHandler;
+    private int previewMessage;
+
+    PreviewCallback(CameraConfigurationManager configManager) {
+        this.configManager = configManager;
+    }
+
+    void setHandler(Handler previewHandler, int previewMessage) {
+        this.previewHandler = previewHandler;
+        this.previewMessage = previewMessage;
+    }
+
+    @Override
+    public void onPreviewFrame(byte[] data, Camera camera) {
+        Point cameraResolution = configManager.getCameraResolution();
+        Handler thePreviewHandler = previewHandler;
+        if (cameraResolution != null && thePreviewHandler != null) {
+            Message message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.x,
+                    cameraResolution.y, data);
+            message.sendToTarget();
+            previewHandler = null;
+        } else {
+            Log.d(TAG, "Got preview callback, but no handler or resolution available");
+        }
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/open/CameraFacing.java b/src/com/android/contacts/util/barcode/camera/open/CameraFacing.java
index 3c34e75..633a6ea 100644
--- a/src/com/android/contacts/util/barcode/camera/open/CameraFacing.java
+++ b/src/com/android/contacts/util/barcode/camera/open/CameraFacing.java
@@ -1,25 +1,25 @@
-/*
- * Copyright (C) 2015 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.camera.open;
-
-/**
- * Enumeration of directions a camera may face: front or back.
- */
-public enum CameraFacing {
-  BACK,  // must be value 0!
-  FRONT, // must be value 1!
-}
+/*
+ * Copyright (C) 2015 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera.open;
+
+/**
+ * Enumeration of directions a camera may face: front or back.
+ */
+public enum CameraFacing {
+  BACK,  // must be value 0!
+  FRONT, // must be value 1!
+}
diff --git a/src/com/android/contacts/util/barcode/camera/open/OpenCamera.java b/src/com/android/contacts/util/barcode/camera/open/OpenCamera.java
index c61bbef..969b41c 100644
--- a/src/com/android/contacts/util/barcode/camera/open/OpenCamera.java
+++ b/src/com/android/contacts/util/barcode/camera/open/OpenCamera.java
@@ -1,55 +1,55 @@
-/*
- * Copyright (C) 2015 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.camera.open;
-
-import android.hardware.Camera;
-
-/**
- * Represents an open Camera and its metadata, like facing direction and orientation.
- */
-public final class OpenCamera {
-  
-  private final int index;
-  private final Camera camera;
-  private final CameraFacing facing;
-  private final int orientation;
-  
-  public OpenCamera(int index, Camera camera, CameraFacing facing, int orientation) {
-    this.index = index;
-    this.camera = camera;
-    this.facing = facing;
-    this.orientation = orientation;
-  }
-
-  public Camera getCamera() {
-    return camera;
-  }
-
-  public CameraFacing getFacing() {
-    return facing;
-  }
-
-  public int getOrientation() {
-    return orientation;
-  }
-
-  @Override
-  public String toString() {
-    return "Camera #" + index + " : " + facing + ',' + orientation;
-  }
-
-}
+/*
+ * Copyright (C) 2015 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera.open;
+
+import android.hardware.Camera;
+
+/**
+ * Represents an open Camera and its metadata, like facing direction and orientation.
+ */
+public final class OpenCamera {
+  
+  private final int index;
+  private final Camera camera;
+  private final CameraFacing facing;
+  private final int orientation;
+  
+  public OpenCamera(int index, Camera camera, CameraFacing facing, int orientation) {
+    this.index = index;
+    this.camera = camera;
+    this.facing = facing;
+    this.orientation = orientation;
+  }
+
+  public Camera getCamera() {
+    return camera;
+  }
+
+  public CameraFacing getFacing() {
+    return facing;
+  }
+
+  public int getOrientation() {
+    return orientation;
+  }
+
+  @Override
+  public String toString() {
+    return "Camera #" + index + " : " + facing + ',' + orientation;
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/open/OpenCameraInterface.java b/src/com/android/contacts/util/barcode/camera/open/OpenCameraInterface.java
index c926747..7dff342 100644
--- a/src/com/android/contacts/util/barcode/camera/open/OpenCameraInterface.java
+++ b/src/com/android/contacts/util/barcode/camera/open/OpenCameraInterface.java
@@ -1,98 +1,98 @@
-/*
- * Copyright (C) 2012 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.camera.open;
-
-import android.hardware.Camera;
-import android.util.Log;
-
-/**
- * Abstraction over the Camera API that helps open them and return their metadata.
- */
-public final class OpenCameraInterface {
-
-  private static final String TAG = OpenCameraInterface.class.getName();
-
-  private OpenCameraInterface() {
-  }
-
-  /** For {@link #open(int)}, means no preference for which camera to open. */
-  public static final int NO_REQUESTED_CAMERA = -1;
-
-  /**
-   * Opens the requested camera with {@link Camera#open(int)}, if one exists.
-   *
-   * @param cameraId camera ID of the camera to use. A negative value
-   *  or {@link #NO_REQUESTED_CAMERA} means "no preference", in which case a rear-facing
-   *  camera is returned if possible or else any camera
-   * @return handle to {@link OpenCamera} that was opened
-   */
-  public static OpenCamera open(int cameraId) {
-
-    int numCameras = Camera.getNumberOfCameras();
-    if (numCameras == 0) {
-      Log.w(TAG, "No cameras!");
-      return null;
-    }
-
-    boolean explicitRequest = cameraId >= 0;
-
-    Camera.CameraInfo selectedCameraInfo = null;
-    int index;
-    if (explicitRequest) {
-      index = cameraId;
-      selectedCameraInfo = new Camera.CameraInfo();
-      Camera.getCameraInfo(index, selectedCameraInfo);
-    } else {
-      index = 0;
-      while (index < numCameras) {
-        Camera.CameraInfo cameraInfo = new Camera.CameraInfo();
-        Camera.getCameraInfo(index, cameraInfo);
-        CameraFacing reportedFacing = CameraFacing.values()[cameraInfo.facing];
-        if (reportedFacing == CameraFacing.BACK) {
-          selectedCameraInfo = cameraInfo;
-          break;
-        }
-        index++;
-      }
-    }
-
-    Camera camera;
-    if (index < numCameras) {
-      Log.i(TAG, "Opening camera #" + index);
-      camera = Camera.open(index);
-    } else {
-      if (explicitRequest) {
-        Log.w(TAG, "Requested camera does not exist: " + cameraId);
-        camera = null;
-      } else {
-        Log.i(TAG, "No camera facing " + CameraFacing.BACK + "; returning camera #0");
-        camera = Camera.open(0);
-        selectedCameraInfo = new Camera.CameraInfo();
-        Camera.getCameraInfo(0, selectedCameraInfo);
-      }
-    }
-
-    if (camera == null) {
-      return null;
-    }
-    return new OpenCamera(index,
-                          camera,
-                          CameraFacing.values()[selectedCameraInfo.facing],
-                          selectedCameraInfo.orientation);
-  }
-
-}
+/*
+ * Copyright (C) 2012 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera.open;
+
+import android.hardware.Camera;
+import android.util.Log;
+
+/**
+ * Abstraction over the Camera API that helps open them and return their metadata.
+ */
+public final class OpenCameraInterface {
+
+  private static final String TAG = OpenCameraInterface.class.getName();
+
+  private OpenCameraInterface() {
+  }
+
+  /** For {@link #open(int)}, means no preference for which camera to open. */
+  public static final int NO_REQUESTED_CAMERA = -1;
+
+  /**
+   * Opens the requested camera with {@link Camera#open(int)}, if one exists.
+   *
+   * @param cameraId camera ID of the camera to use. A negative value
+   *  or {@link #NO_REQUESTED_CAMERA} means "no preference", in which case a rear-facing
+   *  camera is returned if possible or else any camera
+   * @return handle to {@link OpenCamera} that was opened
+   */
+  public static OpenCamera open(int cameraId) {
+
+    int numCameras = Camera.getNumberOfCameras();
+    if (numCameras == 0) {
+      Log.w(TAG, "No cameras!");
+      return null;
+    }
+
+    boolean explicitRequest = cameraId >= 0;
+
+    Camera.CameraInfo selectedCameraInfo = null;
+    int index;
+    if (explicitRequest) {
+      index = cameraId;
+      selectedCameraInfo = new Camera.CameraInfo();
+      Camera.getCameraInfo(index, selectedCameraInfo);
+    } else {
+      index = 0;
+      while (index < numCameras) {
+        Camera.CameraInfo cameraInfo = new Camera.CameraInfo();
+        Camera.getCameraInfo(index, cameraInfo);
+        CameraFacing reportedFacing = CameraFacing.values()[cameraInfo.facing];
+        if (reportedFacing == CameraFacing.BACK) {
+          selectedCameraInfo = cameraInfo;
+          break;
+        }
+        index++;
+      }
+    }
+
+    Camera camera;
+    if (index < numCameras) {
+      Log.i(TAG, "Opening camera #" + index);
+      camera = Camera.open(index);
+    } else {
+      if (explicitRequest) {
+        Log.w(TAG, "Requested camera does not exist: " + cameraId);
+        camera = null;
+      } else {
+        Log.i(TAG, "No camera facing " + CameraFacing.BACK + "; returning camera #0");
+        camera = Camera.open(0);
+        selectedCameraInfo = new Camera.CameraInfo();
+        Camera.getCameraInfo(0, selectedCameraInfo);
+      }
+    }
+
+    if (camera == null) {
+      return null;
+    }
+    return new OpenCamera(index,
+                          camera,
+                          CameraFacing.values()[selectedCameraInfo.facing],
+                          selectedCameraInfo.orientation);
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/result/AddressBookResultHandler.java b/src/com/android/contacts/util/barcode/result/AddressBookResultHandler.java
index 90c1588..fff24ca 100644
--- a/src/com/android/contacts/util/barcode/result/AddressBookResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/AddressBookResultHandler.java
@@ -1,219 +1,219 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-import android.graphics.Typeface;
-import android.telephony.PhoneNumberUtils;
-import android.text.Spannable;
-import android.text.SpannableString;
-import android.text.style.StyleSpan;
-
-import com.google.zxing.client.result.AddressBookParsedResult;
-import com.google.zxing.client.result.ParsedResult;
-
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-
-import com.android.contacts.R;
-
-
-/**
- * Handles address book entries.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class AddressBookResultHandler extends ResultHandler {
-
-  private static final DateFormat[] DATE_FORMATS = {
-    new SimpleDateFormat("yyyyMMdd", Locale.ENGLISH),
-    new SimpleDateFormat("yyyyMMdd'T'HHmmss", Locale.ENGLISH),
-    new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH),
-    new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.ENGLISH),
-  };
-  static {
-    for (DateFormat format : DATE_FORMATS) {
-      format.setLenient(false);
-    }
-  }
-
-  private static final int[] BUTTON_TEXTS = {
-    R.string.button_add_contact,
-    R.string.button_show_map,
-    R.string.button_dial,
-    R.string.button_email,
-  };
-
-  private final boolean[] fields;
-  private int buttonCount;
-
-  // This takes all the work out of figuring out which buttons/actions should be in which
-  // positions, based on which fields are present in this barcode.
-  private int mapIndexToAction(int index) {
-    if (index < buttonCount) {
-      int count = -1;
-      for (int x = 0; x < MAX_BUTTON_COUNT; x++) {
-        if (fields[x]) {
-          count++;
-        }
-        if (count == index) {
-          return x;
-        }
-      }
-    }
-    return -1;
-  }
-
-  public AddressBookResultHandler(Activity activity, ParsedResult result) {
-    super(activity, result);
-    AddressBookParsedResult addressResult = (AddressBookParsedResult) result;
-    String[] addresses = addressResult.getAddresses();
-    String[] phoneNumbers = addressResult.getPhoneNumbers();
-    String[] emails = addressResult.getEmails();
-
-    fields = new boolean[MAX_BUTTON_COUNT];
-    fields[0] = true; // Add contact is always available
-    fields[1] = addresses != null && addresses.length > 0 && addresses[0] != null && !addresses[0].isEmpty();
-    fields[2] = phoneNumbers != null && phoneNumbers.length > 0;
-    fields[3] = emails != null && emails.length > 0;
-
-    buttonCount = 0;
-    for (int x = 0; x < MAX_BUTTON_COUNT; x++) {
-      if (fields[x]) {
-        buttonCount++;
-      }
-    }
-  }
-
-  @Override
-  public int getButtonCount() {
-    return buttonCount;
-  }
-
-  @Override
-  public int getButtonText(int index) {
-    return BUTTON_TEXTS[mapIndexToAction(index)];
-  }
-
-  @Override
-  public void handleButtonPress(int index) {
-    AddressBookParsedResult addressResult = (AddressBookParsedResult) getResult();
-    String[] addresses = addressResult.getAddresses();
-    String address1 = addresses == null || addresses.length < 1 ? null : addresses[0];
-    String[] addressTypes = addressResult.getAddressTypes();
-    String address1Type = addressTypes == null || addressTypes.length < 1 ? null : addressTypes[0];
-    int action = mapIndexToAction(index);
-    switch (action) {
-      case 0:
-        addContact(addressResult.getNames(),
-                   addressResult.getNicknames(),
-                   addressResult.getPronunciation(),
-                   addressResult.getPhoneNumbers(),
-                   addressResult.getPhoneTypes(),
-                   addressResult.getEmails(),
-                   addressResult.getEmailTypes(),
-                   addressResult.getNote(),
-                   addressResult.getInstantMessenger(),
-                   address1,
-                   address1Type,
-                   addressResult.getOrg(),
-                   addressResult.getTitle(),
-                   addressResult.getURLs(),
-                   addressResult.getBirthday(),
-                   addressResult.getGeo());
-        break;
-      case 1:
-        searchMap(address1);
-        break;
-      case 2:
-        dialPhone(addressResult.getPhoneNumbers()[0]);
-        break;
-      case 3:
-        sendEmail(addressResult.getEmails(), null, null, null, null);
-        break;
-      default:
-        break;
-    }
-  }
-
-  private static Date parseDate(String s) {
-    for (DateFormat currentFormat : DATE_FORMATS) {
-      try {
-        return currentFormat.parse(s);
-      } catch (ParseException e) {
-        // continue
-      }
-    }
-    return null;
-  }
-
-  // Overriden so we can hyphenate phone numbers, format birthdays, and bold the name.
-  @Override
-  public CharSequence getDisplayContents() {
-    AddressBookParsedResult result = (AddressBookParsedResult) getResult();
-    StringBuilder contents = new StringBuilder(100);
-    ParsedResult.maybeAppend(result.getNames(), contents);
-    int namesLength = contents.length();
-
-    String pronunciation = result.getPronunciation();
-    if (pronunciation != null && !pronunciation.isEmpty()) {
-      contents.append("\n(");
-      contents.append(pronunciation);
-      contents.append(')');
-    }
-
-    ParsedResult.maybeAppend(result.getTitle(), contents);
-    ParsedResult.maybeAppend(result.getOrg(), contents);
-    ParsedResult.maybeAppend(result.getAddresses(), contents);
-    String[] numbers = result.getPhoneNumbers();
-    if (numbers != null) {
-      for (String number : numbers) {
-        if (number != null) {
-          ParsedResult.maybeAppend(PhoneNumberUtils.formatNumber(number), contents);
-        }
-      }
-    }
-    ParsedResult.maybeAppend(result.getEmails(), contents);
-    ParsedResult.maybeAppend(result.getURLs(), contents);
-
-    String birthday = result.getBirthday();
-    if (birthday != null && !birthday.isEmpty()) {
-      Date date = parseDate(birthday);
-      if (date != null) {
-        ParsedResult.maybeAppend(DateFormat.getDateInstance(DateFormat.MEDIUM).format(date.getTime()), contents);
-      }
-    }
-    ParsedResult.maybeAppend(result.getNote(), contents);
-
-    if (namesLength > 0) {
-      // Bold the full name to make it stand out a bit.
-      Spannable styled = new SpannableString(contents.toString());
-      styled.setSpan(new StyleSpan(Typeface.BOLD), 0, namesLength, 0);
-      return styled;
-    } else {
-      return contents.toString();
-    }
-  }
-
-  @Override
-  public int getDisplayTitle() {
-    return R.string.result_address_book;
-  }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+import android.graphics.Typeface;
+import android.telephony.PhoneNumberUtils;
+import android.text.Spannable;
+import android.text.SpannableString;
+import android.text.style.StyleSpan;
+
+import com.google.zxing.client.result.AddressBookParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+import com.android.contacts.R;
+
+
+/**
+ * Handles address book entries.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class AddressBookResultHandler extends ResultHandler {
+
+  private static final DateFormat[] DATE_FORMATS = {
+    new SimpleDateFormat("yyyyMMdd", Locale.ENGLISH),
+    new SimpleDateFormat("yyyyMMdd'T'HHmmss", Locale.ENGLISH),
+    new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH),
+    new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.ENGLISH),
+  };
+  static {
+    for (DateFormat format : DATE_FORMATS) {
+      format.setLenient(false);
+    }
+  }
+
+  private static final int[] BUTTON_TEXTS = {
+    R.string.button_add_contact,
+    R.string.button_show_map,
+    R.string.button_dial,
+    R.string.button_email,
+  };
+
+  private final boolean[] fields;
+  private int buttonCount;
+
+  // This takes all the work out of figuring out which buttons/actions should be in which
+  // positions, based on which fields are present in this barcode.
+  private int mapIndexToAction(int index) {
+    if (index < buttonCount) {
+      int count = -1;
+      for (int x = 0; x < MAX_BUTTON_COUNT; x++) {
+        if (fields[x]) {
+          count++;
+        }
+        if (count == index) {
+          return x;
+        }
+      }
+    }
+    return -1;
+  }
+
+  public AddressBookResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+    AddressBookParsedResult addressResult = (AddressBookParsedResult) result;
+    String[] addresses = addressResult.getAddresses();
+    String[] phoneNumbers = addressResult.getPhoneNumbers();
+    String[] emails = addressResult.getEmails();
+
+    fields = new boolean[MAX_BUTTON_COUNT];
+    fields[0] = true; // Add contact is always available
+    fields[1] = addresses != null && addresses.length > 0 && addresses[0] != null && !addresses[0].isEmpty();
+    fields[2] = phoneNumbers != null && phoneNumbers.length > 0;
+    fields[3] = emails != null && emails.length > 0;
+
+    buttonCount = 0;
+    for (int x = 0; x < MAX_BUTTON_COUNT; x++) {
+      if (fields[x]) {
+        buttonCount++;
+      }
+    }
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttonCount;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return BUTTON_TEXTS[mapIndexToAction(index)];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    AddressBookParsedResult addressResult = (AddressBookParsedResult) getResult();
+    String[] addresses = addressResult.getAddresses();
+    String address1 = addresses == null || addresses.length < 1 ? null : addresses[0];
+    String[] addressTypes = addressResult.getAddressTypes();
+    String address1Type = addressTypes == null || addressTypes.length < 1 ? null : addressTypes[0];
+    int action = mapIndexToAction(index);
+    switch (action) {
+      case 0:
+        addContact(addressResult.getNames(),
+                   addressResult.getNicknames(),
+                   addressResult.getPronunciation(),
+                   addressResult.getPhoneNumbers(),
+                   addressResult.getPhoneTypes(),
+                   addressResult.getEmails(),
+                   addressResult.getEmailTypes(),
+                   addressResult.getNote(),
+                   addressResult.getInstantMessenger(),
+                   address1,
+                   address1Type,
+                   addressResult.getOrg(),
+                   addressResult.getTitle(),
+                   addressResult.getURLs(),
+                   addressResult.getBirthday(),
+                   addressResult.getGeo());
+        break;
+      case 1:
+        searchMap(address1);
+        break;
+      case 2:
+        dialPhone(addressResult.getPhoneNumbers()[0]);
+        break;
+      case 3:
+        sendEmail(addressResult.getEmails(), null, null, null, null);
+        break;
+      default:
+        break;
+    }
+  }
+
+  private static Date parseDate(String s) {
+    for (DateFormat currentFormat : DATE_FORMATS) {
+      try {
+        return currentFormat.parse(s);
+      } catch (ParseException e) {
+        // continue
+      }
+    }
+    return null;
+  }
+
+  // Overriden so we can hyphenate phone numbers, format birthdays, and bold the name.
+  @Override
+  public CharSequence getDisplayContents() {
+    AddressBookParsedResult result = (AddressBookParsedResult) getResult();
+    StringBuilder contents = new StringBuilder(100);
+    ParsedResult.maybeAppend(result.getNames(), contents);
+    int namesLength = contents.length();
+
+    String pronunciation = result.getPronunciation();
+    if (pronunciation != null && !pronunciation.isEmpty()) {
+      contents.append("\n(");
+      contents.append(pronunciation);
+      contents.append(')');
+    }
+
+    ParsedResult.maybeAppend(result.getTitle(), contents);
+    ParsedResult.maybeAppend(result.getOrg(), contents);
+    ParsedResult.maybeAppend(result.getAddresses(), contents);
+    String[] numbers = result.getPhoneNumbers();
+    if (numbers != null) {
+      for (String number : numbers) {
+        if (number != null) {
+          ParsedResult.maybeAppend(PhoneNumberUtils.formatNumber(number), contents);
+        }
+      }
+    }
+    ParsedResult.maybeAppend(result.getEmails(), contents);
+    ParsedResult.maybeAppend(result.getURLs(), contents);
+
+    String birthday = result.getBirthday();
+    if (birthday != null && !birthday.isEmpty()) {
+      Date date = parseDate(birthday);
+      if (date != null) {
+        ParsedResult.maybeAppend(DateFormat.getDateInstance(DateFormat.MEDIUM).format(date.getTime()), contents);
+      }
+    }
+    ParsedResult.maybeAppend(result.getNote(), contents);
+
+    if (namesLength > 0) {
+      // Bold the full name to make it stand out a bit.
+      Spannable styled = new SpannableString(contents.toString());
+      styled.setSpan(new StyleSpan(Typeface.BOLD), 0, namesLength, 0);
+      return styled;
+    } else {
+      return contents.toString();
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_address_book;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/CalendarResultHandler.java b/src/com/android/contacts/util/barcode/result/CalendarResultHandler.java
index fd4f49a..585a13d 100644
--- a/src/com/android/contacts/util/barcode/result/CalendarResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/CalendarResultHandler.java
@@ -1,188 +1,188 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.Intent;
-import android.util.Log;
-
-import com.google.zxing.client.result.CalendarParsedResult;
-import com.google.zxing.client.result.ParsedResult;
-
-import java.text.DateFormat;
-import java.util.Date;
-
-import com.android.contacts.R;
-
-
-/**
- * Handles calendar entries encoded in QR Codes.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- * @author Sean Owen
- */
-public final class CalendarResultHandler extends ResultHandler {
-
-  private static final String TAG = CalendarResultHandler.class.getSimpleName();
-
-  private static final int[] buttons = {
-      R.string.button_add_calendar
-  };
-
-  public CalendarResultHandler(Activity activity, ParsedResult result) {
-    super(activity, result);
-  }
-
-  @Override
-  public int getButtonCount() {
-    return buttons.length;
-  }
-
-  @Override
-  public int getButtonText(int index) {
-    return buttons[index];
-  }
-
-  @Override
-  public void handleButtonPress(int index) {
-    if (index == 0) {
-      CalendarParsedResult calendarResult = (CalendarParsedResult) getResult();
-
-      String description = calendarResult.getDescription();
-      String organizer = calendarResult.getOrganizer();
-      if (organizer != null) { // No separate Intent key, put in description
-        if (description == null) {
-          description = organizer;
-        } else {
-          description = description + '\n' + organizer;
-        }
-      }
-
-      addCalendarEvent(calendarResult.getSummary(),
-                       calendarResult.getStart(),
-                       calendarResult.isStartAllDay(),
-                       calendarResult.getEnd(),
-                       calendarResult.getLocation(),
-                       description,
-                       calendarResult.getAttendees());
-    }
-  }
-
-  /**
-   * Sends an intent to create a new calendar event by prepopulating the Add Event UI. Older
-   * versions of the system have a bug where the event title will not be filled out.
-   *
-   * @param summary A description of the event
-   * @param start   The start time
-   * @param allDay  if true, event is considered to be all day starting from start time
-   * @param end     The end time (optional)
-   * @param location a text description of the event location
-   * @param description a text description of the event itself
-   * @param attendees attendees to invite
-   */
-  private void addCalendarEvent(String summary,
-                                Date start,
-                                boolean allDay,
-                                Date end,
-                                String location,
-                                String description,
-                                String[] attendees) {
-    Intent intent = new Intent(Intent.ACTION_INSERT);
-    intent.setType("vnd.android.cursor.item/event");
-    long startMilliseconds = start.getTime();
-    intent.putExtra("beginTime", startMilliseconds);
-    if (allDay) {
-      intent.putExtra("allDay", true);
-    }
-    long endMilliseconds;
-    if (end == null) {
-      if (allDay) {
-        // + 1 day
-        endMilliseconds = startMilliseconds + 24 * 60 * 60 * 1000;
-      } else {
-        endMilliseconds = startMilliseconds;
-      }
-    } else {
-      endMilliseconds = end.getTime();
-    }
-    intent.putExtra("endTime", endMilliseconds);
-    intent.putExtra("title", summary);
-    intent.putExtra("eventLocation", location);
-    intent.putExtra("description", description);
-    if (attendees != null) {
-      intent.putExtra(Intent.EXTRA_EMAIL, attendees);
-      // Documentation says this is either a String[] or comma-separated String, which is right?
-    }
-
-    try {
-      // Do this manually at first
-      rawLaunchIntent(intent);
-    } catch (ActivityNotFoundException anfe) {
-      Log.w(TAG, "No calendar app available that responds to " + Intent.ACTION_INSERT);
-      // For calendar apps that don't like "INSERT":
-      intent.setAction(Intent.ACTION_EDIT);
-      launchIntent(intent); // Fail here for real if nothing can handle it
-    }
-  }
-
-
-  @Override
-  public CharSequence getDisplayContents() {
-
-    CalendarParsedResult calResult = (CalendarParsedResult) getResult();
-    StringBuilder result = new StringBuilder(100);
-
-    ParsedResult.maybeAppend(calResult.getSummary(), result);
-
-    Date start = calResult.getStart();
-    ParsedResult.maybeAppend(format(calResult.isStartAllDay(), start), result);
-
-    Date end = calResult.getEnd();
-    if (end != null) {
-      if (calResult.isEndAllDay() && !start.equals(end)) {
-        // Show only year/month/day
-        // if it's all-day and this is the end date, it's exclusive, so show the user
-        // that it ends on the day before to make more intuitive sense.
-        // But don't do it if the event already (incorrectly?) specifies the same start/end
-        end = new Date(end.getTime() - 24 * 60 * 60 * 1000);
-      }
-      ParsedResult.maybeAppend(format(calResult.isEndAllDay(), end), result);
-    }
-
-    ParsedResult.maybeAppend(calResult.getLocation(), result);
-    ParsedResult.maybeAppend(calResult.getOrganizer(), result);
-    ParsedResult.maybeAppend(calResult.getAttendees(), result);
-    ParsedResult.maybeAppend(calResult.getDescription(), result);
-    return result.toString();
-  }
-
-  private static String format(boolean allDay, Date date) {
-    if (date == null) {
-      return null;
-    }
-    DateFormat format = allDay
-        ? DateFormat.getDateInstance(DateFormat.MEDIUM)
-        : DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);
-    return format.format(date);
-  }
-
-  @Override
-  public int getDisplayTitle() {
-    return R.string.result_calendar;
-  }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.util.Log;
+
+import com.google.zxing.client.result.CalendarParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import java.text.DateFormat;
+import java.util.Date;
+
+import com.android.contacts.R;
+
+
+/**
+ * Handles calendar entries encoded in QR Codes.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ * @author Sean Owen
+ */
+public final class CalendarResultHandler extends ResultHandler {
+
+  private static final String TAG = CalendarResultHandler.class.getSimpleName();
+
+  private static final int[] buttons = {
+      R.string.button_add_calendar
+  };
+
+  public CalendarResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    if (index == 0) {
+      CalendarParsedResult calendarResult = (CalendarParsedResult) getResult();
+
+      String description = calendarResult.getDescription();
+      String organizer = calendarResult.getOrganizer();
+      if (organizer != null) { // No separate Intent key, put in description
+        if (description == null) {
+          description = organizer;
+        } else {
+          description = description + '\n' + organizer;
+        }
+      }
+
+      addCalendarEvent(calendarResult.getSummary(),
+                       calendarResult.getStart(),
+                       calendarResult.isStartAllDay(),
+                       calendarResult.getEnd(),
+                       calendarResult.getLocation(),
+                       description,
+                       calendarResult.getAttendees());
+    }
+  }
+
+  /**
+   * Sends an intent to create a new calendar event by prepopulating the Add Event UI. Older
+   * versions of the system have a bug where the event title will not be filled out.
+   *
+   * @param summary A description of the event
+   * @param start   The start time
+   * @param allDay  if true, event is considered to be all day starting from start time
+   * @param end     The end time (optional)
+   * @param location a text description of the event location
+   * @param description a text description of the event itself
+   * @param attendees attendees to invite
+   */
+  private void addCalendarEvent(String summary,
+                                Date start,
+                                boolean allDay,
+                                Date end,
+                                String location,
+                                String description,
+                                String[] attendees) {
+    Intent intent = new Intent(Intent.ACTION_INSERT);
+    intent.setType("vnd.android.cursor.item/event");
+    long startMilliseconds = start.getTime();
+    intent.putExtra("beginTime", startMilliseconds);
+    if (allDay) {
+      intent.putExtra("allDay", true);
+    }
+    long endMilliseconds;
+    if (end == null) {
+      if (allDay) {
+        // + 1 day
+        endMilliseconds = startMilliseconds + 24 * 60 * 60 * 1000;
+      } else {
+        endMilliseconds = startMilliseconds;
+      }
+    } else {
+      endMilliseconds = end.getTime();
+    }
+    intent.putExtra("endTime", endMilliseconds);
+    intent.putExtra("title", summary);
+    intent.putExtra("eventLocation", location);
+    intent.putExtra("description", description);
+    if (attendees != null) {
+      intent.putExtra(Intent.EXTRA_EMAIL, attendees);
+      // Documentation says this is either a String[] or comma-separated String, which is right?
+    }
+
+    try {
+      // Do this manually at first
+      rawLaunchIntent(intent);
+    } catch (ActivityNotFoundException anfe) {
+      Log.w(TAG, "No calendar app available that responds to " + Intent.ACTION_INSERT);
+      // For calendar apps that don't like "INSERT":
+      intent.setAction(Intent.ACTION_EDIT);
+      launchIntent(intent); // Fail here for real if nothing can handle it
+    }
+  }
+
+
+  @Override
+  public CharSequence getDisplayContents() {
+
+    CalendarParsedResult calResult = (CalendarParsedResult) getResult();
+    StringBuilder result = new StringBuilder(100);
+
+    ParsedResult.maybeAppend(calResult.getSummary(), result);
+
+    Date start = calResult.getStart();
+    ParsedResult.maybeAppend(format(calResult.isStartAllDay(), start), result);
+
+    Date end = calResult.getEnd();
+    if (end != null) {
+      if (calResult.isEndAllDay() && !start.equals(end)) {
+        // Show only year/month/day
+        // if it's all-day and this is the end date, it's exclusive, so show the user
+        // that it ends on the day before to make more intuitive sense.
+        // But don't do it if the event already (incorrectly?) specifies the same start/end
+        end = new Date(end.getTime() - 24 * 60 * 60 * 1000);
+      }
+      ParsedResult.maybeAppend(format(calResult.isEndAllDay(), end), result);
+    }
+
+    ParsedResult.maybeAppend(calResult.getLocation(), result);
+    ParsedResult.maybeAppend(calResult.getOrganizer(), result);
+    ParsedResult.maybeAppend(calResult.getAttendees(), result);
+    ParsedResult.maybeAppend(calResult.getDescription(), result);
+    return result.toString();
+  }
+
+  private static String format(boolean allDay, Date date) {
+    if (date == null) {
+      return null;
+    }
+    DateFormat format = allDay
+        ? DateFormat.getDateInstance(DateFormat.MEDIUM)
+        : DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);
+    return format.format(date);
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_calendar;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/EmailAddressResultHandler.java b/src/com/android/contacts/util/barcode/result/EmailAddressResultHandler.java
index 11a2b75..c66412c 100644
--- a/src/com/android/contacts/util/barcode/result/EmailAddressResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/EmailAddressResultHandler.java
@@ -1,72 +1,72 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-
-import com.google.zxing.client.result.EmailAddressParsedResult;
-import com.google.zxing.client.result.ParsedResult;
-
-import com.android.contacts.R;
-
-/**
- * Handles email addresses.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class EmailAddressResultHandler extends ResultHandler {
-  private static final int[] buttons = {
-      R.string.button_email,
-      R.string.button_add_contact
-  };
-
-  public EmailAddressResultHandler(Activity activity, ParsedResult result) {
-    super(activity, result);
-  }
-
-  @Override
-  public int getButtonCount() {
-    return buttons.length;
-  }
-
-  @Override
-  public int getButtonText(int index) {
-    return buttons[index];
-  }
-
-  @Override
-  public void handleButtonPress(int index) {
-    EmailAddressParsedResult emailResult = (EmailAddressParsedResult) getResult();
-    switch (index) {
-      case 0:
-        sendEmail(emailResult.getTos(),
-                  emailResult.getCCs(),
-                  emailResult.getBCCs(),
-                  emailResult.getSubject(),
-                  emailResult.getBody());
-        break;
-      case 1:
-        addEmailOnlyContact(emailResult.getTos(), null);
-        break;
-    }
-  }
-
-  @Override
-  public int getDisplayTitle() {
-    return R.string.result_email_address;
-  }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.client.result.EmailAddressParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.contacts.R;
+
+/**
+ * Handles email addresses.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class EmailAddressResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_email,
+      R.string.button_add_contact
+  };
+
+  public EmailAddressResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    EmailAddressParsedResult emailResult = (EmailAddressParsedResult) getResult();
+    switch (index) {
+      case 0:
+        sendEmail(emailResult.getTos(),
+                  emailResult.getCCs(),
+                  emailResult.getBCCs(),
+                  emailResult.getSubject(),
+                  emailResult.getBody());
+        break;
+      case 1:
+        addEmailOnlyContact(emailResult.getTos(), null);
+        break;
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_email_address;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/GeoResultHandler.java b/src/com/android/contacts/util/barcode/result/GeoResultHandler.java
index d838714..d1b6f7d 100644
--- a/src/com/android/contacts/util/barcode/result/GeoResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/GeoResultHandler.java
@@ -1,69 +1,69 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-
-import com.google.zxing.client.result.GeoParsedResult;
-import com.google.zxing.client.result.ParsedResult;
-
-import com.android.contacts.R;
-
-
-/**
- * Handles geographic coordinates (typically encoded as geo: URLs).
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class GeoResultHandler extends ResultHandler {
-    private static final int[] buttons = {
-            R.string.button_show_map,
-            R.string.button_get_directions
-    };
-
-    public GeoResultHandler(Activity activity, ParsedResult result) {
-        super(activity, result);
-    }
-
-    @Override
-    public int getButtonCount() {
-        return buttons.length;
-    }
-
-    @Override
-    public int getButtonText(int index) {
-        return buttons[index];
-    }
-
-    @Override
-    public void handleButtonPress(int index) {
-        GeoParsedResult geoResult = (GeoParsedResult) getResult();
-        switch (index) {
-            case 0:
-                openMap(geoResult.getGeoURI());
-                break;
-            case 1:
-                getDirections(geoResult.getLatitude(), geoResult.getLongitude());
-                break;
-        }
-    }
-
-    @Override
-    public int getDisplayTitle() {
-        return R.string.result_geo;
-    }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.client.result.GeoParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.contacts.R;
+
+
+/**
+ * Handles geographic coordinates (typically encoded as geo: URLs).
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class GeoResultHandler extends ResultHandler {
+    private static final int[] buttons = {
+            R.string.button_show_map,
+            R.string.button_get_directions
+    };
+
+    public GeoResultHandler(Activity activity, ParsedResult result) {
+        super(activity, result);
+    }
+
+    @Override
+    public int getButtonCount() {
+        return buttons.length;
+    }
+
+    @Override
+    public int getButtonText(int index) {
+        return buttons[index];
+    }
+
+    @Override
+    public void handleButtonPress(int index) {
+        GeoParsedResult geoResult = (GeoParsedResult) getResult();
+        switch (index) {
+            case 0:
+                openMap(geoResult.getGeoURI());
+                break;
+            case 1:
+                getDirections(geoResult.getLatitude(), geoResult.getLongitude());
+                break;
+        }
+    }
+
+    @Override
+    public int getDisplayTitle() {
+        return R.string.result_geo;
+    }
+}
diff --git a/src/com/android/contacts/util/barcode/result/ISBNResultHandler.java b/src/com/android/contacts/util/barcode/result/ISBNResultHandler.java
index 6271622..217bc3f 100644
--- a/src/com/android/contacts/util/barcode/result/ISBNResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/ISBNResultHandler.java
@@ -1,74 +1,74 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-
-import com.google.zxing.Result;
-import com.google.zxing.client.result.ISBNParsedResult;
-import com.google.zxing.client.result.ParsedResult;
-
-import com.android.contacts.R;
-
-/**
- * Handles books encoded by their ISBN values.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class ISBNResultHandler extends ResultHandler {
-  private static final int[] buttons = {
-      R.string.button_product_search,
-      R.string.button_book_search,
-      R.string.button_search_book_contents,
-      R.string.button_custom_product_search
-  };
-
-  public ISBNResultHandler(Activity activity, ParsedResult result, Result rawResult) {
-    super(activity, result, rawResult);
-  }
-
-  @Override
-  public int getButtonCount() {
-    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
-  }
-
-  @Override
-  public int getButtonText(int index) {
-    return buttons[index];
-  }
-
-  @Override
-  public void handleButtonPress(int index) {
-    ISBNParsedResult isbnResult = (ISBNParsedResult) getResult();
-    switch (index) {
-      case 0:
-        openProductSearch(isbnResult.getISBN());
-        break;
-      case 1:
-        openBookSearch(isbnResult.getISBN());
-        break;
-      case 3:
-        openURL(fillInCustomSearchURL(isbnResult.getISBN()));
-        break;
-    }
-  }
-
-  @Override
-  public int getDisplayTitle() {
-    return R.string.result_isbn;
-  }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ISBNParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.contacts.R;
+
+/**
+ * Handles books encoded by their ISBN values.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ISBNResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_product_search,
+      R.string.button_book_search,
+      R.string.button_search_book_contents,
+      R.string.button_custom_product_search
+  };
+
+  public ISBNResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+    super(activity, result, rawResult);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    ISBNParsedResult isbnResult = (ISBNParsedResult) getResult();
+    switch (index) {
+      case 0:
+        openProductSearch(isbnResult.getISBN());
+        break;
+      case 1:
+        openBookSearch(isbnResult.getISBN());
+        break;
+      case 3:
+        openURL(fillInCustomSearchURL(isbnResult.getISBN()));
+        break;
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_isbn;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/ProductResultHandler.java b/src/com/android/contacts/util/barcode/result/ProductResultHandler.java
index a648339..87cc831 100644
--- a/src/com/android/contacts/util/barcode/result/ProductResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/ProductResultHandler.java
@@ -1,85 +1,85 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-
-import com.google.zxing.Result;
-import com.google.zxing.client.result.ExpandedProductParsedResult;
-import com.google.zxing.client.result.ParsedResult;
-import com.google.zxing.client.result.ProductParsedResult;
-
-import com.android.contacts.R;
-
-
-/**
- * Handles generic products which are not books.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class ProductResultHandler extends ResultHandler {
-  private static final int[] buttons = {
-      R.string.button_product_search,
-      R.string.button_web_search,
-      R.string.button_custom_product_search
-  };
-
-  public ProductResultHandler(Activity activity, ParsedResult result, Result rawResult) {
-    super(activity, result, rawResult);
-  }
-
-  @Override
-  public int getButtonCount() {
-    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
-  }
-
-  @Override
-  public int getButtonText(int index) {
-    return buttons[index];
-  }
-
-  @Override
-  public void handleButtonPress(int index) {
-    String productID = getProductIDFromResult(getResult());
-    switch (index) {
-      case 0:
-        openProductSearch(productID);
-        break;
-      case 1:
-        webSearch(productID);
-        break;
-      case 2:
-        openURL(fillInCustomSearchURL(productID));
-        break;
-    }
-  }
-
-  private static String getProductIDFromResult(ParsedResult rawResult) {
-    if (rawResult instanceof ProductParsedResult) {
-      return ((ProductParsedResult) rawResult).getNormalizedProductID();
-    }
-    if (rawResult instanceof ExpandedProductParsedResult) {
-      return ((ExpandedProductParsedResult) rawResult).getRawText();
-    }
-    throw new IllegalArgumentException(rawResult.getClass().toString());
-  }
-
-  @Override
-  public int getDisplayTitle() {
-    return R.string.result_product;
-  }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ExpandedProductParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.ProductParsedResult;
+
+import com.android.contacts.R;
+
+
+/**
+ * Handles generic products which are not books.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ProductResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_product_search,
+      R.string.button_web_search,
+      R.string.button_custom_product_search
+  };
+
+  public ProductResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+    super(activity, result, rawResult);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    String productID = getProductIDFromResult(getResult());
+    switch (index) {
+      case 0:
+        openProductSearch(productID);
+        break;
+      case 1:
+        webSearch(productID);
+        break;
+      case 2:
+        openURL(fillInCustomSearchURL(productID));
+        break;
+    }
+  }
+
+  private static String getProductIDFromResult(ParsedResult rawResult) {
+    if (rawResult instanceof ProductParsedResult) {
+      return ((ProductParsedResult) rawResult).getNormalizedProductID();
+    }
+    if (rawResult instanceof ExpandedProductParsedResult) {
+      return ((ExpandedProductParsedResult) rawResult).getRawText();
+    }
+    throw new IllegalArgumentException(rawResult.getClass().toString());
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_product;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/ResultHandler.java b/src/com/android/contacts/util/barcode/result/ResultHandler.java
index 3e7bd95..da27264 100644
--- a/src/com/android/contacts/util/barcode/result/ResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/ResultHandler.java
@@ -1,497 +1,497 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.ActivityNotFoundException;
-import android.content.ContentValues;
-import android.content.Intent;
-import android.net.Uri;
-import android.provider.ContactsContract;
-import android.util.Log;
-
-import com.android.contacts.util.barcode.Contents;
-import com.android.contacts.util.barcode.LocaleManager;
-import com.google.zxing.Result;
-import com.google.zxing.client.result.ParsedResult;
-import com.google.zxing.client.result.ParsedResultType;
-import com.google.zxing.client.result.ResultParser;
-
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
-import java.util.ArrayList;
-import java.util.Locale;
-
-import com.android.contacts.R;
-
-
-/**
- * A base class for the Android-specific barcode handlers. These allow the app to polymorphically
- * suggest the appropriate actions for each data type.
- * <p>
- * This class also contains a bunch of utility methods to take common actions like opening a URL.
- * They could easily be moved into a helper object, but it can't be static because the Activity
- * instance is needed to launch an intent.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- * @author Sean Owen
- */
-public abstract class ResultHandler {
-
-    private static final String TAG = ResultHandler.class.getSimpleName();
-
-    private static final String[] EMAIL_TYPE_STRINGS = {"home", "work", "mobile"};
-    private static final String[] PHONE_TYPE_STRINGS = {"home", "work", "mobile", "fax", "pager", "main"};
-    private static final String[] ADDRESS_TYPE_STRINGS = {"home", "work"};
-    private static final int[] EMAIL_TYPE_VALUES = {
-            ContactsContract.CommonDataKinds.Email.TYPE_HOME,
-            ContactsContract.CommonDataKinds.Email.TYPE_WORK,
-            ContactsContract.CommonDataKinds.Email.TYPE_MOBILE,
-    };
-    private static final int[] PHONE_TYPE_VALUES = {
-            ContactsContract.CommonDataKinds.Phone.TYPE_HOME,
-            ContactsContract.CommonDataKinds.Phone.TYPE_WORK,
-            ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE,
-            ContactsContract.CommonDataKinds.Phone.TYPE_FAX_WORK,
-            ContactsContract.CommonDataKinds.Phone.TYPE_PAGER,
-            ContactsContract.CommonDataKinds.Phone.TYPE_MAIN,
-    };
-    private static final int[] ADDRESS_TYPE_VALUES = {
-            ContactsContract.CommonDataKinds.StructuredPostal.TYPE_HOME,
-            ContactsContract.CommonDataKinds.StructuredPostal.TYPE_WORK,
-    };
-    private static final int NO_TYPE = -1;
-
-    public static final int MAX_BUTTON_COUNT = 4;
-
-    private final ParsedResult result;
-    private final Activity activity;
-    private final Result rawResult;
-    private final String customProductSearch;
-
-    ResultHandler(Activity activity, ParsedResult result) {
-        this(activity, result, null);
-    }
-
-    ResultHandler(Activity activity, ParsedResult result, Result rawResult) {
-        this.result = result;
-        this.activity = activity;
-        this.rawResult = rawResult;
-        this.customProductSearch = parseCustomSearchURL();
-    }
-
-    public final ParsedResult getResult() {
-        return result;
-    }
-
-    final boolean hasCustomProductSearch() {
-        return customProductSearch != null;
-    }
-
-    final Activity getActivity() {
-        return activity;
-    }
-
-    /**
-     * Indicates how many buttons the derived class wants shown.
-     *
-     * @return The integer button count.
-     */
-    public abstract int getButtonCount();
-
-    /**
-     * The text of the nth action button.
-     *
-     * @param index From 0 to getButtonCount() - 1
-     * @return The button text as a resource ID
-     */
-    public abstract int getButtonText(int index);
-
-    public Integer getDefaultButtonID() {
-        return null;
-    }
-
-    /**
-     * Execute the action which corresponds to the nth button.
-     *
-     * @param index The button that was clicked.
-     */
-    public abstract void handleButtonPress(int index);
-
-    /**
-     * Some barcode contents are considered secure, and should not be saved to history, copied to
-     * the clipboard, or otherwise persisted.
-     *
-     * @return If true, do not create any permanent record of these contents.
-     */
-    public boolean areContentsSecure() {
-        return false;
-    }
-
-    /**
-     * Create a possibly styled string for the contents of the current barcode.
-     *
-     * @return The text to be displayed.
-     */
-    public CharSequence getDisplayContents() {
-        String contents = result.getDisplayResult();
-        return contents.replace("\r", "");
-    }
-
-    /**
-     * A string describing the kind of barcode that was found, e.g. "Found contact info".
-     *
-     * @return The resource ID of the string.
-     */
-    public abstract int getDisplayTitle();
-
-    /**
-     * A convenience method to get the parsed type. Should not be overridden.
-     *
-     * @return The parsed type, e.g. URI or ISBN
-     */
-    public final ParsedResultType getType() {
-        return result.getType();
-    }
-
-    final void addPhoneOnlyContact(String[] phoneNumbers, String[] phoneTypes) {
-        addContact(null, null, null, phoneNumbers, phoneTypes, null, null, null, null, null, null, null, null, null, null, null);
-    }
-
-    final void addEmailOnlyContact(String[] emails, String[] emailTypes) {
-        addContact(null, null, null, null, null, emails, emailTypes, null, null, null, null, null, null, null, null, null);
-    }
-
-    final void addContact(String[] names,
-                          String[] nicknames,
-                          String pronunciation,
-                          String[] phoneNumbers,
-                          String[] phoneTypes,
-                          String[] emails,
-                          String[] emailTypes,
-                          String note,
-                          String instantMessenger,
-                          String address,
-                          String addressType,
-                          String org,
-                          String title,
-                          String[] urls,
-                          String birthday,
-                          String[] geo) {
-
-        // Only use the first name in the array, if present.
-        Intent intent = new Intent(Intent.ACTION_INSERT_OR_EDIT, ContactsContract.Contacts.CONTENT_URI);
-        intent.setType(ContactsContract.Contacts.CONTENT_ITEM_TYPE);
-        putExtra(intent, ContactsContract.Intents.Insert.NAME, names != null ? names[0] : null);
-
-        putExtra(intent, ContactsContract.Intents.Insert.PHONETIC_NAME, pronunciation);
-
-        int phoneCount = Math.min(phoneNumbers != null ? phoneNumbers.length : 0, Contents.PHONE_KEYS.length);
-        for (int x = 0; x < phoneCount; x++) {
-            putExtra(intent, Contents.PHONE_KEYS[x], phoneNumbers[x]);
-            if (phoneTypes != null && x < phoneTypes.length) {
-                int type = toPhoneContractType(phoneTypes[x]);
-                if (type >= 0) {
-                    intent.putExtra(Contents.PHONE_TYPE_KEYS[x], type);
-                }
-            }
-        }
-
-        int emailCount = Math.min(emails != null ? emails.length : 0, Contents.EMAIL_KEYS.length);
-        for (int x = 0; x < emailCount; x++) {
-            putExtra(intent, Contents.EMAIL_KEYS[x], emails[x]);
-            if (emailTypes != null && x < emailTypes.length) {
-                int type = toEmailContractType(emailTypes[x]);
-                if (type >= 0) {
-                    intent.putExtra(Contents.EMAIL_TYPE_KEYS[x], type);
-                }
-            }
-        }
-
-        ArrayList<ContentValues> data = new ArrayList<>();
-        if (urls != null) {
-            for (String url : urls) {
-                if (url != null && !url.isEmpty()) {
-                    ContentValues row = new ContentValues(2);
-                    row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Website.CONTENT_ITEM_TYPE);
-                    row.put(ContactsContract.CommonDataKinds.Website.URL, url);
-                    data.add(row);
-                    break;
-                }
-            }
-        }
-
-        if (birthday != null) {
-            ContentValues row = new ContentValues(3);
-            row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
-            row.put(ContactsContract.CommonDataKinds.Event.TYPE, ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY);
-            row.put(ContactsContract.CommonDataKinds.Event.START_DATE, birthday);
-            data.add(row);
-        }
-
-        if (nicknames != null) {
-            for (String nickname : nicknames) {
-                if (nickname != null && !nickname.isEmpty()) {
-                    ContentValues row = new ContentValues(3);
-                    row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Nickname.CONTENT_ITEM_TYPE);
-                    row.put(ContactsContract.CommonDataKinds.Nickname.TYPE,
-                            ContactsContract.CommonDataKinds.Nickname.TYPE_DEFAULT);
-                    row.put(ContactsContract.CommonDataKinds.Nickname.NAME, nickname);
-                    data.add(row);
-                    break;
-                }
-            }
-        }
-
-        if (!data.isEmpty()) {
-            intent.putParcelableArrayListExtra(ContactsContract.Intents.Insert.DATA, data);
-        }
-
-        StringBuilder aggregatedNotes = new StringBuilder();
-        if (note != null) {
-            aggregatedNotes.append('\n').append(note);
-        }
-        if (geo != null) {
-            aggregatedNotes.append('\n').append(geo[0]).append(',').append(geo[1]);
-        }
-
-        if (aggregatedNotes.length() > 0) {
-            // Remove extra leading '\n'
-            putExtra(intent, ContactsContract.Intents.Insert.NOTES, aggregatedNotes.substring(1));
-        }
-
-        putExtra(intent, ContactsContract.Intents.Insert.IM_HANDLE, instantMessenger);
-        putExtra(intent, ContactsContract.Intents.Insert.POSTAL, address);
-        if (addressType != null) {
-            int type = toAddressContractType(addressType);
-            if (type >= 0) {
-                intent.putExtra(ContactsContract.Intents.Insert.POSTAL_TYPE, type);
-            }
-        }
-        putExtra(intent, ContactsContract.Intents.Insert.COMPANY, org);
-        putExtra(intent, ContactsContract.Intents.Insert.JOB_TITLE, title);
-        launchIntent(intent);
-    }
-
-    private static int toEmailContractType(String typeString) {
-        return doToContractType(typeString, EMAIL_TYPE_STRINGS, EMAIL_TYPE_VALUES);
-    }
-
-    private static int toPhoneContractType(String typeString) {
-        return doToContractType(typeString, PHONE_TYPE_STRINGS, PHONE_TYPE_VALUES);
-    }
-
-    private static int toAddressContractType(String typeString) {
-        return doToContractType(typeString, ADDRESS_TYPE_STRINGS, ADDRESS_TYPE_VALUES);
-    }
-
-    private static int doToContractType(String typeString, String[] types, int[] values) {
-        if (typeString == null) {
-            return NO_TYPE;
-        }
-        for (int i = 0; i < types.length; i++) {
-            String type = types[i];
-            if (typeString.startsWith(type) || typeString.startsWith(type.toUpperCase(Locale.ENGLISH))) {
-                return values[i];
-            }
-        }
-        return NO_TYPE;
-    }
-
-    final void shareByEmail(String contents) {
-        sendEmail(null, null, null, null, contents);
-    }
-
-    final void sendEmail(String[] to,
-                         String[] cc,
-                         String[] bcc,
-                         String subject,
-                         String body) {
-        Intent intent = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
-        if (to != null && to.length != 0) {
-            intent.putExtra(Intent.EXTRA_EMAIL, to);
-        }
-        if (cc != null && cc.length != 0) {
-            intent.putExtra(Intent.EXTRA_CC, cc);
-        }
-        if (bcc != null && bcc.length != 0) {
-            intent.putExtra(Intent.EXTRA_BCC, bcc);
-        }
-        putExtra(intent, Intent.EXTRA_SUBJECT, subject);
-        putExtra(intent, Intent.EXTRA_TEXT, body);
-        intent.setType("text/plain");
-        launchIntent(intent);
-    }
-
-    final void shareBySMS(String contents) {
-        sendSMSFromUri("smsto:", contents);
-    }
-
-    final void sendSMS(String phoneNumber, String body) {
-        sendSMSFromUri("smsto:" + phoneNumber, body);
-    }
-
-    private void sendSMSFromUri(String uri, String body) {
-        Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));
-        putExtra(intent, "sms_body", body);
-        // Exit the app once the SMS is sent
-        intent.putExtra("compose_mode", true);
-        launchIntent(intent);
-    }
-
-    final void sendMMS(String phoneNumber, String subject, String body) {
-        sendMMSFromUri("mmsto:" + phoneNumber, subject, body);
-    }
-
-    private void sendMMSFromUri(String uri, String subject, String body) {
-        Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));
-        // The Messaging app needs to see a valid subject or else it will treat this an an SMS.
-        if (subject == null || subject.isEmpty()) {
-            putExtra(intent, "subject", activity.getString(R.string.msg_default_mms_subject));
-        } else {
-            putExtra(intent, "subject", subject);
-        }
-        putExtra(intent, "sms_body", body);
-        intent.putExtra("compose_mode", true);
-        launchIntent(intent);
-    }
-
-    final void dialPhone(String phoneNumber) {
-        launchIntent(new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + phoneNumber)));
-    }
-
-    final void dialPhoneFromUri(String uri) {
-        launchIntent(new Intent(Intent.ACTION_DIAL, Uri.parse(uri)));
-    }
-
-    final void openMap(String geoURI) {
-        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(geoURI)));
-    }
-
-    /**
-     * Do a geo search using the address as the query.
-     *
-     * @param address The address to find
-     */
-    final void searchMap(String address) {
-        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse("geo:0,0?q=" + Uri.encode(address))));
-    }
-
-    final void getDirections(double latitude, double longitude) {
-        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse("http://maps.google." +
-                LocaleManager.getCountryTLD(activity) + "/maps?f=d&daddr=" + latitude + ',' + longitude)));
-    }
-
-    // Uses the mobile-specific version of Product Search, which is formatted for small screens.
-    final void openProductSearch(String upc) {
-        Uri uri = Uri.parse("http://www.google." + LocaleManager.getProductSearchCountryTLD(activity) +
-                "/m/products?q=" + upc + "&source=zxing");
-        launchIntent(new Intent(Intent.ACTION_VIEW, uri));
-    }
-
-    final void openBookSearch(String isbn) {
-        Uri uri = Uri.parse("http://books.google." + LocaleManager.getBookSearchCountryTLD(activity) +
-                "/books?vid=isbn" + isbn);
-        launchIntent(new Intent(Intent.ACTION_VIEW, uri));
-    }
-
-    final void openURL(String url) {
-        // Strangely, some Android browsers don't seem to register to handle HTTP:// or HTTPS://.
-        // Lower-case these as it should always be OK to lower-case these schemes.
-        if (url.startsWith("HTTP://")) {
-            url = "http" + url.substring(4);
-        } else if (url.startsWith("HTTPS://")) {
-            url = "https" + url.substring(5);
-        }
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        try {
-            launchIntent(intent);
-        } catch (ActivityNotFoundException ignored) {
-            Log.w(TAG, "Nothing available to handle " + intent);
-        }
-    }
-
-    final void webSearch(String query) {
-        Intent intent = new Intent(Intent.ACTION_WEB_SEARCH);
-        intent.putExtra("query", query);
-        launchIntent(intent);
-    }
-
-    /**
-     * Like {@link #launchIntent(Intent)} but will tell you if it is not handle-able
-     * via {@link ActivityNotFoundException}.
-     *
-     * @throws ActivityNotFoundException if Intent can't be handled
-     */
-    final void rawLaunchIntent(Intent intent) {
-        if (intent != null) {
-            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
-            Log.d(TAG, "Launching intent: " + intent + " with extras: " + intent.getExtras());
-            activity.startActivity(intent);
-        }
-    }
-
-    /**
-     * Like {@link #rawLaunchIntent(Intent)} but will show a user dialog if nothing is available to handle.
-     */
-    final void launchIntent(Intent intent) {
-        try {
-            rawLaunchIntent(intent);
-        } catch (ActivityNotFoundException ignored) {
-            AlertDialog.Builder builder = new AlertDialog.Builder(activity);
-            builder.setTitle(R.string.applicationLabel);
-            builder.setMessage(R.string.msg_intent_failed);
-            builder.setPositiveButton(android.R.string.ok, null);
-            builder.show();
-        }
-    }
-
-    private static void putExtra(Intent intent, String key, String value) {
-        if (value != null && !value.isEmpty()) {
-            intent.putExtra(key, value);
-        }
-    }
-
-    private String parseCustomSearchURL() {
-        return null;
-    }
-
-    final String fillInCustomSearchURL(String text) {
-        if (customProductSearch == null) {
-            return text; // ?
-        }
-        try {
-            text = URLEncoder.encode(text, "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            // can't happen; UTF-8 is always supported. Continue, I guess, without encoding
-        }
-        String url = customProductSearch;
-        if (rawResult != null) {
-            // Replace %f but only if it doesn't seem to be a hex escape sequence. This remains
-            // problematic but avoids the more surprising problem of breaking escapes
-            url = url.replaceFirst("%f(?![0-9a-f])", rawResult.getBarcodeFormat().toString());
-            if (url.contains("%t")) {
-                ParsedResult parsedResultAgain = ResultParser.parseResult(rawResult);
-                url = url.replace("%t", parsedResultAgain.getType().toString());
-            }
-        }
-        // Replace %s last as it might contain itself %f or %t
-        return url.replace("%s", text);
-    }
-
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ActivityNotFoundException;
+import android.content.ContentValues;
+import android.content.Intent;
+import android.net.Uri;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+import com.android.contacts.util.barcode.Contents;
+import com.android.contacts.util.barcode.LocaleManager;
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.ParsedResultType;
+import com.google.zxing.client.result.ResultParser;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.Locale;
+
+import com.android.contacts.R;
+
+
+/**
+ * A base class for the Android-specific barcode handlers. These allow the app to polymorphically
+ * suggest the appropriate actions for each data type.
+ * <p>
+ * This class also contains a bunch of utility methods to take common actions like opening a URL.
+ * They could easily be moved into a helper object, but it can't be static because the Activity
+ * instance is needed to launch an intent.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ * @author Sean Owen
+ */
+public abstract class ResultHandler {
+
+    private static final String TAG = ResultHandler.class.getSimpleName();
+
+    private static final String[] EMAIL_TYPE_STRINGS = {"home", "work", "mobile"};
+    private static final String[] PHONE_TYPE_STRINGS = {"home", "work", "mobile", "fax", "pager", "main"};
+    private static final String[] ADDRESS_TYPE_STRINGS = {"home", "work"};
+    private static final int[] EMAIL_TYPE_VALUES = {
+            ContactsContract.CommonDataKinds.Email.TYPE_HOME,
+            ContactsContract.CommonDataKinds.Email.TYPE_WORK,
+            ContactsContract.CommonDataKinds.Email.TYPE_MOBILE,
+    };
+    private static final int[] PHONE_TYPE_VALUES = {
+            ContactsContract.CommonDataKinds.Phone.TYPE_HOME,
+            ContactsContract.CommonDataKinds.Phone.TYPE_WORK,
+            ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE,
+            ContactsContract.CommonDataKinds.Phone.TYPE_FAX_WORK,
+            ContactsContract.CommonDataKinds.Phone.TYPE_PAGER,
+            ContactsContract.CommonDataKinds.Phone.TYPE_MAIN,
+    };
+    private static final int[] ADDRESS_TYPE_VALUES = {
+            ContactsContract.CommonDataKinds.StructuredPostal.TYPE_HOME,
+            ContactsContract.CommonDataKinds.StructuredPostal.TYPE_WORK,
+    };
+    private static final int NO_TYPE = -1;
+
+    public static final int MAX_BUTTON_COUNT = 4;
+
+    private final ParsedResult result;
+    private final Activity activity;
+    private final Result rawResult;
+    private final String customProductSearch;
+
+    ResultHandler(Activity activity, ParsedResult result) {
+        this(activity, result, null);
+    }
+
+    ResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+        this.result = result;
+        this.activity = activity;
+        this.rawResult = rawResult;
+        this.customProductSearch = parseCustomSearchURL();
+    }
+
+    public final ParsedResult getResult() {
+        return result;
+    }
+
+    final boolean hasCustomProductSearch() {
+        return customProductSearch != null;
+    }
+
+    final Activity getActivity() {
+        return activity;
+    }
+
+    /**
+     * Indicates how many buttons the derived class wants shown.
+     *
+     * @return The integer button count.
+     */
+    public abstract int getButtonCount();
+
+    /**
+     * The text of the nth action button.
+     *
+     * @param index From 0 to getButtonCount() - 1
+     * @return The button text as a resource ID
+     */
+    public abstract int getButtonText(int index);
+
+    public Integer getDefaultButtonID() {
+        return null;
+    }
+
+    /**
+     * Execute the action which corresponds to the nth button.
+     *
+     * @param index The button that was clicked.
+     */
+    public abstract void handleButtonPress(int index);
+
+    /**
+     * Some barcode contents are considered secure, and should not be saved to history, copied to
+     * the clipboard, or otherwise persisted.
+     *
+     * @return If true, do not create any permanent record of these contents.
+     */
+    public boolean areContentsSecure() {
+        return false;
+    }
+
+    /**
+     * Create a possibly styled string for the contents of the current barcode.
+     *
+     * @return The text to be displayed.
+     */
+    public CharSequence getDisplayContents() {
+        String contents = result.getDisplayResult();
+        return contents.replace("\r", "");
+    }
+
+    /**
+     * A string describing the kind of barcode that was found, e.g. "Found contact info".
+     *
+     * @return The resource ID of the string.
+     */
+    public abstract int getDisplayTitle();
+
+    /**
+     * A convenience method to get the parsed type. Should not be overridden.
+     *
+     * @return The parsed type, e.g. URI or ISBN
+     */
+    public final ParsedResultType getType() {
+        return result.getType();
+    }
+
+    final void addPhoneOnlyContact(String[] phoneNumbers, String[] phoneTypes) {
+        addContact(null, null, null, phoneNumbers, phoneTypes, null, null, null, null, null, null, null, null, null, null, null);
+    }
+
+    final void addEmailOnlyContact(String[] emails, String[] emailTypes) {
+        addContact(null, null, null, null, null, emails, emailTypes, null, null, null, null, null, null, null, null, null);
+    }
+
+    final void addContact(String[] names,
+                          String[] nicknames,
+                          String pronunciation,
+                          String[] phoneNumbers,
+                          String[] phoneTypes,
+                          String[] emails,
+                          String[] emailTypes,
+                          String note,
+                          String instantMessenger,
+                          String address,
+                          String addressType,
+                          String org,
+                          String title,
+                          String[] urls,
+                          String birthday,
+                          String[] geo) {
+
+        // Only use the first name in the array, if present.
+        Intent intent = new Intent(Intent.ACTION_INSERT_OR_EDIT, ContactsContract.Contacts.CONTENT_URI);
+        intent.setType(ContactsContract.Contacts.CONTENT_ITEM_TYPE);
+        putExtra(intent, ContactsContract.Intents.Insert.NAME, names != null ? names[0] : null);
+
+        putExtra(intent, ContactsContract.Intents.Insert.PHONETIC_NAME, pronunciation);
+
+        int phoneCount = Math.min(phoneNumbers != null ? phoneNumbers.length : 0, Contents.PHONE_KEYS.length);
+        for (int x = 0; x < phoneCount; x++) {
+            putExtra(intent, Contents.PHONE_KEYS[x], phoneNumbers[x]);
+            if (phoneTypes != null && x < phoneTypes.length) {
+                int type = toPhoneContractType(phoneTypes[x]);
+                if (type >= 0) {
+                    intent.putExtra(Contents.PHONE_TYPE_KEYS[x], type);
+                }
+            }
+        }
+
+        int emailCount = Math.min(emails != null ? emails.length : 0, Contents.EMAIL_KEYS.length);
+        for (int x = 0; x < emailCount; x++) {
+            putExtra(intent, Contents.EMAIL_KEYS[x], emails[x]);
+            if (emailTypes != null && x < emailTypes.length) {
+                int type = toEmailContractType(emailTypes[x]);
+                if (type >= 0) {
+                    intent.putExtra(Contents.EMAIL_TYPE_KEYS[x], type);
+                }
+            }
+        }
+
+        ArrayList<ContentValues> data = new ArrayList<>();
+        if (urls != null) {
+            for (String url : urls) {
+                if (url != null && !url.isEmpty()) {
+                    ContentValues row = new ContentValues(2);
+                    row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Website.CONTENT_ITEM_TYPE);
+                    row.put(ContactsContract.CommonDataKinds.Website.URL, url);
+                    data.add(row);
+                    break;
+                }
+            }
+        }
+
+        if (birthday != null) {
+            ContentValues row = new ContentValues(3);
+            row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
+            row.put(ContactsContract.CommonDataKinds.Event.TYPE, ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY);
+            row.put(ContactsContract.CommonDataKinds.Event.START_DATE, birthday);
+            data.add(row);
+        }
+
+        if (nicknames != null) {
+            for (String nickname : nicknames) {
+                if (nickname != null && !nickname.isEmpty()) {
+                    ContentValues row = new ContentValues(3);
+                    row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Nickname.CONTENT_ITEM_TYPE);
+                    row.put(ContactsContract.CommonDataKinds.Nickname.TYPE,
+                            ContactsContract.CommonDataKinds.Nickname.TYPE_DEFAULT);
+                    row.put(ContactsContract.CommonDataKinds.Nickname.NAME, nickname);
+                    data.add(row);
+                    break;
+                }
+            }
+        }
+
+        if (!data.isEmpty()) {
+            intent.putParcelableArrayListExtra(ContactsContract.Intents.Insert.DATA, data);
+        }
+
+        StringBuilder aggregatedNotes = new StringBuilder();
+        if (note != null) {
+            aggregatedNotes.append('\n').append(note);
+        }
+        if (geo != null) {
+            aggregatedNotes.append('\n').append(geo[0]).append(',').append(geo[1]);
+        }
+
+        if (aggregatedNotes.length() > 0) {
+            // Remove extra leading '\n'
+            putExtra(intent, ContactsContract.Intents.Insert.NOTES, aggregatedNotes.substring(1));
+        }
+
+        putExtra(intent, ContactsContract.Intents.Insert.IM_HANDLE, instantMessenger);
+        putExtra(intent, ContactsContract.Intents.Insert.POSTAL, address);
+        if (addressType != null) {
+            int type = toAddressContractType(addressType);
+            if (type >= 0) {
+                intent.putExtra(ContactsContract.Intents.Insert.POSTAL_TYPE, type);
+            }
+        }
+        putExtra(intent, ContactsContract.Intents.Insert.COMPANY, org);
+        putExtra(intent, ContactsContract.Intents.Insert.JOB_TITLE, title);
+        launchIntent(intent);
+    }
+
+    private static int toEmailContractType(String typeString) {
+        return doToContractType(typeString, EMAIL_TYPE_STRINGS, EMAIL_TYPE_VALUES);
+    }
+
+    private static int toPhoneContractType(String typeString) {
+        return doToContractType(typeString, PHONE_TYPE_STRINGS, PHONE_TYPE_VALUES);
+    }
+
+    private static int toAddressContractType(String typeString) {
+        return doToContractType(typeString, ADDRESS_TYPE_STRINGS, ADDRESS_TYPE_VALUES);
+    }
+
+    private static int doToContractType(String typeString, String[] types, int[] values) {
+        if (typeString == null) {
+            return NO_TYPE;
+        }
+        for (int i = 0; i < types.length; i++) {
+            String type = types[i];
+            if (typeString.startsWith(type) || typeString.startsWith(type.toUpperCase(Locale.ENGLISH))) {
+                return values[i];
+            }
+        }
+        return NO_TYPE;
+    }
+
+    final void shareByEmail(String contents) {
+        sendEmail(null, null, null, null, contents);
+    }
+
+    final void sendEmail(String[] to,
+                         String[] cc,
+                         String[] bcc,
+                         String subject,
+                         String body) {
+        Intent intent = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
+        if (to != null && to.length != 0) {
+            intent.putExtra(Intent.EXTRA_EMAIL, to);
+        }
+        if (cc != null && cc.length != 0) {
+            intent.putExtra(Intent.EXTRA_CC, cc);
+        }
+        if (bcc != null && bcc.length != 0) {
+            intent.putExtra(Intent.EXTRA_BCC, bcc);
+        }
+        putExtra(intent, Intent.EXTRA_SUBJECT, subject);
+        putExtra(intent, Intent.EXTRA_TEXT, body);
+        intent.setType("text/plain");
+        launchIntent(intent);
+    }
+
+    final void shareBySMS(String contents) {
+        sendSMSFromUri("smsto:", contents);
+    }
+
+    final void sendSMS(String phoneNumber, String body) {
+        sendSMSFromUri("smsto:" + phoneNumber, body);
+    }
+
+    private void sendSMSFromUri(String uri, String body) {
+        Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));
+        putExtra(intent, "sms_body", body);
+        // Exit the app once the SMS is sent
+        intent.putExtra("compose_mode", true);
+        launchIntent(intent);
+    }
+
+    final void sendMMS(String phoneNumber, String subject, String body) {
+        sendMMSFromUri("mmsto:" + phoneNumber, subject, body);
+    }
+
+    private void sendMMSFromUri(String uri, String subject, String body) {
+        Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));
+        // The Messaging app needs to see a valid subject or else it will treat this an an SMS.
+        if (subject == null || subject.isEmpty()) {
+            putExtra(intent, "subject", activity.getString(R.string.msg_default_mms_subject));
+        } else {
+            putExtra(intent, "subject", subject);
+        }
+        putExtra(intent, "sms_body", body);
+        intent.putExtra("compose_mode", true);
+        launchIntent(intent);
+    }
+
+    final void dialPhone(String phoneNumber) {
+        launchIntent(new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + phoneNumber)));
+    }
+
+    final void dialPhoneFromUri(String uri) {
+        launchIntent(new Intent(Intent.ACTION_DIAL, Uri.parse(uri)));
+    }
+
+    final void openMap(String geoURI) {
+        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(geoURI)));
+    }
+
+    /**
+     * Do a geo search using the address as the query.
+     *
+     * @param address The address to find
+     */
+    final void searchMap(String address) {
+        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse("geo:0,0?q=" + Uri.encode(address))));
+    }
+
+    final void getDirections(double latitude, double longitude) {
+        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse("http://maps.google." +
+                LocaleManager.getCountryTLD(activity) + "/maps?f=d&daddr=" + latitude + ',' + longitude)));
+    }
+
+    // Uses the mobile-specific version of Product Search, which is formatted for small screens.
+    final void openProductSearch(String upc) {
+        Uri uri = Uri.parse("http://www.google." + LocaleManager.getProductSearchCountryTLD(activity) +
+                "/m/products?q=" + upc + "&source=zxing");
+        launchIntent(new Intent(Intent.ACTION_VIEW, uri));
+    }
+
+    final void openBookSearch(String isbn) {
+        Uri uri = Uri.parse("http://books.google." + LocaleManager.getBookSearchCountryTLD(activity) +
+                "/books?vid=isbn" + isbn);
+        launchIntent(new Intent(Intent.ACTION_VIEW, uri));
+    }
+
+    final void openURL(String url) {
+        // Strangely, some Android browsers don't seem to register to handle HTTP:// or HTTPS://.
+        // Lower-case these as it should always be OK to lower-case these schemes.
+        if (url.startsWith("HTTP://")) {
+            url = "http" + url.substring(4);
+        } else if (url.startsWith("HTTPS://")) {
+            url = "https" + url.substring(5);
+        }
+        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+        try {
+            launchIntent(intent);
+        } catch (ActivityNotFoundException ignored) {
+            Log.w(TAG, "Nothing available to handle " + intent);
+        }
+    }
+
+    final void webSearch(String query) {
+        Intent intent = new Intent(Intent.ACTION_WEB_SEARCH);
+        intent.putExtra("query", query);
+        launchIntent(intent);
+    }
+
+    /**
+     * Like {@link #launchIntent(Intent)} but will tell you if it is not handle-able
+     * via {@link ActivityNotFoundException}.
+     *
+     * @throws ActivityNotFoundException if Intent can't be handled
+     */
+    final void rawLaunchIntent(Intent intent) {
+        if (intent != null) {
+            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+            Log.d(TAG, "Launching intent: " + intent + " with extras: " + intent.getExtras());
+            activity.startActivity(intent);
+        }
+    }
+
+    /**
+     * Like {@link #rawLaunchIntent(Intent)} but will show a user dialog if nothing is available to handle.
+     */
+    final void launchIntent(Intent intent) {
+        try {
+            rawLaunchIntent(intent);
+        } catch (ActivityNotFoundException ignored) {
+            AlertDialog.Builder builder = new AlertDialog.Builder(activity);
+            builder.setTitle(R.string.applicationLabel);
+            builder.setMessage(R.string.msg_intent_failed);
+            builder.setPositiveButton(android.R.string.ok, null);
+            builder.show();
+        }
+    }
+
+    private static void putExtra(Intent intent, String key, String value) {
+        if (value != null && !value.isEmpty()) {
+            intent.putExtra(key, value);
+        }
+    }
+
+    private String parseCustomSearchURL() {
+        return null;
+    }
+
+    final String fillInCustomSearchURL(String text) {
+        if (customProductSearch == null) {
+            return text; // ?
+        }
+        try {
+            text = URLEncoder.encode(text, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            // can't happen; UTF-8 is always supported. Continue, I guess, without encoding
+        }
+        String url = customProductSearch;
+        if (rawResult != null) {
+            // Replace %f but only if it doesn't seem to be a hex escape sequence. This remains
+            // problematic but avoids the more surprising problem of breaking escapes
+            url = url.replaceFirst("%f(?![0-9a-f])", rawResult.getBarcodeFormat().toString());
+            if (url.contains("%t")) {
+                ParsedResult parsedResultAgain = ResultParser.parseResult(rawResult);
+                url = url.replace("%t", parsedResultAgain.getType().toString());
+            }
+        }
+        // Replace %s last as it might contain itself %f or %t
+        return url.replace("%s", text);
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/result/ResultHandlerFactory.java b/src/com/android/contacts/util/barcode/result/ResultHandlerFactory.java
index ff946ae..1ce9e9e 100644
--- a/src/com/android/contacts/util/barcode/result/ResultHandlerFactory.java
+++ b/src/com/android/contacts/util/barcode/result/ResultHandlerFactory.java
@@ -1,63 +1,63 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import com.android.contacts.util.barcode.CaptureActivity;
-import com.google.zxing.Result;
-import com.google.zxing.client.result.ParsedResult;
-import com.google.zxing.client.result.ResultParser;
-
-
-/**
- * Manufactures Android-specific handlers based on the barcode content's type.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class ResultHandlerFactory {
-  private ResultHandlerFactory() {
-  }
-
-  public static ResultHandler makeResultHandler(CaptureActivity activity, Result rawResult) {
-    ParsedResult result = parseResult(rawResult);
-    switch (result.getType()) {
-      case ADDRESSBOOK:
-        return new AddressBookResultHandler(activity, result);
-      case EMAIL_ADDRESS:
-        return new EmailAddressResultHandler(activity, result);
-      case PRODUCT:
-        return new ProductResultHandler(activity, result, rawResult);
-      case URI:
-        return new URIResultHandler(activity, result);
-      case GEO:
-        return new GeoResultHandler(activity, result);
-      case TEL:
-        return new TelResultHandler(activity, result);
-      case SMS:
-        return new SMSResultHandler(activity, result);
-      case CALENDAR:
-        return new CalendarResultHandler(activity, result);
-      case ISBN:
-        return new ISBNResultHandler(activity, result, rawResult);
-      default:
-        return new TextResultHandler(activity, result, rawResult);
-    }
-  }
-
-  private static ParsedResult parseResult(Result rawResult) {
-    return ResultParser.parseResult(rawResult);
-  }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import com.android.contacts.util.barcode.CaptureActivity;
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.ResultParser;
+
+
+/**
+ * Manufactures Android-specific handlers based on the barcode content's type.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ResultHandlerFactory {
+  private ResultHandlerFactory() {
+  }
+
+  public static ResultHandler makeResultHandler(CaptureActivity activity, Result rawResult) {
+    ParsedResult result = parseResult(rawResult);
+    switch (result.getType()) {
+      case ADDRESSBOOK:
+        return new AddressBookResultHandler(activity, result);
+      case EMAIL_ADDRESS:
+        return new EmailAddressResultHandler(activity, result);
+      case PRODUCT:
+        return new ProductResultHandler(activity, result, rawResult);
+      case URI:
+        return new URIResultHandler(activity, result);
+      case GEO:
+        return new GeoResultHandler(activity, result);
+      case TEL:
+        return new TelResultHandler(activity, result);
+      case SMS:
+        return new SMSResultHandler(activity, result);
+      case CALENDAR:
+        return new CalendarResultHandler(activity, result);
+      case ISBN:
+        return new ISBNResultHandler(activity, result, rawResult);
+      default:
+        return new TextResultHandler(activity, result, rawResult);
+    }
+  }
+
+  private static ParsedResult parseResult(Result rawResult) {
+    return ResultParser.parseResult(rawResult);
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/SMSResultHandler.java b/src/com/android/contacts/util/barcode/result/SMSResultHandler.java
index a663172..0d2215a 100644
--- a/src/com/android/contacts/util/barcode/result/SMSResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/SMSResultHandler.java
@@ -1,86 +1,86 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-import android.telephony.PhoneNumberUtils;
-
-import com.google.zxing.client.result.ParsedResult;
-import com.google.zxing.client.result.SMSParsedResult;
-
-import com.android.contacts.R;
-
-/**
- * Handles SMS addresses, offering a choice of composing a new SMS or MMS message.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class SMSResultHandler extends ResultHandler {
-  private static final int[] buttons = {
-      R.string.button_sms,
-      R.string.button_mms
-  };
-
-  public SMSResultHandler(Activity activity, ParsedResult result) {
-    super(activity, result);
-  }
-
-  @Override
-  public int getButtonCount() {
-    return buttons.length;
-  }
-
-  @Override
-  public int getButtonText(int index) {
-    return buttons[index];
-  }
-
-  @Override
-  public void handleButtonPress(int index) {
-    SMSParsedResult smsResult = (SMSParsedResult) getResult();
-    String number = smsResult.getNumbers()[0];
-    switch (index) {
-      case 0:
-        // Don't know of a way yet to express a SENDTO intent with multiple recipients
-        sendSMS(number, smsResult.getBody());
-        break;
-      case 1:
-        sendMMS(number, smsResult.getSubject(), smsResult.getBody());
-        break;
-    }
-  }
-
-  @Override
-  public CharSequence getDisplayContents() {
-    SMSParsedResult smsResult = (SMSParsedResult) getResult();
-    String[] rawNumbers = smsResult.getNumbers();
-    String[] formattedNumbers = new String[rawNumbers.length];
-    for (int i = 0; i < rawNumbers.length; i++) {
-      formattedNumbers[i] = PhoneNumberUtils.formatNumber(rawNumbers[i]);
-    }
-    StringBuilder contents = new StringBuilder(50);
-    ParsedResult.maybeAppend(formattedNumbers, contents);
-    ParsedResult.maybeAppend(smsResult.getSubject(), contents);
-    ParsedResult.maybeAppend(smsResult.getBody(), contents);
-    return contents.toString();
-  }
-
-  @Override
-  public int getDisplayTitle() {
-    return R.string.result_sms;
-  }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+import android.telephony.PhoneNumberUtils;
+
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.SMSParsedResult;
+
+import com.android.contacts.R;
+
+/**
+ * Handles SMS addresses, offering a choice of composing a new SMS or MMS message.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class SMSResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_sms,
+      R.string.button_mms
+  };
+
+  public SMSResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    SMSParsedResult smsResult = (SMSParsedResult) getResult();
+    String number = smsResult.getNumbers()[0];
+    switch (index) {
+      case 0:
+        // Don't know of a way yet to express a SENDTO intent with multiple recipients
+        sendSMS(number, smsResult.getBody());
+        break;
+      case 1:
+        sendMMS(number, smsResult.getSubject(), smsResult.getBody());
+        break;
+    }
+  }
+
+  @Override
+  public CharSequence getDisplayContents() {
+    SMSParsedResult smsResult = (SMSParsedResult) getResult();
+    String[] rawNumbers = smsResult.getNumbers();
+    String[] formattedNumbers = new String[rawNumbers.length];
+    for (int i = 0; i < rawNumbers.length; i++) {
+      formattedNumbers[i] = PhoneNumberUtils.formatNumber(rawNumbers[i]);
+    }
+    StringBuilder contents = new StringBuilder(50);
+    ParsedResult.maybeAppend(formattedNumbers, contents);
+    ParsedResult.maybeAppend(smsResult.getSubject(), contents);
+    ParsedResult.maybeAppend(smsResult.getBody(), contents);
+    return contents.toString();
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_sms;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/TelResultHandler.java b/src/com/android/contacts/util/barcode/result/TelResultHandler.java
index c9fcdac..21b1799 100644
--- a/src/com/android/contacts/util/barcode/result/TelResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/TelResultHandler.java
@@ -1,84 +1,84 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-import android.telephony.PhoneNumberUtils;
-
-import com.google.zxing.client.result.ParsedResult;
-import com.google.zxing.client.result.TelParsedResult;
-
-import com.android.contacts.R;
-
-
-/**
- * Offers relevant actions for telephone numbers.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class TelResultHandler extends ResultHandler {
-  private static final int[] buttons = {
-      R.string.button_dial,
-      R.string.button_add_contact
-  };
-
-  public TelResultHandler(Activity activity, ParsedResult result) {
-    super(activity, result);
-  }
-
-  @Override
-  public int getButtonCount() {
-    return buttons.length;
-  }
-
-  @Override
-  public int getButtonText(int index) {
-    return buttons[index];
-  }
-
-  @Override
-  public void handleButtonPress(int index) {
-    TelParsedResult telResult = (TelParsedResult) getResult();
-    switch (index) {
-      case 0:
-        dialPhoneFromUri(telResult.getTelURI());
-        // When dialer comes up, it allows underlying display activity to continue or something,
-        // but app can't get camera in this state. Avoid issues by just quitting, only in the
-        // case of a phone number
-        getActivity().finish();
-        break;
-      case 1:
-        String[] numbers = new String[1];
-        numbers[0] = telResult.getNumber();
-        addPhoneOnlyContact(numbers, null);
-        break;
-    }
-  }
-
-  // Overriden so we can take advantage of Android's phone number hyphenation routines.
-  @Override
-  public CharSequence getDisplayContents() {
-    String contents = getResult().getDisplayResult();
-    contents = contents.replace("\r", "");
-    return PhoneNumberUtils.formatNumber(contents);
-  }
-
-  @Override
-  public int getDisplayTitle() {
-    return R.string.result_tel;
-  }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+import android.telephony.PhoneNumberUtils;
+
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.TelParsedResult;
+
+import com.android.contacts.R;
+
+
+/**
+ * Offers relevant actions for telephone numbers.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class TelResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_dial,
+      R.string.button_add_contact
+  };
+
+  public TelResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    TelParsedResult telResult = (TelParsedResult) getResult();
+    switch (index) {
+      case 0:
+        dialPhoneFromUri(telResult.getTelURI());
+        // When dialer comes up, it allows underlying display activity to continue or something,
+        // but app can't get camera in this state. Avoid issues by just quitting, only in the
+        // case of a phone number
+        getActivity().finish();
+        break;
+      case 1:
+        String[] numbers = new String[1];
+        numbers[0] = telResult.getNumber();
+        addPhoneOnlyContact(numbers, null);
+        break;
+    }
+  }
+
+  // Overriden so we can take advantage of Android's phone number hyphenation routines.
+  @Override
+  public CharSequence getDisplayContents() {
+    String contents = getResult().getDisplayResult();
+    contents = contents.replace("\r", "");
+    return PhoneNumberUtils.formatNumber(contents);
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_tel;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/TextResultHandler.java b/src/com/android/contacts/util/barcode/result/TextResultHandler.java
index 1307c99..767b8c0 100644
--- a/src/com/android/contacts/util/barcode/result/TextResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/TextResultHandler.java
@@ -1,78 +1,78 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-
-import com.google.zxing.Result;
-import com.google.zxing.client.result.ParsedResult;
-
-import com.android.contacts.R;
-
-
-/**
- * This class handles TextParsedResult as well as unknown formats. It's the fallback handler.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class TextResultHandler extends ResultHandler {
-
-  private static final int[] buttons = {
-      R.string.button_web_search,
-      R.string.button_share_by_email,
-      R.string.button_share_by_sms,
-      R.string.button_custom_product_search,
-  };
-
-  public TextResultHandler(Activity activity, ParsedResult result, Result rawResult) {
-    super(activity, result, rawResult);
-  }
-
-  @Override
-  public int getButtonCount() {
-    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
-  }
-
-  @Override
-  public int getButtonText(int index) {
-    return buttons[index];
-  }
-
-  @Override
-  public void handleButtonPress(int index) {
-    String text = getResult().getDisplayResult();
-    switch (index) {
-      case 0:
-        webSearch(text);
-        break;
-      case 1:
-        shareByEmail(text);
-        break;
-      case 2:
-        shareBySMS(text);
-        break;
-      case 3:
-        openURL(fillInCustomSearchURL(text));
-        break;
-    }
-  }
-
-  @Override
-  public int getDisplayTitle() {
-    return R.string.result_text;
-  }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.contacts.R;
+
+
+/**
+ * This class handles TextParsedResult as well as unknown formats. It's the fallback handler.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class TextResultHandler extends ResultHandler {
+
+  private static final int[] buttons = {
+      R.string.button_web_search,
+      R.string.button_share_by_email,
+      R.string.button_share_by_sms,
+      R.string.button_custom_product_search,
+  };
+
+  public TextResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+    super(activity, result, rawResult);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    String text = getResult().getDisplayResult();
+    switch (index) {
+      case 0:
+        webSearch(text);
+        break;
+      case 1:
+        shareByEmail(text);
+        break;
+      case 2:
+        shareBySMS(text);
+        break;
+      case 3:
+        openURL(fillInCustomSearchURL(text));
+        break;
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_text;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/URIResultHandler.java b/src/com/android/contacts/util/barcode/result/URIResultHandler.java
index a4c2bd0..afd68db 100644
--- a/src/com/android/contacts/util/barcode/result/URIResultHandler.java
+++ b/src/com/android/contacts/util/barcode/result/URIResultHandler.java
@@ -1,104 +1,104 @@
-/*
- * Copyright (C) 2008 ZXing authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.contacts.util.barcode.result;
-
-import android.app.Activity;
-
-import com.android.contacts.util.barcode.LocaleManager;
-import com.google.zxing.client.result.ParsedResult;
-import com.google.zxing.client.result.URIParsedResult;
-
-import java.util.Locale;
-
-import com.android.contacts.R;
-
-
-/**
- * Offers appropriate actions for URLS.
- *
- * @author dswitkin@google.com (Daniel Switkin)
- */
-public final class URIResultHandler extends ResultHandler {
-    // URIs beginning with entries in this array will not be saved to history or copied to the
-    // clipboard for security.
-    private static final String[] SECURE_PROTOCOLS = {
-            "otpauth:"
-    };
-
-    private static final int[] buttons = {
-            R.string.button_open_browser,
-            R.string.button_share_by_email,
-            R.string.button_share_by_sms,
-            R.string.button_search_book_contents,
-    };
-
-    public URIResultHandler(Activity activity, ParsedResult result) {
-        super(activity, result);
-    }
-
-    @Override
-    public int getButtonCount() {
-        if (LocaleManager.isBookSearchUrl(((URIParsedResult) getResult()).getURI())) {
-            return buttons.length;
-        }
-        return buttons.length - 1;
-    }
-
-    @Override
-    public int getButtonText(int index) {
-        return buttons[index];
-    }
-
-    @Override
-    public Integer getDefaultButtonID() {
-        return 0;
-    }
-
-    @Override
-    public void handleButtonPress(int index) {
-        URIParsedResult uriResult = (URIParsedResult) getResult();
-        String uri = uriResult.getURI();
-        switch (index) {
-            case 0:
-                openURL(uri);
-                break;
-            case 1:
-                shareByEmail(uri);
-                break;
-            case 2:
-                shareBySMS(uri);
-                break;
-        }
-    }
-
-    @Override
-    public int getDisplayTitle() {
-        return R.string.result_uri;
-    }
-
-    @Override
-    public boolean areContentsSecure() {
-        URIParsedResult uriResult = (URIParsedResult) getResult();
-        String uri = uriResult.getURI().toLowerCase(Locale.ENGLISH);
-        for (String secure : SECURE_PROTOCOLS) {
-            if (uri.startsWith(secure)) {
-                return true;
-            }
-        }
-        return false;
-    }
-}
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.android.contacts.util.barcode.LocaleManager;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.URIParsedResult;
+
+import java.util.Locale;
+
+import com.android.contacts.R;
+
+
+/**
+ * Offers appropriate actions for URLS.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class URIResultHandler extends ResultHandler {
+    // URIs beginning with entries in this array will not be saved to history or copied to the
+    // clipboard for security.
+    private static final String[] SECURE_PROTOCOLS = {
+            "otpauth:"
+    };
+
+    private static final int[] buttons = {
+            R.string.button_open_browser,
+            R.string.button_share_by_email,
+            R.string.button_share_by_sms,
+            R.string.button_search_book_contents,
+    };
+
+    public URIResultHandler(Activity activity, ParsedResult result) {
+        super(activity, result);
+    }
+
+    @Override
+    public int getButtonCount() {
+        if (LocaleManager.isBookSearchUrl(((URIParsedResult) getResult()).getURI())) {
+            return buttons.length;
+        }
+        return buttons.length - 1;
+    }
+
+    @Override
+    public int getButtonText(int index) {
+        return buttons[index];
+    }
+
+    @Override
+    public Integer getDefaultButtonID() {
+        return 0;
+    }
+
+    @Override
+    public void handleButtonPress(int index) {
+        URIParsedResult uriResult = (URIParsedResult) getResult();
+        String uri = uriResult.getURI();
+        switch (index) {
+            case 0:
+                openURL(uri);
+                break;
+            case 1:
+                shareByEmail(uri);
+                break;
+            case 2:
+                shareBySMS(uri);
+                break;
+        }
+    }
+
+    @Override
+    public int getDisplayTitle() {
+        return R.string.result_uri;
+    }
+
+    @Override
+    public boolean areContentsSecure() {
+        URIParsedResult uriResult = (URIParsedResult) getResult();
+        String uri = uriResult.getURI().toLowerCase(Locale.ENGLISH);
+        for (String secure : SECURE_PROTOCOLS) {
+            if (uri.startsWith(secure)) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
-- 
2.7.4

