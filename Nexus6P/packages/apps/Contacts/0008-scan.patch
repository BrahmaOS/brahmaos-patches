From 58494e968fe9d37e152db0aeab321e6660c2e3b2 Mon Sep 17 00:00:00 2001
From: martin <martin@163.com>
Date: Thu, 22 Nov 2018 10:13:14 +0800
Subject: [PATCH] scan

Change-Id: I3e88a343529318ded66b9b13d0df0a7fdb387690
Signed-off-by: martin <martin@163.com>
---
 Android.mk                                         |   2 +
 AndroidManifest.xml                                |   6 +-
 res/layout/activity_capture.xml                    |  71 +++
 res/raw/beep.ogg                                   | Bin 0 -> 6401 bytes
 res/values-zh-rCN/strings.xml                      |   3 +
 res/values/colors.xml                              |   8 +
 res/values/dimens.xml                              |  16 +
 res/values/ids.xml                                 |   8 +
 res/values/strings.xml                             |  69 +++
 res/values/styles.xml                              |   9 +
 .../contacts/activities/ContactEditorActivity.java |   6 +
 .../contacts/activities/base/BaseActivity.java     | 145 ++++++
 .../contacts/editor/ContactEditorFragment.java     |  97 +++-
 .../android/contacts/editor/KindSectionView.java   |  14 +
 .../contacts/editor/RawContactEditorView.java      |  20 +-
 .../contacts/editor/TextFieldsEditorView.java      |  41 +-
 .../android/contacts/util/BitcoinPaymentURI.java   | 370 +++++++++++++++
 .../contacts/util/BitcoinPaymentURIParam.java      |  41 ++
 src/com/android/contacts/util/DisplayUtil.java     |  42 ++
 src/com/android/contacts/util/PermissionUtil.java  | 138 ++++++
 .../contacts/util/barcode/AmbientLightManager.java |  82 ++++
 .../android/contacts/util/barcode/BeepManager.java | 127 ++++++
 .../contacts/util/barcode/CaptureActivity.java     | 427 ++++++++++++++++++
 .../util/barcode/CaptureActivityHandler.java       | 172 +++++++
 .../android/contacts/util/barcode/Contents.java    | 118 +++++
 .../contacts/util/barcode/DecodeFormatManager.java | 106 +++++
 .../contacts/util/barcode/DecodeHandler.java       | 129 ++++++
 .../contacts/util/barcode/DecodeHintManager.java   | 236 ++++++++++
 .../contacts/util/barcode/DecodeThread.java        | 113 +++++
 .../contacts/util/barcode/FinishListener.java      |  49 ++
 src/com/android/contacts/util/barcode/Intents.java | 231 ++++++++++
 .../contacts/util/barcode/LocaleManager.java       | 185 ++++++++
 .../barcode/ViewfinderResultPointCallback.java     |  35 ++
 .../contacts/util/barcode/ViewfinderView.java      | 191 ++++++++
 .../util/barcode/camera/AutoFocusManager.java      | 130 ++++++
 .../barcode/camera/CameraConfigurationManager.java | 223 +++++++++
 .../barcode/camera/CameraConfigurationUtils.java   | 455 +++++++++++++++++++
 .../util/barcode/camera/CameraManager.java         | 350 +++++++++++++++
 .../util/barcode/camera/PreviewCallback.java       |  56 +++
 .../util/barcode/camera/open/CameraFacing.java     |  25 ++
 .../util/barcode/camera/open/OpenCamera.java       |  55 +++
 .../barcode/camera/open/OpenCameraInterface.java   |  98 ++++
 .../barcode/result/AddressBookResultHandler.java   | 219 +++++++++
 .../util/barcode/result/CalendarResultHandler.java | 188 ++++++++
 .../barcode/result/EmailAddressResultHandler.java  |  72 +++
 .../util/barcode/result/GeoResultHandler.java      |  69 +++
 .../util/barcode/result/ISBNResultHandler.java     |  74 +++
 .../util/barcode/result/ProductResultHandler.java  |  85 ++++
 .../util/barcode/result/ResultHandler.java         | 497 +++++++++++++++++++++
 .../util/barcode/result/ResultHandlerFactory.java  |  63 +++
 .../util/barcode/result/SMSResultHandler.java      |  86 ++++
 .../util/barcode/result/TelResultHandler.java      |  84 ++++
 .../util/barcode/result/TextResultHandler.java     |  78 ++++
 .../util/barcode/result/URIResultHandler.java      | 104 +++++
 54 files changed, 6299 insertions(+), 19 deletions(-)
 create mode 100644 res/layout/activity_capture.xml
 create mode 100644 res/raw/beep.ogg
 create mode 100644 src/com/android/contacts/activities/base/BaseActivity.java
 create mode 100644 src/com/android/contacts/util/BitcoinPaymentURI.java
 create mode 100644 src/com/android/contacts/util/BitcoinPaymentURIParam.java
 create mode 100644 src/com/android/contacts/util/DisplayUtil.java
 create mode 100644 src/com/android/contacts/util/PermissionUtil.java
 create mode 100644 src/com/android/contacts/util/barcode/AmbientLightManager.java
 create mode 100644 src/com/android/contacts/util/barcode/BeepManager.java
 create mode 100644 src/com/android/contacts/util/barcode/CaptureActivity.java
 create mode 100644 src/com/android/contacts/util/barcode/CaptureActivityHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/Contents.java
 create mode 100644 src/com/android/contacts/util/barcode/DecodeFormatManager.java
 create mode 100644 src/com/android/contacts/util/barcode/DecodeHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/DecodeHintManager.java
 create mode 100644 src/com/android/contacts/util/barcode/DecodeThread.java
 create mode 100644 src/com/android/contacts/util/barcode/FinishListener.java
 create mode 100644 src/com/android/contacts/util/barcode/Intents.java
 create mode 100644 src/com/android/contacts/util/barcode/LocaleManager.java
 create mode 100644 src/com/android/contacts/util/barcode/ViewfinderResultPointCallback.java
 create mode 100644 src/com/android/contacts/util/barcode/ViewfinderView.java
 create mode 100644 src/com/android/contacts/util/barcode/camera/AutoFocusManager.java
 create mode 100644 src/com/android/contacts/util/barcode/camera/CameraConfigurationManager.java
 create mode 100644 src/com/android/contacts/util/barcode/camera/CameraConfigurationUtils.java
 create mode 100644 src/com/android/contacts/util/barcode/camera/CameraManager.java
 create mode 100644 src/com/android/contacts/util/barcode/camera/PreviewCallback.java
 create mode 100644 src/com/android/contacts/util/barcode/camera/open/CameraFacing.java
 create mode 100644 src/com/android/contacts/util/barcode/camera/open/OpenCamera.java
 create mode 100644 src/com/android/contacts/util/barcode/camera/open/OpenCameraInterface.java
 create mode 100644 src/com/android/contacts/util/barcode/result/AddressBookResultHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/result/CalendarResultHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/result/EmailAddressResultHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/result/GeoResultHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/result/ISBNResultHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/result/ProductResultHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/result/ResultHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/result/ResultHandlerFactory.java
 create mode 100644 src/com/android/contacts/util/barcode/result/SMSResultHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/result/TelResultHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/result/TextResultHandler.java
 create mode 100644 src/com/android/contacts/util/barcode/result/URIResultHandler.java

diff --git a/Android.mk b/Android.mk
index e629e54..c995bf4 100644
--- a/Android.mk
+++ b/Android.mk
@@ -23,6 +23,7 @@ LOCAL_RESOURCE_DIR := $(addprefix $(LOCAL_PATH)/, $(res_dirs)) \
     $(support_library_root_dir)/v7/cardview/res \
     $(support_library_root_dir)/v7/recyclerview/res
 LOCAL_ASSET_DIR := $(addprefix $(LOCAL_PATH)/, $(asset_dirs))
+LOCAL_DEX_PREOPT := false
 
 LOCAL_AAPT_FLAGS := \
     --auto-add-overlay \
@@ -46,6 +47,7 @@ LOCAL_STATIC_JAVA_LIBRARIES := \
     android-support-v4 \
     com.android.vcard \
     guava \
+    google-zxing \
     libphonenumber \
     legacy-android-test \
     junit
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index cfdb8e2..5415cd5 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -17,7 +17,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.android.contacts"
           android:versionCode="1007021"
-          android:versionName="1.7.21b5">
+          android:versionName="1.7.21b15">
 
     <uses-sdk
         android:minSdkVersion="21"
@@ -56,6 +56,7 @@
     <!-- Following used for getting the status of the contacts sync adapter -->
     <uses-permission android:name="android.permission.READ_SYNC_STATS"/>
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
+    <uses-permission android:name="android.permission.CAMERA"/>
 
     <uses-feature
         android:name="android.hardware.telephony"
@@ -522,6 +523,9 @@
             android:label="@string/sim_import_title"
             android:theme="@style/PeopleThemeAppCompat.FullScreenDialog.SimImportActivity"/>
 
+        <activity
+            android:name=".util.barcode.CaptureActivity"
+            android:theme="@style/CaptureStyle" />
 
         <service
             android:name=".vcard.VCardService"
diff --git a/res/layout/activity_capture.xml b/res/layout/activity_capture.xml
new file mode 100644
index 0000000..7433e5e
--- /dev/null
+++ b/res/layout/activity_capture.xml
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/tools"
+    android:id="@+id/capture_container"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:id="@+id/toolbar_parent"
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:elevation="@dimen/tab_elevation"
+        android:layout_height="wrap_content" >
+        <FrameLayout
+            android:id="@+id/toolbar_frame"
+            android:layout_width="match_parent"
+            android:layout_height="?attr/actionBarSize"
+            android:background="?attr/colorPrimary">
+            <!-- the attribute padding removes the gap between this Toolbar and its parent FrameLayout on tablet -->
+            <android.support.v7.widget.Toolbar
+                android:layout_width="match_parent"
+                android:layout_height="?attr/actionBarSize"
+                android:id="@+id/toolbar"
+                android:padding="0dp"
+                style="@style/ContactsToolbarStyle" />
+        </FrameLayout>
+    </LinearLayout>
+
+    <FrameLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+        <SurfaceView android:id="@+id/preview_view"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"/>
+        <com.android.contacts.util.barcode.ViewfinderView
+            android:id="@+id/viewfinder_view"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"/>
+        <Button
+            android:id="@+id/set_torch_btn"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textSize="@dimen/font_size_body"
+            android:textColor="@android:color/white"
+            android:padding="@dimen/space_small"
+            android:visibility="gone"/>
+        <TextView android:id="@+id/status_view"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="bottom|center_horizontal"
+            android:background="@android:color/transparent"
+            android:textColor="@android:color/white"/>
+    </FrameLayout>
+
+</LinearLayout>
diff --git a/res/raw/beep.ogg b/res/raw/beep.ogg
new file mode 100644
index 0000000000000000000000000000000000000000..14199476a89093b575f6ef388febe417b5cd003b
GIT binary patch
literal 6401
zcmb7Id010N*Pk205(EqoRuRJ@5(Fd=lu+y&Srj551j3F&fGPqigt!*HtO5!mghdDx
zEUN{@B`R7mD2oe3APu0XY_eFa;)-vz@=b#6(|&(^@B7_n?%Z?F%$#%2ne&@DbGK~Y
z?gKF3>or1gvXGE8-;~dYKC*Xr0xOy=VIa<pk_P~DTM+5<DzZf~@~=xWQquBoHIsEq
zT^Ig-os?OWV+WfzZ25*5zT21MM`Tf0#9(VHD_b&|ye^bz$_i&kMG|-KA_he7*<raQ
zVf!jJF*cgzC;bGHL=PgnD96On$qxYv0HB8M+U;m>9uojO0F{mFiVoemG5_>Xa{VU4
zp-c%i(YUGiU}g)XUf!tFJ#-)P*hEUC1^`%qk`zi4Mjd~>F|V&PrRuF~)+M3Rv#hu}
z>FWz01<e{1Ja+tb{j|P<a-b}LKB6fYq!Add2I+rRq?!^|HmSCRb&pi1$L=O~5mQy{
zXQ~Ul9C4&-FS=PnHJ3rR7zkp&ydnRD{c6KUVjA8N3i-2=+ChZh0-2FgrbP0hyhXE!
z0F_woc9L-ayk1YAUe9a22dXQ*)mHXdTZkC8J~r!_zAj>4rav<@bYGl!Z=AR&ZqQFk
z_{9ZYjvM}Gk(y3KK&25i--wiNNXnnE%g3f=G-5!c#3hxc*%NlT&s=j?M(2NbplEwm
zY5l3vnT85QX%~RNE|P0>fA;kL-0cVQrFCgtbZPB>TWCA(m;oB}Wmml3V%d~nEHCx&
z9RTN)#xU+mFyF+cbg>;aB|3K{y5Hsc-sOiZ`EwHBw8M+0Ztmja&{g2@K;8C%h|;6(
z;Z5-n{TIcDkSvWCXox}icSSo<1)IEZsasGeR=Y~UNoi3N?2uXYj9A)R`nHFvQaV}L
zKqwQnW%-t^YH27bV+*O%yjY>m1dlBw-8<D$d8)UREp$^Vty!cFsFle#HS|NC&NNS@
zQzsnui|#L#Z+I90#|HM6PSv*%AeF@}Tg7kjU6dyk$`&?k<q6xUV{k;)qq3M5Tqvae
z9m#vygOl)}-meu-8a^~QZ{b7Qo#iRSq+B@`!JyWlKtJ(>N<k(04yjr{CwC*gA=Qha
zv#KUBMQS+_fHeHyqu3xro0Vx$$4gK&tFO+_HoIqfvD^B-xuj~mEwrC)zKwTMB46sK
zo7;;0B69ds73{NA*O(gqK+x(M7~rIuMMS|#B}V3LkkgUkBcmh%qM|ZI@$VBiXZ%2Q
zdEej4gV%a6m>1(&8q7@py>WrXoZ&0!p+lUJ!K9JFoNZbeQGrGOD2t{;OMnDUQaEy1
z$H`s1R8L3T;sk$1&Zc-m*Gav*Cyh5>F!ty-?|DPn@|M!4?gGQbM<cXPgCo+6@>v@y
zvW*fkqr`io9$t<LzLFGpIca46Z)K44cjQ3W7*ca5T>puj+;O{HBe#6xz<d)aavDxm
zJa0JtzmQY8BfG97yDl?(Iy2Wat0+3F^i0d?*n4MZul>jJ7jhtAU~yp>yZi$=0<xYH
z1kVL?kGG39uJ41ZL!yh;-zNY7L7viP$x>qM&9D$NY{d)<rtf;@f4amHXhFvoN>^HC
z`;WSZ?v}LYAKG!;QR(1p2|M>-&vC;$@h|W;nFp2>8etFQoN~^LhfZ?=c(`_Ir|LO%
z8%*=6JsHn<KlXd?<gvN-^yM{#n0x#meOa6NYlT$!dYo~Of9a7oonNcF1TF@9;N6T@
zR1Q=H&IrIO7}Vr3TuD>B1Qk*ZFG6Tg%VpoAPV!Rw-5Pl8ek$oCL-Lv+bbHS86;es%
zX>eP^=)v1O4MGJA;xRy_>$QWM$l1G};{DFOkF&lnG1N`u?xXI)6gzt}J^cA`eZEn_
z{S?tJ@YUAam+5UA_t2L){J~vR<S{6Y^Ja2_FUN)Nj~kv}FS-O@<DMjj2Jee|I3E=}
zn6pVL${&j2c=(Isd^mBT>MnyCO#dPmabc8y5ocRr)RRHyK8}l+8|ux83N8#C*&7u&
z?=kqE!z@aNtz%a>q1wAf)>S}7+hD7I)I+UZPu3nDo=@K{{i;5uZJ%$bh{=I^hX*90
z{P|Ik^RO^(#6R@m2V3vN&^~5VU?MZnFY4iZXy6BqH!~@?FiO%oA2*_v@o*q%EHN}x
zBH1tSL(=eI;p6~k?4!HrGBl7Q;v|iH;A}s|3H|6Y_&$kQloY{_+V(Mhq~TNN>*Ht6
z%%1s8@uu1RTg^+ZzkS@ghRYfL824oR<JJ?eCq8$cj2XT~p1sU|+<Mmh=3AS?Q2_^Q
zqlar}f4}zpTI-tGYvjkR=Lk&kATxMvhPW_&Li6y%P|}#)#=jJW4<(K4KODZlV(@a#
z*oUNhv9lXjeE-9n?rS-}ed<j3WIw$xS2(AHg8?Op4XY|8g6;)Fkf{#B@ChnpSp$X=
zTn}ng9O<eNc<brv$Zj`WO|>T7&4Q)mI90;!rjn|-MUEtkbhV%*HSL=8=qA2j%ub5|
zJUyn0tL;Rxs2$kp-Xzu~%Neje=~Fzoy1|A4>*@ML6~?bbxSj7jUrmUZ<Z+ek&6cNe
z>1O0YE=#GQ-H(yYul9|IIX|fxA*|wRZZ<m)8{){5+7aDUiE`ee@&WiQelS3xD5_}#
z6h$I+bW`1+DEk>xIKthcLzAA>1Vxb=I-n?vjsPb&iy|(|g48j@>Tc;M3YM?p=h2VD
z&ka6Ky)v*<xu!i}QTcKH2W^RR?agMka73K#hexbND!(XZ=lLnkhzI=1ff(V9x`CY@
z=O-Vry4O!>NA|SHFLi_lYC4g~mj`ynk*D;&Dklv<Q5FM_V1rb-SQpwcFa&)y2t_q?
zl*S0#x=JFpSPbYzbg%Cyis@;YFAdIvP*;Lk9=60w4#E~Eg>9N?hjyBrK_{=Em)Ksy
zW|(#IQuF8?C2TzX9xv64PCo@HHxf6WPH#$Q(CH0)2wO!7Y-4-50eY2^MTcev(6)H<
z`){4SZKEEZH-4b*B7&&gE8+A}nBvP8iyRoh5{@rZ%;7vymn24mF!JZ6eK-&f9->4E
zXZS;sh{7D?M8S1FoFnB7#6<*1I1ew!g;IAtfr!w`2rqeb?d7M|HA-D`?lM52t_M)X
z*ns6@)jQ0arC%inK)8~loI$#hBg_i9j;^GY0E7t;Koq1|d+oSG2Sk`@65E4fn&4*1
zYJe4_GU(FR|ErSjs{ijw1I+l3fzgGq+rKKTa*0Sz&uGMgTQDh)fH7+S+_?G|t4ZxN
z2E(nUa3gt|$jxWao0vj3*P5DvpkwC~JmD<xHG_}CU<}%6(WxEr0!C?23>i|UH8t81
zjpTtKC$|Q^cEoYp!5{|g0<CG8&u1JXcZS5gY$+aKHS(umcCwzY8PQ}r{g^!`=`7^K
z?AxoUBOvB1RetOc0v;=?06cE3usJ``&rUZ)>Lz1=(lW`NJhlo1urr+u#YppESJGEr
zTHaS)6_;VX$Xm(vf)JJTgFO1(#jz5nEl>Q)Bh^UcNm@xYFzGg3%vQLt^(&?J7sdFq
zUp0gNbp#xSGmwszR8?sbDH2MeS4x@H5CGUS3b({CY<Z+_U|Nnz$bKLVe3&W|g+Z~T
zjS@#^+#$9TGZaZ3JiZbsRj<~al*TO-k~1<3G=rCD$iQqCFG-y+$rw|sJOs!q;23}w
zo?PXWrhxxZAh>$<5<KlVMrOD=o6BY4#58a6a$s(0^-PAA(Yf(ahiszGXo}@ad%Pn)
z1>Zgn6kP>vxOEP%Ggdtw#g?CD$V(4waKT&(K$jd|wNG!;(Jpz{%sUEhZZLxaU<e50
zfgl{?>`dwE8+(nY8Cp9s)TB+43X5IL`Xz@%ELM8z!zLOoHcL)@5`Ho7WsxSucEM=D
zVu1p0i-pzjNi;KO*e4z=)2=LQ4Cd%_E}UH^xZ>1-aAZ``o1CS$^BWnDbCm0Avxm2!
zwqT)UU9;v~*}Cp9gi^8F1ywqI50(F^Y@5am`iT*>c?QKJmqxZ$|Mo@jO-{glwM!1=
znO$a+ycMiWlgONXTEPD2id|kbyW3giUvfPnV<;CaC5Cr8t^mr*G)G$s<^YH_2eG{i
ze6-@~a)7HM0wG%^01ZZ0AsC=u30!enBfaN}I7lKwJmV*mZC|ea4Wh+!tSFH|4Mxi^
zdCM06gr+XA59DNs*6%aIC>*O#1)7Aa>W+Fl=6-A)_eTxiyN9wi3Ql>@Xs$G`%%j=h
zY}rizS=+;j-&{NJs3-2)jZ4SNi;J&xtd4(G^6FFTtEGF%&*q9>$Sj;?m)zn`@dp|;
z$nU~#e4f9rPC29Oe5Q?{ViM?Z*V9^P{5yH%M4_K<%hqY0k8YTwBS<LFcuq9OC>=Ld
zy6bS!vB`R&>3YyWDR7cSZ>fMa_g0)h^(;Ysj>v|3<l9Ize5=g2O|6fU(PpAu!sf$E
z4KI=|D2dF!-13Oke(Ku?fJ(2xCB-vL77)#w(=GvUQJDgF+O>wrG5DgsAUD&FRU3_n
z6<}hKJ=<<!O~E5d9zYULnAzN@)@O{~Cn1%D$c$@Yb~kihQBt_43Gi56WEu55vj_ux
zLB`$asY+D>ZA5L98;{qlbxF1XK~v6XrUHhbpyD{!;jLJu#y!n#l%<Oe6f6}yofY@o
z7(D|7OBH1Gf<H8C;fPMhRH<<?*zmob`JKd$1G0)r89&|hRkl0&uYn!zWj|_gu_>R8
z0;%#T$$JzF`#6f>w2zyfr8tlKs7DAwBGVkL5gFqH_Q#O(PF&<dk1ETpmtc=W4_Bz-
z#w!qZxN^yw$zZa~6ackKuS~x*J{{74r%rc$#@w=#JI;!up)<f96kCMV3i~u)2jt)n
z5%drkLx7znDr-z5eh(3bVn6b+lr$9V5A8;lp_@@tq#P(91n?Gs>SU~IrNtch?BD?i
zvbc>QKf6Ye11?`LB6?j925Ft`h~RxV(vkm3whe@B!<5dCW~)U7@j%7~Z|;wR^@1Sl
z+|@23%+lu@@!8Sdir9{hDzoRN*{Mb}QWh7J?8G$9E;}=BXAZoao#S~$M1lYZ_80*a
z3{5`le%_E~8T0;d-L)*c_-DUO?5Y5HCVjC9TDfjpPbqvmIp_R?otlwJ)7Hbdgn-AG
z)4qF6^1bkp%_l<p6fw!FCPM}E9B0<ieOf22_g!44yW%EQ_xDeqz6%p}efP^Vty>F9
z<>~v7FF&_Fu0(r@LvAar?jAEg@6a>;;E#JM4F|=Zdw@!F-cIEZ1UfBEuCy7h8J1`u
zq6xRl2?YU5=7^EN(;Y{<4I}IXPi8H+0{k(?z=Vd(aQEQemPPo+&&`nD9XSC;313`)
zQO;Oa)+Bf@GBh1B0AW;zne@)xAqY4_xP%#8lIHGz#hkFNKhqHTLqAM)Hk*A)6WK6)
z#7;KHnUGp}bqk8A^2Y3+^v<rdPS5peW@J}Z)TjD9Zp2(o7zZ62v3o2v|443-`yHW`
zK5KiOe-Ce!ay}2UQgfQwhPPtzjcjxDb-M6F!S$~;V@+;{7~lSa>Z^zMe=^juCW8LA
z+2zTIYWPX_gh&tK)E^hYr99Ostv73M#Bt!IXyf?i3IbTG!M8VBW7P<FOV<MhDI<4h
zgBsf|!Btj%l(v&-+bi*sxj;>2$=v&8K$Er~qVPK~B-pluw&n9GL|I({%}S8Lj_Qss
z4_j7=lSG#qAclk(s%~|g8CeR|D2<mWzCc+epU0QCH2`pb%4%hR?_;&hFua~|1JO?5
za^Yzua21DlZCZWn7T;91l>KW8UMJ}8QShX018upX7WWoCnZZ?+S5zeAQ8$phEa}OU
z7zN>41}ajw@LFRnt9Y7mw_1FascFCJg3rwP`?aheMk1VmPHD>_izc9L>Z$Vu*J=Lr
z_G-_lnM3WjGKpJ*Y$L2v!k5;yv3S8=Ka$!#H$FGMzQbnpb0>?a^V{;1_%S6_HA<Fi
zZ)fkSM2}EQ!BWiU93wEf4@jV>4F4m9=mpIM=V|Q{`h}Ntyn1@k=ef|V3_1;T>kfgJ
zuSO7TucpE+MF8rN@3it@h{cA0=H%;T=qykhoyI1HVQ_N=R2tZYoP~dy+))g%P!3bM
zp=^a)!u7+v{TW|oBLTrh_HbKRbI^E4U|_T9$Il%IcY~<^S|X_}?@=@YlG@{ELR`Gp
z?w}@jR8r1jykxw-J-wRFjfv0B_r|64es&aW5JwZPo{PbyR4Uq;Dic<ED$AyfZcIBJ
zHj#b0LV46~ohm{<Krp?xk<it$XSr;pC+$(j56cp-YJvV=e&^mkpb>AJIoU3pu2-XZ
zzgQY>l@hrw9^2{}!EFvO%y#<_&MnjCTI~JOswz_;>#Vng{CVXF03sbU+u+-;2=pSh
zTh<b^pB0uy|70iqDXW4P)W|qU!m81u*Iu%4VFzBA?10Z4B{WiIw+2w(jv?YPm`d|0
zR7D_5(*y{Lry+Uz0Hxpoa!F1fT~h~8pN~Yb_0yK87Dd&kE#!Mw0<=&ZHsgL%6ZCc|
z%DZ&%c{Q4Cz422-H3C|Is9rg1R~&;^Y}b#@a(ag6_+ado5#%QYBz#7Zmz}>CFU4tj
z<w>IBSa<R`A=ayMDAUXCZ50s8;RP;0a0E3a2!DQtJgGYRWkW>yKDE?|p1MOSAm8}n
zi@NUwD7S%ZZF=7BoMHwTKT-b6_3V=dDC_!3Z>DyDL;3R5a~9{j1jbtanc90rZga6&
z<;d)nT7h78J_lCYZN}dlouf3yzH|R@eX9zQ_-=0K`G~4v<Mjut0r+KFY$A|j$Q=5{
z0|h&1lqCV^4OKJnU|~W<l0e|at^&{R_rbrmG|cxp#bAwWrIsXpC|Lz)SNGpM3Ty_V
zLPdXUe05{~-Mg~{ZS$x*Lr;qpyzsV+TdK|{6JlGHH^k`bzB~No0yiyVHD{zJe8chY
zD+wF!r(~{ad-V2&saRY<UU*t~k<pHf8Zj#0%VpVl9W)`6)#ixH_T<ftWsgQeFglRH
z7zQLTjyz2#KcHV;+W#-cn&)TQ(CKqWC;15)Hb>Htn(>I@6T1}Ez1vj`obs2sV{PvE
zvod0@x1n!sGTiAu-C5>z47|G-2;>ZncbLfn{5J_H`$;5~r_AIZmRg}t^Z=!H<P9kJ
znCi3o({%gV?^O-J0$!#1v&?~9`xQ4=p1r9U;BmXDnzfm-(xLW;IWU~4jn{9~n210S
zwmqE)X1^(-ZL2^Z)MMR`?%WO9O;Uy1uWHLuPIr+74$d>_C@RW1*8KgKy87vce*xdu
z)8}$V=hffY_=m_0%Pc`(*d*nfsI+q5{9ISPHj7$Hp(d=od8EgLsv;^rcr^X^zKP=9
z;`*S`5beano5(2XXwQw;m+R+OJ?N*77W<Lq^{p6jDuA}k?Tz;r((s`NR;`49SAzMi
Q!3(l<w0I|Y!;u01144^n5dZ)H

literal 0
HcmV?d00001

diff --git a/res/values-zh-rCN/strings.xml b/res/values-zh-rCN/strings.xml
index 2e15a60..0790368 100644
--- a/res/values-zh-rCN/strings.xml
+++ b/res/values-zh-rCN/strings.xml
@@ -533,4 +533,7 @@
     <string name="importing_sim_failed_message" msgid="3345258302998021066">"无法导入 SIM 卡中的联系人"</string>
     <string name="importing_sim_in_progress_title" msgid="3638299581276676109">"正在导入 SIM 卡联系人"</string>
     <string name="contacts_default_notification_channel" msgid="4754058700611188581">"通知"</string>
+
+    <string name="title_capture_code">扫码</string>
+    <string name="tip_scan_code_failed">扫码失败</string>
 </resources>
diff --git a/res/values/colors.xml b/res/values/colors.xml
index aeba877..bc68bf3 100644
--- a/res/values/colors.xml
+++ b/res/values/colors.xml
@@ -256,4 +256,12 @@
     <!-- Highlight color used in places such as ripples -->
     <color name="control_highlight_color">#1A000000</color>
 
+    <color name="colorAccent">#74a7f5</color>
+    <color name="viewfinder_laser">#ffcc0000</color>  <!-- Android standard ICS color -->
+    <color name="viewfinder_mask">#60000000</color>
+    <color name="viewfinder_btn_bg">#20000000</color>
+    <color name="result_view">#b0000000</color>
+    <color name="possible_result_points">#c0ffbd21</color>  <!-- Android standard ICS color -->
+    <color name="result_points">#c099cc00</color>  <!-- Android standard ICS color -->
+    <color name="light_green">#70ff56</color>
 </resources>
diff --git a/res/values/dimens.xml b/res/values/dimens.xml
index f92cf79..ae6dcd5 100644
--- a/res/values/dimens.xml
+++ b/res/values/dimens.xml
@@ -385,4 +385,20 @@
     <!-- Side padding within the navigation drawer -->
     <dimen name="drawer_label_header_end_padding">24dp</dimen>
 
+    <dimen name="toolbar_height">48dp</dimen>
+    <dimen name="space_unit">4dp</dimen>
+    <dimen name="space_smaller">8dp</dimen>
+    <dimen name="space_small">12dp</dimen>
+    <dimen name="space_normal">16dp</dimen>
+    <dimen name="space_large">24dp</dimen>
+    <dimen name="space_larger">32dp</dimen>
+    <dimen name="space_largest">40dp</dimen>
+    <dimen name="font_size_display2">30sp</dimen>
+    <dimen name="font_size_display1">28sp</dimen>
+    <dimen name="font_size_headline">24sp</dimen>
+    <dimen name="font_size_title">20sp</dimen>
+    <dimen name="font_size_subtitle">18sp</dimen>
+    <dimen name="font_size_subheading">16sp</dimen>
+    <dimen name="font_size_body">14sp</dimen>
+    <dimen name="font_size_caption">12sp</dimen>
 </resources>
diff --git a/res/values/ids.xml b/res/values/ids.xml
index a4b8b4b..ccaf01a 100644
--- a/res/values/ids.xml
+++ b/res/values/ids.xml
@@ -98,4 +98,12 @@
     <item type="id" name="tag_contact_type"/>
 
     <item type="id" name="menu_save"/>
+
+    <item type="id" name="decode"/>
+    <item type="id" name="decode_failed"/>
+    <item type="id" name="decode_succeeded"/>
+    <item type="id" name="launch_product_query"/>
+    <item type="id" name="quit"/>
+    <item type="id" name="restart_preview"/>
+    <item type="id" name="return_scan_result"/>
 </resources>
diff --git a/res/values/strings.xml b/res/values/strings.xml
index 88bb74a..5c45996 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -1599,4 +1599,73 @@
     <!-- Text shown when viewing channel settings for default Contacts notifications [CHAR LIMIT=50] -->
     <string name="contacts_default_notification_channel">Notifications</string>
 
+    <!-- scan barcode -->
+    <string name="open_slash">Open Flash</string>
+    <string name="close_slash">Close Flash</string>
+    <string name="bookmark_picker_name">Bookmarks</string>
+    <string name="button_add_calendar">Add to calendar</string>
+    <string name="button_add_contact">Add contact</string>
+    <string name="button_book_search">Book Search</string>
+    <string name="button_cancel">Cancel</string>
+    <string name="button_custom_product_search">Custom search</string>
+    <string name="button_dial">Dial number</string>
+    <string name="button_email">Send email</string>
+    <string name="button_get_directions">Get directions</string>
+    <string name="button_mms">Send MMS</string>
+    <string name="button_ok">OK</string>
+    <string name="button_open_browser">Open browser</string>
+    <string name="button_product_search">Product search</string>
+    <string name="button_search_book_contents">Search contents</string>
+    <string name="button_share_app">Application</string>
+    <string name="button_share_bookmark">Bookmark</string>
+    <string name="button_share_by_email">Share via email</string>
+    <string name="button_share_by_sms">Share via SMS</string>
+    <string name="button_share_clipboard">Clipboard</string>
+    <string name="button_share_contact">Contact</string>
+    <string name="button_show_map">Show map</string>
+    <string name="button_sms">Send SMS</string>
+    <string name="button_web_search">Web search</string>
+    <string name="msg_bulk_mode_scanned">Bulk mode: barcode scanned and saved</string>
+    <string name="msg_camera_framework_bug">Sorry, the Android camera encountered a problem. You may need to restart the device.</string>
+    <string name="msg_default_format">Format</string>
+    <string name="msg_default_meta">Metadata</string>
+    <string name="msg_default_mms_subject">Hi</string>
+    <string name="msg_default_status">Place a barcode inside the viewfinder rectangle to scan it.</string>
+    <string name="msg_default_time">Time</string>
+    <string name="msg_default_type">Type</string>
+    <string name="msg_encode_contents_failed">Could not encode a barcode from the data provided.</string>
+    <string name="msg_error">Error</string>
+    <string name="msg_google_books">Google</string>
+    <string name="msg_google_product">Google</string>
+    <string name="msg_intent_failed">Sorry, the requested application could not be launched. The barcode contents may be invalid.</string>
+    <string name="msg_invalid_value">Invalid value</string>
+    <string name="msg_redirect">Redirect</string>
+    <string name="msg_sbc_book_not_searchable">Sorry, this book is not searchable.</string>
+    <string name="msg_sbc_failed">Sorry, the search encountered a problem.</string>
+    <string name="msg_sbc_no_page_returned">No page returned</string>
+    <string name="msg_sbc_page">Page</string>
+    <string name="msg_sbc_results">Results</string>
+    <string name="msg_sbc_searching_book">Searching book\u2026</string>
+    <string name="msg_sbc_snippet_unavailable">Snippet not available</string>
+    <string name="msg_share_explanation">You can share data by displaying a barcode on your screen and scanning it with another phone.</string>
+    <string name="msg_share_text">Or type some text and press Enter</string>
+    <string name="msg_sure">Are you sure?</string>
+    <string name="msg_unmount_usb">Sorry, the SD card is not accessible.</string>
+    <string name="result_address_book">Found contact info</string>
+    <string name="result_calendar">Found calendar event</string>
+    <string name="result_email_address">Found email address</string>
+    <string name="result_geo">Found geographic coordinates</string>
+    <string name="result_isbn">Found book</string>
+    <string name="result_product">Found product</string>
+    <string name="result_sms">Found SMS address</string>
+    <string name="result_tel">Found phone number</string>
+    <string name="result_text">Found plain text</string>
+    <string name="result_uri">Found URL</string>
+    <string name="result_wifi">Found WLAN Configuration</string>
+    <string name="title_capture_code">Scan</string>
+    <string name="tip_scan_code_failed">Scan code failed!</string>
+
+    <string name="action_go_settings">Go Settings</string>
+    <string name="tip_camera_permission">You have not authorized the camera yet. Please go to the settings page.</string>
+    <string name="tip_external_storage_permission">You have not authorized the external storage yet. Please go to the settings page.</string>
 </resources>
diff --git a/res/values/styles.xml b/res/values/styles.xml
index 4c78136..d7ff25e 100644
--- a/res/values/styles.xml
+++ b/res/values/styles.xml
@@ -592,4 +592,13 @@ background and text color. See also android:style/Widget.Holo.TextView.ListSepar
         <item name="android:paddingStart">@dimen/drawer_side_padding</item>
         <item name="android:paddingEnd">@dimen/drawer_label_header_end_padding</item>
     </style>
+
+    <style name="CaptureStyle" parent="@style/Theme.AppCompat">
+        <item name="android:windowNoTitle">true</item>
+        <item name="android:windowActionBar">false</item>
+        <item name="windowNoTitle">true</item>
+        <item name="windowActionBar">false</item>
+        <item name="android:listSelector">?android:attr/listChoiceBackgroundIndicator</item>
+        <item name="android:windowAnimationStyle">@style/FullScreenDialogAnimationStyle</item>
+    </style>
 </resources>
diff --git a/src/com/android/contacts/activities/ContactEditorActivity.java b/src/com/android/contacts/activities/ContactEditorActivity.java
index ec49d48..56fb15c 100644
--- a/src/com/android/contacts/activities/ContactEditorActivity.java
+++ b/src/com/android/contacts/activities/ContactEditorActivity.java
@@ -16,14 +16,18 @@
 
 package com.android.contacts.activities;
 
+import android.Manifest;
 import android.app.Dialog;
 import android.app.FragmentTransaction;
 import android.content.ComponentName;
 import android.content.ContentValues;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Bundle;
 import android.provider.ContactsContract.QuickContact;
+import android.support.annotation.NonNull;
+import android.support.v4.app.ActivityCompat;
 import android.support.v7.widget.Toolbar;
 import android.util.Log;
 import android.view.View;
@@ -41,6 +45,8 @@ import com.android.contacts.interactions.ContactDeletionInteraction;
 import com.android.contacts.model.RawContactDeltaList;
 import com.android.contacts.util.DialogManager;
 import com.android.contacts.util.ImplicitIntentsUtil;
+import com.android.contacts.util.PermissionUtil;
+import com.android.contacts.util.barcode.CaptureActivity;
 
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
diff --git a/src/com/android/contacts/activities/base/BaseActivity.java b/src/com/android/contacts/activities/base/BaseActivity.java
new file mode 100644
index 0000000..3936c47
--- /dev/null
+++ b/src/com/android/contacts/activities/base/BaseActivity.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.activities.base;
+
+import android.Manifest;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.app.ActivityCompat;
+import android.support.v7.app.ActionBar;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import com.android.contacts.R;
+import com.android.contacts.util.PermissionUtil;
+
+
+public abstract class BaseActivity extends AppCompatActivity {
+
+    protected abstract String tag();
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+    }
+
+    @Override
+    protected void onPostCreate(@Nullable Bundle savedInstanceState) {
+        super.onPostCreate(savedInstanceState);
+        
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+    }
+
+    protected void showShortToast(String message) {
+        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
+    }
+
+    protected void showShortToast(int res) {
+        showShortToast(getString(res));
+    }
+
+    protected void showLongToast(String message) {
+        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
+    }
+
+    protected void showLongToast(int res) {
+        showLongToast(getString(res));
+    }
+
+    // Request camera permission
+    public void requestCameraScanPermission() {
+        PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
+    }
+
+    // Request write external storage
+    public void requestExternalStorage() {
+        PermissionUtil.requestMultiPermissions(this, PermissionUtil.EXTERNAL_STORAGE_PERMISSIONS, PermissionUtil.CODE_EXTERNAL_STORAGE);
+    }
+
+    public void handleCameraScanPermission() {}
+
+    public void handleExternalStoragePermission() {}
+
+    /**
+     * Callback received when a permissions request has been completed.
+     */
+    @Override
+    public void onRequestPermissionsResult(final int requestCode, @NonNull String[] permissions,
+                                           @NonNull int[] grantResults) {
+        if (requestCode == PermissionUtil.CODE_CAMERA_SCAN) {
+            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
+                    == PackageManager.PERMISSION_GRANTED) {
+                handleCameraScanPermission();
+            } else {
+                PermissionUtil.openSettingActivity(this, getString(R.string.tip_camera_permission));
+            }
+        } else if (requestCode == PermissionUtil.CODE_EXTERNAL_STORAGE) {
+            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)
+                    == PackageManager.PERMISSION_GRANTED) {
+                handleExternalStoragePermission();
+            } else {
+                PermissionUtil.openSettingActivity(this, getString(R.string.tip_external_storage_permission));
+            }
+        }
+    }
+
+    // show navigation backup action icon
+    protected void showNavBackBtn() {
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        if (toolbar != null) {
+
+            setSupportActionBar(toolbar);
+            ActionBar ab = getSupportActionBar();
+            if (ab != null) {
+                ab.setDisplayHomeAsUpEnabled(true);
+                ab.setDisplayShowHomeEnabled(true);
+            }
+        }
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        int id = item.getItemId();
+        if (id == android.R.id.home) {
+            finish();
+            return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+
+    /**
+     * set toolbar title
+     */
+    protected void setToolbarTitle(String title) {
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        if (toolbar != null) {
+            toolbar.setTitle(title);
+        }
+    }
+}
diff --git a/src/com/android/contacts/editor/ContactEditorFragment.java b/src/com/android/contacts/editor/ContactEditorFragment.java
index 4ed4cc7..e96572c 100644
--- a/src/com/android/contacts/editor/ContactEditorFragment.java
+++ b/src/com/android/contacts/editor/ContactEditorFragment.java
@@ -16,6 +16,7 @@
 
 package com.android.contacts.editor;
 
+import android.Manifest;
 import android.accounts.Account;
 import android.app.Activity;
 import android.app.Fragment;
@@ -27,6 +28,7 @@ import android.content.Context;
 import android.content.CursorLoader;
 import android.content.Intent;
 import android.content.Loader;
+import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.net.Uri;
@@ -41,6 +43,7 @@ import android.provider.ContactsContract.CommonDataKinds.StructuredName;
 import android.provider.ContactsContract.CommonDataKinds.StructuredPostal;
 import android.provider.ContactsContract.Intents;
 import android.provider.ContactsContract.RawContacts;
+import android.support.annotation.NonNull;
 import android.support.v7.widget.Toolbar;
 import android.text.TextUtils;
 import android.util.Log;
@@ -80,14 +83,18 @@ import com.android.contacts.model.account.AccountInfo;
 import com.android.contacts.model.account.AccountType;
 import com.android.contacts.model.account.AccountWithDataSet;
 import com.android.contacts.model.account.AccountsLoader;
+import com.android.contacts.model.dataitem.DataKind;
 import com.android.contacts.preference.ContactsPreferences;
 import com.android.contacts.quickcontact.InvisibleContactUtil;
 import com.android.contacts.quickcontact.QuickContactActivity;
+import com.android.contacts.util.BitcoinPaymentURI;
 import com.android.contacts.util.ContactDisplayUtils;
 import com.android.contacts.util.ContactPhotoUtils;
 import com.android.contacts.util.ImplicitIntentsUtil;
 import com.android.contacts.util.MaterialColorMapUtils;
+import com.android.contacts.util.PermissionUtil;
 import com.android.contacts.util.UiClosables;
+import com.android.contacts.util.barcode.CaptureActivity;
 import com.android.contactsbind.HelpUtils;
 
 import com.google.common.base.Preconditions;
@@ -110,7 +117,9 @@ public class ContactEditorFragment extends Fragment implements
         JoinContactConfirmationDialogFragment.Listener,
         AggregationSuggestionEngine.Listener, AggregationSuggestionView.Listener,
         CancelEditDialogFragment.Listener,
-        RawContactEditorView.Listener, PhotoEditorView.Listener,
+        RawContactEditorView.Listener,
+        PhotoEditorView.Listener,
+        TextFieldsEditorView.OperateListener,
         AccountsLoader.AccountsListener {
 
     static final String TAG = "ContactEditor";
@@ -217,6 +226,62 @@ public class ContactEditorFragment extends Fragment implements
      */
     public static final String JOIN_CONTACT_ID_EXTRA_KEY = "joinContactId";
 
+    private TextFieldsEditorView editorView;
+    private DataKind dataKind;
+
+    /**
+     * Click
+     */
+    @Override
+    public void onClickOperateView(TextFieldsEditorView view, DataKind kind) {
+        editorView = view;
+        dataKind = kind;
+        startScan();
+    }
+
+    // start CaptureActivity
+    public void startScan() {
+        if (shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) {
+            requestCameraScanPermission();
+        } else {
+            Intent intent = new Intent(getContext(), CaptureActivity.class);
+            if (dataKind.mimeType.equals(ContactsContract.CommonDataKinds.BitcoinAccountAddress.CONTENT_ITEM_TYPE)) {
+                startActivityForResult(intent, REQUEST_CODE_SCAN_BITCOIN_QR);
+            } else if (dataKind.mimeType.equals(ContactsContract.CommonDataKinds.EthereumAccountAddress.CONTENT_ITEM_TYPE)) {
+                startActivityForResult(intent, REQUEST_CODE_SCAN_ETHEREUM_QR);
+            }
+        }
+    }
+
+    // Request camera permission
+    public void requestCameraScanPermission() {
+        requestPermissions(PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
+    }
+
+    public void handleCameraScanPermission() {
+        Intent intent = new Intent(getContext(), CaptureActivity.class);
+        if (dataKind.mimeType.equals(ContactsContract.CommonDataKinds.BitcoinAccountAddress.CONTENT_ITEM_TYPE)) {
+            startActivityForResult(intent, REQUEST_CODE_SCAN_BITCOIN_QR);
+        } else if (dataKind.mimeType.equals(ContactsContract.CommonDataKinds.EthereumAccountAddress.CONTENT_ITEM_TYPE)) {
+            startActivityForResult(intent, REQUEST_CODE_SCAN_ETHEREUM_QR);
+        }
+    }
+
+    /**
+     * Callback received when a permissions request has been completed.
+     */
+    @Override
+    public void onRequestPermissionsResult(final int requestCode, @NonNull String[] permissions,
+                                           @NonNull int[] grantResults) {
+        if (requestCode == PermissionUtil.CODE_CAMERA_SCAN) {
+            if (shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) {
+                PermissionUtil.openSettingActivity(mContext, getString(R.string.tip_camera_permission));
+            } else {
+                handleCameraScanPermission();
+            }
+        }
+    }
+
     /**
      * Callbacks for Activities that host contact editors Fragments.
      */
@@ -649,6 +714,7 @@ public class ContactEditorFragment extends Fragment implements
 
     @Override
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        Log.d("ContactEditorFragment", "onActivityResult");
         switch (requestCode) {
             case REQUEST_CODE_JOIN: {
                 // Ignore failed requests
@@ -679,6 +745,34 @@ public class ContactEditorFragment extends Fragment implements
                 createContact(account);
                 break;
             }
+            case REQUEST_CODE_SCAN_ETHEREUM_QR: {
+                if (resultCode == Activity.RESULT_OK) {
+                    if (data != null) {
+                        String qrCode = data.getStringExtra(com.android.contacts.util.barcode.Intents.Scan.RESULT);
+                        if (qrCode != null && qrCode.length() > 0) {
+                            Log.d(getTag(), qrCode);
+                            if (editorView != null) {
+                                editorView.setValue(0, qrCode);
+                            }
+                        }
+                    }
+                }
+                break;
+            }
+            case REQUEST_CODE_SCAN_BITCOIN_QR: {
+                if (resultCode == Activity.RESULT_OK) {
+                    if (data != null) {
+                        String qrCode = data.getStringExtra(com.android.contacts.util.barcode.Intents.Scan.RESULT);
+                        if (qrCode != null && qrCode.length() > 0) {
+                            BitcoinPaymentURI bitcoinUri = BitcoinPaymentURI.parse(qrCode);
+                            if (bitcoinUri != null &&editorView != null) {
+                                editorView.setValue(0, bitcoinUri.getAddress());
+                            }
+                        }
+                    }
+                }
+                break;
+            }
         }
     }
 
@@ -1253,6 +1347,7 @@ public class ContactEditorFragment extends Fragment implements
         // Add input fields for the loaded Contact
         final RawContactEditorView editorView = getContent();
         editorView.setListener(this);
+        editorView.setOperateListener(this);
         if (mCopyReadOnlyName) {
             copyReadOnlyName();
         }
diff --git a/src/com/android/contacts/editor/KindSectionView.java b/src/com/android/contacts/editor/KindSectionView.java
index 94f8a32..800af13 100644
--- a/src/com/android/contacts/editor/KindSectionView.java
+++ b/src/com/android/contacts/editor/KindSectionView.java
@@ -18,6 +18,7 @@ package com.android.contacts.editor;
 
 import android.content.Context;
 import android.database.Cursor;
+import android.provider.ContactsContract;
 import android.provider.ContactsContract.CommonDataKinds.Event;
 import android.provider.ContactsContract.CommonDataKinds.GroupMembership;
 import android.provider.ContactsContract.CommonDataKinds.Nickname;
@@ -153,6 +154,7 @@ public class KindSectionView extends LinearLayout {
     private KindSectionData mKindSectionData;
     private ViewIdGenerator mViewIdGenerator;
     private RawContactEditorView.Listener mListener;
+    private TextFieldsEditorView.OperateListener mOperateListener;
 
     private boolean mIsUserProfile;
     private boolean mShowOneEmptyEditor = false;
@@ -181,6 +183,10 @@ public class KindSectionView extends LinearLayout {
         }
     }
 
+    public void setOperateListener(TextFieldsEditorView.OperateListener listener) {
+        this.mOperateListener = listener;
+    }
+
     @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
@@ -406,6 +412,14 @@ public class KindSectionView extends LinearLayout {
             editor.setValues(dataKind, valuesDelta, rawContactDelta, !dataKind.editable,
                     mViewIdGenerator);
         }
+
+        if (view instanceof TextFieldsEditorView) {
+            if (dataKind.mimeType.equals(ContactsContract.CommonDataKinds.EthereumAccountAddress.CONTENT_ITEM_TYPE)
+                    || dataKind.mimeType.equals(ContactsContract.CommonDataKinds.BitcoinAccountAddress.CONTENT_ITEM_TYPE)) {
+                final TextFieldsEditorView editor = (TextFieldsEditorView) view;
+                editor.setOperateListener(mOperateListener);
+            }
+        }
         mEditors.addView(view);
 
         return view;
diff --git a/src/com/android/contacts/editor/RawContactEditorView.java b/src/com/android/contacts/editor/RawContactEditorView.java
index b7c304b..b2c2c95 100644
--- a/src/com/android/contacts/editor/RawContactEditorView.java
+++ b/src/com/android/contacts/editor/RawContactEditorView.java
@@ -197,6 +197,7 @@ public class RawContactEditorView extends LinearLayout implements View.OnClickLi
     }
 
     private RawContactEditorView.Listener mListener;
+    private TextFieldsEditorView.OperateListener mOperateListener;
 
     private AccountTypeManager mAccountTypeManager;
     private LayoutInflater mLayoutInflater;
@@ -256,12 +257,12 @@ public class RawContactEditorView extends LinearLayout implements View.OnClickLi
 
         // Account header
         mAccountHeaderContainer = findViewById(R.id.account_header_container);
-        mAccountHeaderPrimaryText = (TextView) findViewById(R.id.account_type);
-        mAccountHeaderSecondaryText = (TextView) findViewById(R.id.account_name);
-        mAccountHeaderIcon = (ImageView) findViewById(R.id.account_type_icon);
-        mAccountHeaderExpanderIcon = (ImageView) findViewById(R.id.account_expander_icon);
+        mAccountHeaderPrimaryText = findViewById(R.id.account_type);
+        mAccountHeaderSecondaryText = findViewById(R.id.account_name);
+        mAccountHeaderIcon = findViewById(R.id.account_type_icon);
+        mAccountHeaderExpanderIcon = findViewById(R.id.account_expander_icon);
 
-        mPhotoView = (PhotoEditorView) findViewById(R.id.photo_editor);
+        mPhotoView = findViewById(R.id.photo_editor);
         mKindSectionViews = (LinearLayout) findViewById(R.id.kind_section_views);
         mMoreFields = findViewById(R.id.more_fields);
         mMoreFields.setOnClickListener(this);
@@ -312,6 +313,10 @@ public class RawContactEditorView extends LinearLayout implements View.OnClickLi
         mPhotoView.setListener(listener);
     }
 
+    public void setOperateListener(TextFieldsEditorView.OperateListener listener) {
+        this.mOperateListener = listener;
+    }
+
     public void removePhoto() {
         mPhotoValuesDelta.setFromTemplate(true);
         mPhotoValuesDelta.put(Photo.PHOTO, (byte[]) null);
@@ -905,6 +910,11 @@ public class RawContactEditorView extends LinearLayout implements View.OnClickLi
             kindSectionView.setHideWhenEmpty(false);
         }
 
+        if (EthereumAccountAddress.CONTENT_ITEM_TYPE.equals(mimeType)
+                || BitcoinAccountAddress.CONTENT_ITEM_TYPE.equals(mimeType)) {
+            kindSectionView.setOperateListener(mOperateListener);
+        }
+
         // Since phone numbers, email addresses, ethereum and bitcoin account displayed,
         // even if they are empty,
         // they will be the only types you add new values to initially for new contacts
diff --git a/src/com/android/contacts/editor/TextFieldsEditorView.java b/src/com/android/contacts/editor/TextFieldsEditorView.java
index 69b80ec..8f2eaa1 100644
--- a/src/com/android/contacts/editor/TextFieldsEditorView.java
+++ b/src/com/android/contacts/editor/TextFieldsEditorView.java
@@ -46,6 +46,7 @@ import com.android.contacts.model.RawContactDelta;
 import com.android.contacts.model.ValuesDelta;
 import com.android.contacts.model.account.AccountType.EditField;
 import com.android.contacts.model.dataitem.DataKind;
+import com.android.contacts.util.DisplayUtil;
 import com.android.contacts.util.PhoneNumberFormatter;
 
 /**
@@ -59,7 +60,6 @@ public class TextFieldsEditorView extends LabeledEditorView {
     private EditText[] mFieldEditTexts = null;
     private ViewGroup mFields = null;
     protected View mExpansionViewContainer;
-    protected ImageView mOperateView;
     protected ImageView mExpansionView;
     protected String mCollapseButtonDescription;
     protected String mExpandButtonDescription;
@@ -70,6 +70,8 @@ public class TextFieldsEditorView extends LabeledEditorView {
     private int mMinFieldHeight;
     private int mPreviousViewHeight;
     private int mHintTextColorUnfocused;
+    protected ImageView mOperateView;
+    private OperateListener mOperateListener;
 
     public TextFieldsEditorView(Context context) {
         super(context);
@@ -83,6 +85,17 @@ public class TextFieldsEditorView extends LabeledEditorView {
         super(context, attrs, defStyle);
     }
 
+    public interface OperateListener {
+        /**
+         * Handle when click [operate] image view.
+         */
+        void onClickOperateView(TextFieldsEditorView view, DataKind kind);
+    }
+
+    public void setOperateListener(OperateListener listener) {
+        mOperateListener = listener;
+    }
+
     /** {@inheritDoc} */
     @Override
     protected void onFinishInflate() {
@@ -93,9 +106,9 @@ public class TextFieldsEditorView extends LabeledEditorView {
 
         mMinFieldHeight = getContext().getResources().getDimensionPixelSize(
                 R.dimen.editor_min_line_item_height);
-        mFields = (ViewGroup) findViewById(R.id.editors);
+        mFields = findViewById(R.id.editors);
         mHintTextColorUnfocused = getResources().getColor(R.color.editor_disabled_text_color);
-        mExpansionView = (ImageView) findViewById(R.id.expansion_view);
+        mExpansionView = findViewById(R.id.expansion_view);
         mOperateView = findViewById(R.id.operate);
         mCollapseButtonDescription = getResources()
                 .getString(R.string.collapse_fields_description);
@@ -192,17 +205,21 @@ public class TextFieldsEditorView extends LabeledEditorView {
         mExpansionViewContainer.setVisibility(shouldExist ? View.VISIBLE : View.INVISIBLE);
     }
 
-    public static int dip2px(Context context, float dpValue) {
-        final float scale = context.getResources().getDisplayMetrics().density;
-        return (int) (dpValue * scale + 0.5f);
-    }
-
-    private void setupOperateView(boolean showOperate, int iconResourceId, EditText fieldView) {
+    private void setupOperateView(boolean showOperate, int iconResourceId, EditText fieldView, DataKind kind) {
         if (mOperateView != null) {
             mOperateView.setVisibility(showOperate ? View.VISIBLE : View.GONE);
             if (showOperate) {
                 mOperateView.setImageDrawable(getContext().getDrawable(iconResourceId));
-                fieldView.setPadding(0, 0, dip2px(getContext(), 40), 0);
+                fieldView.setPadding(0, 0, DisplayUtil.dip2px(getContext(), 40), 0);
+                mOperateView.setClickable(true);
+                mOperateView.setOnClickListener(new OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        if (mOperateListener != null) {
+                            mOperateListener.onClickOperateView(TextFieldsEditorView.this, kind);
+                        }
+                    }
+                });
             }
         }
     }
@@ -295,9 +312,9 @@ public class TextFieldsEditorView extends LabeledEditorView {
             // Show scan icon for ethereum and bitcoin account
             if (ContactsContract.CommonDataKinds.EthereumAccountAddress.CONTENT_ITEM_TYPE.equals(kind.mimeType)
                     || ContactsContract.CommonDataKinds.BitcoinAccountAddress.CONTENT_ITEM_TYPE.equals(kind.mimeType)) {
-                setupOperateView(true, R.drawable.quantum_ic_scan_vd_theme_24, fieldView);
+                setupOperateView(true, R.drawable.quantum_ic_scan_vd_theme_24, fieldView, kind);
             } else {
-                setupOperateView(false, 0, fieldView);
+                setupOperateView(false, 0, fieldView, null);
             }
 
             // Show the delete button if we have a non-empty value
diff --git a/src/com/android/contacts/util/BitcoinPaymentURI.java b/src/com/android/contacts/util/BitcoinPaymentURI.java
new file mode 100644
index 0000000..f16acf0
--- /dev/null
+++ b/src/com/android/contacts/util/BitcoinPaymentURI.java
@@ -0,0 +1,370 @@
+package com.android.contacts.util;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+
+/**
+ * Java library to handle Bitcoin payment URI.
+ * This library is based on the specification at the BIP 21.
+ *
+ * The BIT is available at: https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki
+ */
+
+public class BitcoinPaymentURI {
+
+    private static final String SCHEME = "bitcoin:";
+    private static final String PARAMETER_AMOUNT = "amount";
+    private static final String PARAMETER_LABEL = "label";
+    private static final String PARAMETER_MESSAGE = "message";
+
+    private final String address;
+    private final HashMap<String, BitcoinPaymentURIParam> parameters;
+
+    private BitcoinPaymentURI(Builder builder) {
+        this.address = builder.address;
+
+        parameters = new HashMap<>();
+
+        if (builder.amount != null) {
+            parameters.put(PARAMETER_AMOUNT, new BitcoinPaymentURIParam(String.valueOf(builder.amount), false));
+        }
+
+        if (builder.label != null) {
+            parameters.put(PARAMETER_LABEL, new BitcoinPaymentURIParam(builder.label, false));
+        }
+
+        if (builder.message != null) {
+            parameters.put(PARAMETER_MESSAGE, new BitcoinPaymentURIParam(builder.message, false));
+        }
+
+        if (builder.otherParameters != null) {
+            parameters.putAll(builder.otherParameters);
+        }
+    }
+
+    /**
+     * Gets the URI Bitcoin address.
+     *
+     * @return the URI Bitcoin address.
+     */
+
+    public String getAddress() {
+        return address;
+    }
+
+    /**
+     * Gets the URI amount.
+     *
+     * @return the URI amount.
+     */
+
+    public Double getAmount() {
+        if (parameters.get(PARAMETER_AMOUNT) == null) {
+            return null;
+        }
+
+        return Double.valueOf(parameters.get(PARAMETER_AMOUNT).getValue());
+    }
+
+    /**
+     * Gets the URI label.
+     *
+     * @return the URI label.
+     */
+
+    public String getLabel() {
+        if (parameters.get(PARAMETER_LABEL) == null) {
+            return null;
+        }
+
+        return parameters.get(PARAMETER_LABEL).getValue();
+    }
+
+    /**
+     * Gets the URI message.
+     *
+     * @return the URI message.
+     */
+
+    public String getMessage() {
+        if (parameters.get(PARAMETER_MESSAGE) == null) {
+            return null;
+        }
+
+        return parameters.get(PARAMETER_MESSAGE).getValue();
+    }
+
+    /**
+     * Gets the URI parameters.
+     *
+     * @return the URI parameters.
+     */
+
+    public HashMap<String, BitcoinPaymentURIParam> getBitcoinPaymentURIParams() {
+        HashMap<String, BitcoinPaymentURIParam> filteredParameters = new HashMap<>(parameters);
+
+        filteredParameters.remove(PARAMETER_AMOUNT);
+        filteredParameters.remove(PARAMETER_LABEL);
+        filteredParameters.remove(PARAMETER_MESSAGE);
+
+        return filteredParameters;
+    }
+
+    /**
+     * Gets the URI.
+     *
+     * @return a string with the URI. This string can be used to make a Bitcoin payment.
+     */
+
+    public String getURI() {
+        String queryParameters = null;
+        try {
+            for (Map.Entry<String, BitcoinPaymentURIParam> entry : parameters.entrySet()) {
+                if (queryParameters == null) {
+                    if (entry.getValue().isRequired()) {
+                        queryParameters = String.format("req-%s=%s", URLEncoder.encode(entry.getKey(), "UTF-8").replace("+", "%20"), URLEncoder.encode(entry.getValue().getValue(), "UTF-8").replace("+", "%20"));
+
+                        continue;
+                    }
+
+                    queryParameters = String.format("%s=%s", URLEncoder.encode(entry.getKey(), "UTF-8").replace("+", "%20"), URLEncoder.encode(entry.getValue().getValue(), "UTF-8").replace("+", "%20"));
+
+                    continue;
+                }
+
+                if (entry.getValue().isRequired()) {
+                    queryParameters = String.format("%s&req-%s=%s", queryParameters, URLEncoder.encode(entry.getKey(), "UTF-8").replace("+", "%20"), URLEncoder.encode(entry.getValue().getValue(), "UTF-8").replace("+", "%20"));
+
+                    continue;
+                }
+
+                queryParameters = String.format("%s&%s=%s", queryParameters, URLEncoder.encode(entry.getKey(), "UTF-8").replace("+", "%20"), URLEncoder.encode(entry.getValue().getValue(), "UTF-8").replace("+", "%20"));
+            }
+
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+
+            return null;
+        }
+
+        return String.format("%s%s%s", SCHEME, getAddress(), queryParameters == null ? "" : String.format("?%s", queryParameters));
+    }
+
+    /**
+     * Parses a string to a Bitcoin payment URI.
+     *
+     * @param string The string to be parsed.
+     *
+     * @return a Bitcoin payment URI if the URI is valid, or null for an invalid string.
+     */
+
+    public static BitcoinPaymentURI parse(String string) {
+
+        try {
+            string = URLDecoder.decode(string,  "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+            return null;
+        }
+
+        if (string == null) {
+            return null;
+        }
+
+        if (string.isEmpty()) {
+            return null;
+        }
+
+        if (!string.toLowerCase().startsWith(SCHEME)) {
+            return null;
+        }
+
+        String bitcoinPaymentURIWithoutScheme = string.replaceFirst(SCHEME, "");
+        ArrayList<String> bitcoinPaymentURIElements = new ArrayList<>(Arrays.asList(bitcoinPaymentURIWithoutScheme.split("\\?")));
+
+        if (bitcoinPaymentURIElements.size() != 1 && bitcoinPaymentURIElements.size() != 2) {
+            return null;
+        }
+
+        if (bitcoinPaymentURIElements.get(0).length() == 0) {
+            return null;
+        }
+
+        if (bitcoinPaymentURIElements.size() == 1) {
+            return new Builder().address(bitcoinPaymentURIElements.get(0)).build();
+        }
+
+        List<String> queryParametersList = Arrays.asList(bitcoinPaymentURIElements.get(1).split("&"));
+
+        if (queryParametersList.isEmpty()) {
+            return new Builder().address(bitcoinPaymentURIElements.get(0)).build();
+        }
+
+        HashMap<String, String> queryParametersFiltered = new HashMap<>();
+
+        for (String query : queryParametersList) {
+            String[] queryParameter = query.split("=");
+            if (queryParameter.length == 2) {
+                queryParametersFiltered.put(queryParameter[0], queryParameter[1]);
+            }
+        }
+
+        Builder bitcoinPaymentURIBuilder = new Builder().address(bitcoinPaymentURIElements.get(0));
+
+        if (queryParametersFiltered.containsKey(PARAMETER_AMOUNT)) {
+            bitcoinPaymentURIBuilder.amount(Double.valueOf(queryParametersFiltered.get(PARAMETER_AMOUNT)));
+            queryParametersFiltered.remove(PARAMETER_AMOUNT);
+        }
+
+        if (queryParametersFiltered.containsKey(PARAMETER_LABEL)) {
+            bitcoinPaymentURIBuilder.label(queryParametersFiltered.get(PARAMETER_LABEL));
+            queryParametersFiltered.remove(PARAMETER_LABEL);
+        }
+
+        if (queryParametersFiltered.containsKey(PARAMETER_MESSAGE)) {
+            bitcoinPaymentURIBuilder.message(queryParametersFiltered.get(PARAMETER_MESSAGE));
+            queryParametersFiltered.remove(PARAMETER_MESSAGE);
+        }
+
+        for (Map.Entry<String, String> entry : queryParametersFiltered.entrySet()) {
+            bitcoinPaymentURIBuilder.parameter(entry.getKey(), entry.getValue());
+        }
+
+        return bitcoinPaymentURIBuilder.build();
+    }
+
+    public static class Builder{
+
+        private String address;
+        private Double amount;
+        private String label;
+        private String message;
+        private HashMap<String, BitcoinPaymentURIParam> otherParameters;
+
+        /**
+         * Returns a builder for the Bitcoin payment URI.
+         */
+
+        public Builder() {
+        }
+
+        /**
+         * Adds the address to the builder.
+         *
+         * @param address The address.
+         *
+         * @return the builder with the address.
+         */
+
+        public Builder address(String address) {
+            this.address = address;
+
+            return this;
+        }
+
+        /**
+         * Adds the amount to the builder.
+         *
+         * @param amount The amount.
+         *
+         * @return the builder with the amount.
+         */
+
+        public Builder amount(Double amount) {
+            this.amount = amount;
+
+            return this;
+        }
+
+        /**
+         * Adds the label to the builder.
+         *
+         * @param label The label.
+         *
+         * @return the builder with the label.
+         */
+
+        public Builder label(String label) {
+            this.label = label;
+
+            return this;
+        }
+
+        /**
+         * Adds the message to the builder.
+         *
+         * @param message The message.
+         *
+         * @return the builder with the message.
+         */
+
+        public Builder message(String message) {
+            this.message = message;
+
+            return this;
+        }
+
+        /**
+         * Adds a parameter to the builder.
+         *
+         * @param key The parameter.
+         * @param value The value.
+         *
+         * @return the builder with the parameter.
+         */
+
+        public Builder parameter(String key, String value) {
+            if (otherParameters == null) {
+                otherParameters = new HashMap<String, BitcoinPaymentURIParam>();
+            }
+
+            if (key.startsWith("req-")) {
+                otherParameters.put(key.replace("req-", ""), new BitcoinPaymentURIParam(value, true));
+
+                return this;
+            }
+
+            otherParameters.put(key, new BitcoinPaymentURIParam(value, false));
+
+            return this;
+        }
+
+        /**
+         * Adds a required to the builder.
+         *
+         * @param key The key.
+         * @param value The value.
+         *
+         * @return the builder with the parameter.
+         */
+
+        public Builder requiredParameter(String key, String value) {
+            if (otherParameters == null) {
+                otherParameters = new HashMap<String, BitcoinPaymentURIParam>();
+            }
+
+            otherParameters.put(key, new BitcoinPaymentURIParam(value, true));
+
+            return this;
+        }
+
+        /**
+         * Builds a Bitcoin payment URI.
+         *
+         * @return a Bitcoin payment URI.
+         */
+
+        public BitcoinPaymentURI build() {
+            return new BitcoinPaymentURI(this);
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/src/com/android/contacts/util/BitcoinPaymentURIParam.java b/src/com/android/contacts/util/BitcoinPaymentURIParam.java
new file mode 100644
index 0000000..8867a6f
--- /dev/null
+++ b/src/com/android/contacts/util/BitcoinPaymentURIParam.java
@@ -0,0 +1,41 @@
+package com.android.contacts.util;
+
+public class BitcoinPaymentURIParam {
+
+    private final String value;
+    private final Boolean required;
+
+    /**
+     * Constructor.
+     *
+     * @param value The value.
+     * @param required A boolean indicating if the parameter is required.
+     */
+
+    public BitcoinPaymentURIParam(String value, Boolean required) {
+        super();
+        this.value = value;
+        this.required = required;
+    }
+
+    /**
+     * Gets the parameter value.
+     *
+     * @return the parameter value.
+     */
+
+    public String getValue() {
+        return value;
+    }
+
+    /**
+     * Gets a boolean indicating if the parameter is required.
+     *
+     * @return a boolean indicating if the parameter is required
+     */
+
+    public Boolean isRequired() {
+        return required;
+    }
+
+}
\ No newline at end of file
diff --git a/src/com/android/contacts/util/DisplayUtil.java b/src/com/android/contacts/util/DisplayUtil.java
new file mode 100644
index 0000000..55403e2
--- /dev/null
+++ b/src/com/android/contacts/util/DisplayUtil.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util;
+
+
+import android.app.Activity;
+import android.content.Context;
+import android.util.DisplayMetrics;
+
+public class DisplayUtil {
+
+    public static int getScreenWidth(Activity context) {
+        DisplayMetrics dm = new DisplayMetrics();
+        context.getWindowManager().getDefaultDisplay().getMetrics(dm);
+        return dm.widthPixels;
+    }
+
+    public static int getScreenHeight(Activity context) {
+        DisplayMetrics dm = new DisplayMetrics();
+        context.getWindowManager().getDefaultDisplay().getMetrics(dm);
+        return dm.heightPixels;
+    }
+
+    public static int dip2px(Context context, float dpValue) {
+        final float scale = context.getResources().getDisplayMetrics().density;
+        return (int) (dpValue * scale + 0.5f);
+    }
+}
diff --git a/src/com/android/contacts/util/PermissionUtil.java b/src/com/android/contacts/util/PermissionUtil.java
new file mode 100644
index 0000000..3bd6f9b
--- /dev/null
+++ b/src/com/android/contacts/util/PermissionUtil.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.provider.Settings;
+import android.support.v4.app.ActivityCompat;
+import android.support.v7.app.AlertDialog;
+import android.util.Log;
+import android.widget.Toast;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.android.contacts.R;
+
+/**
+ * Utility class that wraps access to the runtime permissions API in M and provides basic helper
+ * methods.
+ */
+public class PermissionUtil {
+
+    private static final String TAG = PermissionUtil.class.getSimpleName();
+    public static final int CODE_CAMERA_SCAN = 10000;
+    public static final int CODE_EXTERNAL_STORAGE = 10001;
+
+    public static final String PERMISSION_CAMERA = Manifest.permission.CAMERA;
+    public static final String PERMISSION_WRITE_EXTERNAL_STORAGE = Manifest.permission.WRITE_EXTERNAL_STORAGE;
+
+    public static final String[] CAMERA_PERMISSIONS = {
+            PERMISSION_CAMERA
+    };
+
+    public static final String[] EXTERNAL_STORAGE_PERMISSIONS = {
+            PERMISSION_WRITE_EXTERNAL_STORAGE
+    };
+
+    /**
+     * Check that all given permissions have been granted by verifying that each entry in the
+     * given array is of the value {@link PackageManager#PERMISSION_GRANTED}.
+     *
+     * @see Activity#onRequestPermissionsResult(int, String[], int[])
+     */
+    public static boolean verifyPermissions(int[] grantResults) {
+        // At least one result must be checked.
+        if(grantResults.length < 1){
+            return false;
+        }
+
+        // Verify that each required permission has been granted, otherwise return false.
+        for (int result : grantResults) {
+            if (result != PackageManager.PERMISSION_GRANTED) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Request multi permissions one time.
+     */
+    public static void requestMultiPermissions(final Activity activity, String[] permissionList, int requestCode) {
+
+        final List<String> unGrantPermissionsList = getNoGrantedPermission(activity, permissionList);
+
+        if (unGrantPermissionsList == null) {
+            return;
+        }
+        Log.d(TAG, "requestMultiPermissions permissionsList:" + unGrantPermissionsList.size());
+
+        if (unGrantPermissionsList.size() > 0) {
+            ActivityCompat.requestPermissions(activity, unGrantPermissionsList.toArray(new String[unGrantPermissionsList.size()]),
+                    requestCode);
+            Log.d(TAG, "showMessageOKCancel requestPermissions");
+        }
+    }
+
+    public static ArrayList<String> getNoGrantedPermission(Activity activity, String[] permissionList) {
+
+        ArrayList<String> permissions = new ArrayList<>();
+
+        for (int i = 0; i < permissionList.length; i++) {
+            String requestPermission = permissionList[i];
+
+            // default PERMISSION DENIED
+            int checkSelfPermission = PackageManager.PERMISSION_DENIED;
+            try {
+                checkSelfPermission = ActivityCompat.checkSelfPermission(activity, requestPermission);
+            } catch (RuntimeException e) {
+                Toast.makeText(activity, "please open those permission", Toast.LENGTH_SHORT)
+                        .show();
+                Log.e(TAG, "RuntimeException:" + e.getMessage());
+                return null;
+            }
+
+            if (checkSelfPermission != PackageManager.PERMISSION_GRANTED) {
+                permissions.add(requestPermission);
+            }
+        }
+        return permissions;
+    }
+
+    // Show the tip dialog
+    public static void openSettingActivity(final Context context, String message) {
+        new AlertDialog.Builder(context)
+                .setMessage(message)
+                .setPositiveButton(R.string.action_go_settings, (dialog, which) -> {
+                    Intent intent = new Intent();
+                    intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+                    Log.d(TAG, "getPackageName(): " + context.getPackageName());
+                    Uri uri = Uri.fromParts("package", context.getPackageName(), null);
+                    intent.setData(uri);
+                    context.startActivity(intent);
+                })
+                .setNegativeButton(android.R.string.cancel, null)
+                .create()
+                .show();
+    }
+}
diff --git a/src/com/android/contacts/util/barcode/AmbientLightManager.java b/src/com/android/contacts/util/barcode/AmbientLightManager.java
new file mode 100644
index 0000000..b33796e
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/AmbientLightManager.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2012 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.content.Context;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+
+import com.android.contacts.util.barcode.camera.CameraManager;
+
+
+/**
+ * Detects ambient light and switches on the front light when very dark, and off again when sufficiently light.
+ *
+ * @author Sean Owen
+ * @author Nikolaus Huber
+ */
+final class AmbientLightManager implements SensorEventListener {
+
+    private static final float TOO_DARK_LUX = 45.0f;
+    private static final float BRIGHT_ENOUGH_LUX = 45.0f;
+
+    private final Context context;
+    private CameraManager cameraManager;
+    private Sensor lightSensor;
+
+    AmbientLightManager(Context context) {
+        this.context = context;
+    }
+
+    void start(CameraManager cameraManager) {
+        this.cameraManager = cameraManager;
+        SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
+        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
+        if (lightSensor != null) {
+            sensorManager.registerListener(this, lightSensor, SensorManager.SENSOR_DELAY_NORMAL);
+        }
+    }
+
+    void stop() {
+        if (lightSensor != null) {
+            SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
+            sensorManager.unregisterListener(this);
+            cameraManager = null;
+            lightSensor = null;
+        }
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent sensorEvent) {
+        /*float ambientLightLux = sensorEvent.values[0];
+        if (cameraManager != null) {
+            if (ambientLightLux <= TOO_DARK_LUX) {
+                cameraManager.setTorch(true);
+            } else if (ambientLightLux >= BRIGHT_ENOUGH_LUX) {
+                cameraManager.setTorch(false);
+            }
+        }*/
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+        // do nothing
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/BeepManager.java b/src/com/android/contacts/util/barcode/BeepManager.java
new file mode 100644
index 0000000..88e7b78
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/BeepManager.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.AssetFileDescriptor;
+import android.media.AudioManager;
+import android.media.MediaPlayer;
+import android.os.Build;
+import android.os.Vibrator;
+import android.util.Log;
+
+import java.io.Closeable;
+import java.io.IOException;
+
+import com.android.contacts.R;
+
+/**
+ * Manages beeps and vibrations for {@link CaptureActivity}.
+ */
+final class BeepManager implements MediaPlayer.OnErrorListener, Closeable {
+
+    private static final String TAG = BeepManager.class.getSimpleName();
+
+    private static final float BEEP_VOLUME = 0.10f;
+    private static final long VIBRATE_DURATION = 200L;
+
+    private final Activity activity;
+    private MediaPlayer mediaPlayer;
+    private boolean playBeep;
+    private boolean vibrate;
+
+    BeepManager(Activity activity) {
+        this.activity = activity;
+        this.mediaPlayer = null;
+        updatePrefs();
+    }
+
+    synchronized void updatePrefs() {
+        playBeep = shouldBeep(activity);
+        vibrate = false;
+        if (playBeep && mediaPlayer == null) {
+            // The volume on STREAM_SYSTEM is not adjustable, and users found it too loud,
+            // so we now play on the music stream.
+            activity.setVolumeControlStream(AudioManager.STREAM_MUSIC);
+            mediaPlayer = buildMediaPlayer(activity);
+        }
+    }
+
+    synchronized void playBeepSoundAndVibrate() {
+        if (playBeep && mediaPlayer != null) {
+            mediaPlayer.start();
+        }
+        if (vibrate) {
+            Vibrator vibrator = (Vibrator) activity.getSystemService(Context.VIBRATOR_SERVICE);
+            vibrator.vibrate(VIBRATE_DURATION);
+        }
+    }
+
+    private static boolean shouldBeep(Context activity) {
+        boolean shouldPlayBeep = true;
+        // See if sound settings overrides this
+        AudioManager audioService = (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);
+        if (audioService.getRingerMode() != AudioManager.RINGER_MODE_NORMAL) {
+            shouldPlayBeep = false;
+        }
+        return shouldPlayBeep;
+    }
+
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private MediaPlayer buildMediaPlayer(Context activity) {
+        MediaPlayer mediaPlayer = new MediaPlayer();
+        try {
+            try (AssetFileDescriptor file = activity.getResources().openRawResourceFd(R.raw.beep)) {
+                mediaPlayer.setDataSource(file.getFileDescriptor(), file.getStartOffset(), file.getLength());
+            }
+            mediaPlayer.setOnErrorListener(this);
+            mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
+            mediaPlayer.setLooping(false);
+            mediaPlayer.setVolume(BEEP_VOLUME, BEEP_VOLUME);
+            mediaPlayer.prepare();
+            return mediaPlayer;
+        } catch (IOException ioe) {
+            Log.w(TAG, ioe);
+            mediaPlayer.release();
+            return null;
+        }
+    }
+
+    @Override
+    public synchronized boolean onError(MediaPlayer mp, int what, int extra) {
+        if (what == MediaPlayer.MEDIA_ERROR_SERVER_DIED) {
+            // we are finished, so put up an appropriate error toast if required and finish
+            activity.finish();
+        } else {
+            // possibly media player error, so release and recreate
+            close();
+            updatePrefs();
+        }
+        return true;
+    }
+
+    @Override
+    public synchronized void close() {
+        if (mediaPlayer != null) {
+            mediaPlayer.release();
+            mediaPlayer = null;
+        }
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/CaptureActivity.java b/src/com/android/contacts/util/barcode/CaptureActivity.java
new file mode 100644
index 0000000..afe3c36
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/CaptureActivity.java
@@ -0,0 +1,427 @@
+/*
+ * Copyright (C) 2018 BRAHMACARIYA FOUNDATION LTD.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.Manifest;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.support.v4.app.ActivityCompat;
+import android.support.v7.app.ActionBar;
+import android.support.v7.app.AlertDialog;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.Button;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+
+import com.android.contacts.activities.base.BaseActivity;
+import com.android.contacts.util.PermissionUtil;
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.Result;
+import com.google.zxing.ResultMetadataType;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Map;
+
+import com.android.contacts.R;
+import com.android.contacts.util.barcode.CaptureActivityHandler;
+import com.android.contacts.util.barcode.FinishListener;
+import com.android.contacts.util.barcode.Intents;
+import com.android.contacts.util.barcode.ViewfinderView;
+import com.android.contacts.util.barcode.camera.CameraManager;
+import com.android.contacts.util.barcode.result.ResultHandler;
+import com.android.contacts.util.barcode.result.ResultHandlerFactory;
+import com.android.contacts.util.DisplayUtil;
+
+
+/**
+ *  - Intents.Scan.WIDTH
+ *  - Intents.Scan.HEIGHT
+ */
+public class CaptureActivity extends BaseActivity implements SurfaceHolder.Callback {
+
+    private static final String TAG = "CaptureActivity";
+
+    private static final long DEFAULT_INTENT_RESULT_DURATION_MS = 100L;
+    private CameraManager cameraManager;
+    private boolean hasSurface;
+    private BeepManager beepManager;
+    private AmbientLightManager ambientLightManager;
+    private ViewfinderView viewfinderView;
+    private TextView statusView;
+    private Button setTorchBtn;
+    private CaptureActivityHandler handler;
+    private Collection<BarcodeFormat> decodeFormats;
+    private Map<DecodeHintType,?> decodeHints;
+    private String characterSet;
+    private Result lastResult;
+    private Result savedResultToShow;
+
+    @Override
+    protected String tag() {
+        return CaptureActivity.class.getName();
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_capture);
+        Log.d(TAG, "onCreate");
+        hasSurface = false;
+        beepManager = new BeepManager(this);
+        ambientLightManager = new AmbientLightManager(this);
+
+        Window window = getWindow();
+        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
+        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        if (toolbar != null) {
+            setSupportActionBar(toolbar);
+            ActionBar ab = getSupportActionBar();
+            if (ab != null) {
+                ab.setDisplayHomeAsUpEnabled(true);
+                ab.setDisplayShowHomeEnabled(true);
+                ab.setTitle("qrcode");
+            }
+        }
+    }
+
+    ViewfinderView getViewfinderView() {
+        return viewfinderView;
+    }
+
+    public Handler getHandler() {
+        return handler;
+    }
+
+    CameraManager getCameraManager() {
+        return cameraManager;
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        // CameraManager must be initialized here, not in onCreate(). This is necessary because we don't
+        // want to open the camera driver and measure the screen size if we're going to show the help on
+        // first launch. That led to bugs where the scanning rectangle was the wrong size and partially
+        // off screen.
+        cameraManager = new CameraManager(getApplication());
+
+        viewfinderView = findViewById(R.id.viewfinder_view);
+        viewfinderView.setCameraManager(cameraManager);
+        statusView = findViewById(R.id.status_view);
+        setTorchBtn = findViewById(R.id.set_torch_btn);
+
+        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+        int windowHeight = DisplayUtil.getScreenHeight(this);
+        int windowWidth = DisplayUtil.getScreenWidth(this);
+        int scanHeight = CameraManager.findDesiredDimensionInRange(windowHeight, CameraManager.MIN_FRAME_HEIGHT, CameraManager.MAX_FRAME_HEIGHT);
+        int topOffset = (windowHeight - scanHeight) / 3;
+        int measureWidth = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
+        int measureHeight = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
+        setTorchBtn.measure(measureWidth, measureHeight);
+        int buttonWidth = setTorchBtn.getMeasuredWidth();
+        layoutParams.setMargins((windowWidth - buttonWidth) / 2, scanHeight + topOffset + DisplayUtil.dip2px(this, getResources().getDimension(R.dimen.space_normal)), 0, 0);
+
+        handler = null;
+        beepManager.updatePrefs();
+        ambientLightManager.start(cameraManager);
+
+        Intent intent = getIntent();
+        decodeFormats = DecodeFormatManager.parseDecodeFormats(intent);
+        decodeHints = DecodeHintManager.parseDecodeHints(intent);
+        if (intent.hasExtra(Intents.Scan.WIDTH) && intent.hasExtra(Intents.Scan.HEIGHT)) {
+            int width = intent.getIntExtra(Intents.Scan.WIDTH, 0);
+            int height = intent.getIntExtra(Intents.Scan.HEIGHT, 0);
+            if (width > 0 && height > 0) {
+                cameraManager.setManualFramingRect(width, height);
+            }
+        }
+
+        if (intent.hasExtra(Intents.Scan.CAMERA_ID)) {
+            int cameraId = intent.getIntExtra(Intents.Scan.CAMERA_ID, -1);
+            if (cameraId >= 0) {
+                cameraManager.setManualCameraId(cameraId);
+            }
+        }
+
+        String customPromptMessage = intent.getStringExtra(Intents.Scan.PROMPT_MESSAGE);
+        if (customPromptMessage != null) {
+            statusView.setText(customPromptMessage);
+        }
+
+        characterSet = intent.getStringExtra(Intents.Scan.CHARACTER_SET);
+
+        SurfaceView surfaceView = findViewById(R.id.preview_view);
+        SurfaceHolder surfaceHolder = surfaceView.getHolder();
+        if (hasSurface) {
+            // The activity was paused but not stopped, so the surface still exists. Therefore
+            // surfaceCreated() won't be called, so init the camera here.
+            initCamera(surfaceHolder);
+        } else {
+            // Install the callback and wait for surfaceCreated() to init the camera.
+            surfaceHolder.addCallback(this);
+        }
+    }
+
+    // Request camera permission
+    public void requestCameraScanPermission() {
+        PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
+    }
+
+    public void handleCameraScanPermission() {
+    }
+
+    @Override
+    protected void onPause() {
+        Log.d(TAG, "onPause");
+        if (handler != null) {
+            handler.quitSynchronously();
+            handler = null;
+        }
+
+        if (ambientLightManager != null) {
+            ambientLightManager.stop();
+        }
+        if (beepManager != null) {
+            beepManager.close();
+        }
+        if (cameraManager != null) {
+            cameraManager.closeDriver();
+        }
+
+        if (!hasSurface) {
+            SurfaceView surfaceView = findViewById(R.id.preview_view);
+            SurfaceHolder surfaceHolder = surfaceView.getHolder();
+            surfaceHolder.removeCallback(this);
+        }
+        super.onPause();
+    }
+
+    /**
+     * A valid barcode has been found, so give an indication of success and show the results.
+     *
+     * @param rawResult The contents of the barcode.
+     * @param scaleFactor amount by which thumbnail was scaled
+     * @param barcode   A greyscale bitmap of the camera data which was decoded.
+     */
+    public void handleDecode(Result rawResult, Bitmap barcode, float scaleFactor) {
+        lastResult = rawResult;
+        ResultHandler resultHandler = ResultHandlerFactory.makeResultHandler(this, rawResult);
+
+        boolean fromLiveScan = barcode != null;
+        if (fromLiveScan) {
+            // Then not from history, so beep/vibrate and we have an image to draw on
+            beepManager.playBeepSoundAndVibrate();
+        }
+
+        handleDecodeExternally(rawResult, resultHandler, barcode);
+    }
+
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        Log.d(tag(), "surface created");
+        if (holder == null) {
+            Log.e(TAG, "*** WARNING *** surfaceCreated() gave us a null surface!");
+        }
+
+        if (!hasSurface) {
+            hasSurface = true;
+            initCamera(holder);
+        }
+    }
+
+    // Briefly show the contents of the barcode, then handle the result outside Barcode Scanner.
+    private void handleDecodeExternally(Result rawResult, ResultHandler resultHandler, Bitmap barcode) {
+
+        if (barcode != null) {
+            viewfinderView.drawResultBitmap(barcode);
+        }
+
+        long resultDurationMS;
+        if (getIntent() == null) {
+            resultDurationMS = DEFAULT_INTENT_RESULT_DURATION_MS;
+        } else {
+            resultDurationMS = getIntent().getLongExtra(Intents.Scan.RESULT_DISPLAY_DURATION_MS,
+                    DEFAULT_INTENT_RESULT_DURATION_MS);
+        }
+
+        // Hand back whatever action they requested - this can be changed to Intents.Scan.ACTION when
+        // the deprecated intent is retired.
+        Intent intent = new Intent(getIntent().getAction());
+        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+        intent.putExtra(Intents.Scan.RESULT, rawResult.toString());
+        intent.putExtra(Intents.Scan.RESULT_FORMAT, rawResult.getBarcodeFormat().toString());
+        byte[] rawBytes = rawResult.getRawBytes();
+        if (rawBytes != null && rawBytes.length > 0) {
+            intent.putExtra(Intents.Scan.RESULT_BYTES, rawBytes);
+        }
+
+        Map<ResultMetadataType,?> metadata = rawResult.getResultMetadata();
+        if (metadata != null) {
+            if (metadata.containsKey(ResultMetadataType.UPC_EAN_EXTENSION)) {
+                intent.putExtra(Intents.Scan.RESULT_UPC_EAN_EXTENSION,
+                        metadata.get(ResultMetadataType.UPC_EAN_EXTENSION).toString());
+            }
+            Number orientation = (Number) metadata.get(ResultMetadataType.ORIENTATION);
+            if (orientation != null) {
+                intent.putExtra(Intents.Scan.RESULT_ORIENTATION, orientation.intValue());
+            }
+            String ecLevel = (String) metadata.get(ResultMetadataType.ERROR_CORRECTION_LEVEL);
+            if (ecLevel != null) {
+                intent.putExtra(Intents.Scan.RESULT_ERROR_CORRECTION_LEVEL, ecLevel);
+            }
+
+            @SuppressWarnings("unchecked")
+            Iterable<byte[]> byteSegments = (Iterable<byte[]>) metadata.get(ResultMetadataType.BYTE_SEGMENTS);
+            if (byteSegments != null) {
+                int i = 0;
+                for (byte[] byteSegment : byteSegments) {
+                    intent.putExtra(Intents.Scan.RESULT_BYTE_SEGMENTS_PREFIX + i, byteSegment);
+                    i++;
+                }
+            }
+        }
+        sendReplyMessage(R.id.return_scan_result, intent, resultDurationMS);
+    }
+
+    private void sendReplyMessage(int id, Object arg, long delayMS) {
+        if (handler != null) {
+            Message message = Message.obtain(handler, id, arg);
+            if (delayMS > 0L) {
+                handler.sendMessageDelayed(message, delayMS);
+            } else {
+                handler.sendMessage(message);
+            }
+        }
+    }
+
+    private void decodeOrStoreSavedBitmap(Bitmap bitmap, Result result) {
+        // Bitmap isn't used yet -- will be used soon
+        if (handler == null) {
+            savedResultToShow = result;
+        } else {
+            if (result != null) {
+                savedResultToShow = result;
+            }
+            if (savedResultToShow != null) {
+                Message message = Message.obtain(handler, R.id.decode_succeeded, savedResultToShow);
+                handler.sendMessage(message);
+            }
+            savedResultToShow = null;
+        }
+    }
+
+    private void initCamera(SurfaceHolder surfaceHolder) {
+        if (surfaceHolder == null) {
+            throw new IllegalStateException("No SurfaceHolder provided");
+        }
+
+        /*if (PermissionUtil.getNoGrantedPermission(this, PermissionUtil.CAMERA_PERMISSIONS) != null) {
+            PermissionUtil.requestMultiPermissions(this, PermissionUtil.CAMERA_PERMISSIONS, PermissionUtil.CODE_CAMERA_SCAN);
+            return;
+        }*/
+
+        if (cameraManager.isOpen()) {
+            Log.w(TAG, "initCamera() while already open -- late SurfaceView callback?");
+            return;
+        }
+
+        try {
+            cameraManager.openDriver(surfaceHolder);
+            // Creating the handler starts the preview, which can also throw a RuntimeException.
+            if (handler == null) {
+                handler = new CaptureActivityHandler(this, decodeFormats, decodeHints, characterSet, cameraManager);
+            }
+            decodeOrStoreSavedBitmap(null, null);
+        } catch (IOException ioe) {
+            Log.w(TAG, ioe.getMessage());
+            ioe.printStackTrace();
+            displayFrameworkBugMessageAndExit();
+        } catch (RuntimeException e) {
+            // Barcode Scanner has seen crashes in the wild of this variety:
+            // java.?lang.?RuntimeException: Fail to connect to camera service
+            Log.w(TAG, "Unexpected error initializing camera = " + e.getMessage());
+            displayFrameworkBugMessageAndExit();
+        }
+    }
+
+    private void displayFrameworkBugMessageAndExit() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(getString(R.string.applicationLabel));
+        builder.setMessage(getString(R.string.msg_camera_framework_bug));
+        builder.setPositiveButton(R.string.button_ok, new FinishListener(this));
+        builder.setOnCancelListener(new FinishListener(this));
+        builder.show();
+    }
+
+    @Override
+    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
+        Log.d(tag(), "surface changed");
+    }
+
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        Log.d(tag(), "surface destroyed");
+        hasSurface = false;
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_BACK:
+                setResult(RESULT_CANCELED);
+                finish();
+                return true;
+
+            case KeyEvent.KEYCODE_FOCUS:
+            case KeyEvent.KEYCODE_CAMERA:
+                // Handle these events so they don't launch the Camera app
+                return true;
+
+            // Use volume up/down to turn on light
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+                cameraManager.setTorch(false);
+                return true;
+
+            case KeyEvent.KEYCODE_VOLUME_UP:
+                cameraManager.setTorch(true);
+                return true;
+        }
+        return super.onKeyDown(keyCode, event);
+    }
+
+    public void drawViewfinder() {
+        viewfinderView.drawViewfinder();
+    }
+}
diff --git a/src/com/android/contacts/util/barcode/CaptureActivityHandler.java b/src/com/android/contacts/util/barcode/CaptureActivityHandler.java
new file mode 100644
index 0000000..44d761f
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/CaptureActivityHandler.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.provider.Browser;
+import android.util.Log;
+
+import com.android.contacts.util.barcode.camera.CameraManager;
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.Result;
+
+import java.util.Collection;
+import java.util.Map;
+
+import com.android.contacts.R;
+
+
+/**
+ * This class handles all the messaging which comprises the state machine for capture.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class CaptureActivityHandler extends Handler {
+
+    private static final String TAG = CaptureActivityHandler.class.getSimpleName();
+
+    private final CaptureActivity activity;
+    private final DecodeThread decodeThread;
+    private State state;
+    private final CameraManager cameraManager;
+
+    private enum State {
+        PREVIEW,
+        SUCCESS,
+        DONE
+    }
+
+    CaptureActivityHandler(CaptureActivity activity,
+                           Collection<BarcodeFormat> decodeFormats,
+                           Map<DecodeHintType, ?> baseHints,
+                           String characterSet,
+                           CameraManager cameraManager) {
+        this.activity = activity;
+        decodeThread = new DecodeThread(activity, decodeFormats, baseHints, characterSet,
+                new ViewfinderResultPointCallback(activity.getViewfinderView()));
+        decodeThread.start();
+        state = State.SUCCESS;
+
+        // Start ourselves capturing previews and decoding.
+        this.cameraManager = cameraManager;
+        cameraManager.startPreview();
+        restartPreviewAndDecode();
+    }
+
+    @Override
+    public void handleMessage(Message message) {
+        switch (message.what) {
+            case R.id.restart_preview:
+                restartPreviewAndDecode();
+                break;
+
+            case R.id.decode_succeeded:
+                state = State.SUCCESS;
+                Bundle bundle = message.getData();
+                Bitmap barcode = null;
+                float scaleFactor = 1.0f;
+                if (bundle != null) {
+                    byte[] compressedBitmap = bundle.getByteArray(DecodeThread.BARCODE_BITMAP);
+                    if (compressedBitmap != null) {
+                        barcode = BitmapFactory.decodeByteArray(compressedBitmap, 0, compressedBitmap.length, null);
+                        // Mutable copy:
+                        barcode = barcode.copy(Bitmap.Config.ARGB_8888, true);
+                    }
+                    scaleFactor = bundle.getFloat(DecodeThread.BARCODE_SCALED_FACTOR);
+                }
+                activity.handleDecode((Result) message.obj, barcode, scaleFactor);
+                break;
+
+            case R.id.decode_failed:
+                // We're decoding as fast as possible, so when one decode fails, start another.
+                state = State.PREVIEW;
+                cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
+                break;
+
+            case R.id.return_scan_result:
+                activity.setResult(Activity.RESULT_OK, (Intent) message.obj);
+                activity.finish();
+                break;
+
+            case R.id.launch_product_query:
+                String url = (String) message.obj;
+
+                Intent intent = new Intent(Intent.ACTION_VIEW);
+                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+                intent.setData(Uri.parse(url));
+
+                ResolveInfo resolveInfo =
+                        activity.getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
+                String browserPackageName = null;
+                if (resolveInfo != null && resolveInfo.activityInfo != null) {
+                    browserPackageName = resolveInfo.activityInfo.packageName;
+                    Log.d(TAG, "Using browser in package " + browserPackageName);
+                }
+
+                // Needed for default Android browser / Chrome only apparently
+                if ("com.android.browser".equals(browserPackageName) || "com.android.chrome".equals(browserPackageName)) {
+                    intent.setPackage(browserPackageName);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    intent.putExtra(Browser.EXTRA_APPLICATION_ID, browserPackageName);
+                }
+
+                try {
+                    activity.startActivity(intent);
+                } catch (ActivityNotFoundException ignored) {
+                    Log.w(TAG, "Can't find anything to handle VIEW of URI " + url);
+                }
+                break;
+        }
+    }
+
+    public void quitSynchronously() {
+        state = State.DONE;
+        cameraManager.stopPreview();
+        Message quit = Message.obtain(decodeThread.getHandler(), R.id.quit);
+        quit.sendToTarget();
+        try {
+            // Wait at most half a second; should be enough time, and onPause() will timeout quickly
+            decodeThread.join(500L);
+        } catch (InterruptedException e) {
+            // continue
+        }
+
+        // Be absolutely sure we don't send any queued up messages
+        removeMessages(R.id.decode_succeeded);
+        removeMessages(R.id.decode_failed);
+    }
+
+    private void restartPreviewAndDecode() {
+        if (state == State.SUCCESS) {
+            state = State.PREVIEW;
+            cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
+            activity.drawViewfinder();
+        }
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/Contents.java b/src/com/android/contacts/util/barcode/Contents.java
new file mode 100644
index 0000000..162fc28
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/Contents.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.provider.ContactsContract;
+
+/**
+ * The set of constants to use when sending Barcode Scanner an Intent which requests a barcode
+ * to be encoded.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class Contents {
+  private Contents() {
+  }
+
+  /**
+   * Contains type constants used when sending Intents.
+   */
+  public static final class Type {
+    /**
+     * Plain text. Use Intent.putExtra(DATA, string). This can be used for URLs too, but string
+     * must include "http://" or "https://".
+     */
+    public static final String TEXT = "TEXT_TYPE";
+
+    /**
+     * An email type. Use Intent.putExtra(DATA, string) where string is the email address.
+     */
+    public static final String EMAIL = "EMAIL_TYPE";
+
+    /**
+     * Use Intent.putExtra(DATA, string) where string is the phone number to call.
+     */
+    public static final String PHONE = "PHONE_TYPE";
+
+    /**
+     * An SMS type. Use Intent.putExtra(DATA, string) where string is the number to SMS.
+     */
+    public static final String SMS = "SMS_TYPE";
+
+    /**
+     * A contact. Send a request to encode it as follows:
+     * {@code
+     * import android.provider.Contacts;
+     *
+     * Intent intent = new Intent(Intents.Encode.ACTION);
+     * intent.putExtra(Intents.Encode.TYPE, CONTACT);
+     * Bundle bundle = new Bundle();
+     * bundle.putString(ContactsContract.Intents.Insert.NAME, "Jenny");
+     * bundle.putString(ContactsContract.Intents.Insert.PHONE, "8675309");
+     * bundle.putString(ContactsContract.Intents.Insert.EMAIL, "jenny@the80s.com");
+     * bundle.putString(ContactsContract.Intents.Insert.POSTAL, "123 Fake St. San Francisco, CA 94102");
+     * intent.putExtra(Intents.Encode.DATA, bundle);
+     * }
+     */
+    public static final String CONTACT = "CONTACT_TYPE";
+
+    /**
+     * A geographic location. Use as follows:
+     * Bundle bundle = new Bundle();
+     * bundle.putFloat("LAT", latitude);
+     * bundle.putFloat("LONG", longitude);
+     * intent.putExtra(Intents.Encode.DATA, bundle);
+     */
+    public static final String LOCATION = "LOCATION_TYPE";
+
+    private Type() {
+    }
+  }
+
+  public static final String URL_KEY = "URL_KEY";
+
+  public static final String NOTE_KEY = "NOTE_KEY";
+
+  /**
+   * When using Type.CONTACT, these arrays provide the keys for adding or retrieving multiple
+   * phone numbers and addresses.
+   */
+  public static final String[] PHONE_KEYS = {
+      ContactsContract.Intents.Insert.PHONE,
+      ContactsContract.Intents.Insert.SECONDARY_PHONE,
+      ContactsContract.Intents.Insert.TERTIARY_PHONE
+  };
+
+  public static final String[] PHONE_TYPE_KEYS = {
+      ContactsContract.Intents.Insert.PHONE_TYPE,
+      ContactsContract.Intents.Insert.SECONDARY_PHONE_TYPE,
+      ContactsContract.Intents.Insert.TERTIARY_PHONE_TYPE
+  };
+
+  public static final String[] EMAIL_KEYS = {
+      ContactsContract.Intents.Insert.EMAIL,
+      ContactsContract.Intents.Insert.SECONDARY_EMAIL,
+      ContactsContract.Intents.Insert.TERTIARY_EMAIL
+  };
+
+  public static final String[] EMAIL_TYPE_KEYS = {
+      ContactsContract.Intents.Insert.EMAIL_TYPE,
+      ContactsContract.Intents.Insert.SECONDARY_EMAIL_TYPE,
+      ContactsContract.Intents.Insert.TERTIARY_EMAIL_TYPE
+  };
+
+}
diff --git a/src/com/android/contacts/util/barcode/DecodeFormatManager.java b/src/com/android/contacts/util/barcode/DecodeFormatManager.java
new file mode 100644
index 0000000..70f7aea
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/DecodeFormatManager.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.content.Intent;
+import android.net.Uri;
+
+import com.google.zxing.BarcodeFormat;
+
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+final class DecodeFormatManager {
+
+  private static final Pattern COMMA_PATTERN = Pattern.compile(",");
+
+  static final Set<BarcodeFormat> PRODUCT_FORMATS;
+  static final Set<BarcodeFormat> INDUSTRIAL_FORMATS;
+  private static final Set<BarcodeFormat> ONE_D_FORMATS;
+  static final Set<BarcodeFormat> QR_CODE_FORMATS = EnumSet.of(BarcodeFormat.QR_CODE);
+  static final Set<BarcodeFormat> DATA_MATRIX_FORMATS = EnumSet.of(BarcodeFormat.DATA_MATRIX);
+  static final Set<BarcodeFormat> AZTEC_FORMATS = EnumSet.of(BarcodeFormat.AZTEC);
+  static final Set<BarcodeFormat> PDF417_FORMATS = EnumSet.of(BarcodeFormat.PDF_417);
+  static {
+    PRODUCT_FORMATS = EnumSet.of(BarcodeFormat.UPC_A,
+                                 BarcodeFormat.UPC_E,
+                                 BarcodeFormat.EAN_13,
+                                 BarcodeFormat.EAN_8,
+                                 BarcodeFormat.RSS_14,
+                                 BarcodeFormat.RSS_EXPANDED);
+    INDUSTRIAL_FORMATS = EnumSet.of(BarcodeFormat.CODE_39,
+                                    BarcodeFormat.CODE_93,
+                                    BarcodeFormat.CODE_128,
+                                    BarcodeFormat.ITF,
+                                    BarcodeFormat.CODABAR);
+    ONE_D_FORMATS = EnumSet.copyOf(PRODUCT_FORMATS);
+    ONE_D_FORMATS.addAll(INDUSTRIAL_FORMATS);
+  }
+  private static final Map<String,Set<BarcodeFormat>> FORMATS_FOR_MODE;
+  static {
+    FORMATS_FOR_MODE = new HashMap<>();
+    FORMATS_FOR_MODE.put(Intents.Scan.ONE_D_MODE, ONE_D_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.PRODUCT_MODE, PRODUCT_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.QR_CODE_MODE, QR_CODE_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.DATA_MATRIX_MODE, DATA_MATRIX_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.AZTEC_MODE, AZTEC_FORMATS);
+    FORMATS_FOR_MODE.put(Intents.Scan.PDF417_MODE, PDF417_FORMATS);
+  }
+
+  private DecodeFormatManager() {}
+
+  static Set<BarcodeFormat> parseDecodeFormats(Intent intent) {
+    Iterable<String> scanFormats = null;
+    CharSequence scanFormatsString = intent.getStringExtra(Intents.Scan.FORMATS);
+    if (scanFormatsString != null) {
+      scanFormats = Arrays.asList(COMMA_PATTERN.split(scanFormatsString));
+    }
+    return parseDecodeFormats(scanFormats, intent.getStringExtra(Intents.Scan.MODE));
+  }
+
+  static Set<BarcodeFormat> parseDecodeFormats(Uri inputUri) {
+    List<String> formats = inputUri.getQueryParameters(Intents.Scan.FORMATS);
+    if (formats != null && formats.size() == 1 && formats.get(0) != null) {
+      formats = Arrays.asList(COMMA_PATTERN.split(formats.get(0)));
+    }
+    return parseDecodeFormats(formats, inputUri.getQueryParameter(Intents.Scan.MODE));
+  }
+
+  private static Set<BarcodeFormat> parseDecodeFormats(Iterable<String> scanFormats, String decodeMode) {
+    if (scanFormats != null) {
+      Set<BarcodeFormat> formats = EnumSet.noneOf(BarcodeFormat.class);
+      try {
+        for (String format : scanFormats) {
+          formats.add(BarcodeFormat.valueOf(format));
+        }
+        return formats;
+      } catch (IllegalArgumentException iae) {
+        // ignore it then
+      }
+    }
+    if (decodeMode != null) {
+      return FORMATS_FOR_MODE.get(decodeMode);
+    }
+    return null;
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/DecodeHandler.java b/src/com/android/contacts/util/barcode/DecodeHandler.java
new file mode 100644
index 0000000..eceafe6
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/DecodeHandler.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.graphics.Bitmap;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.util.Log;
+
+import com.google.zxing.BinaryBitmap;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.MultiFormatReader;
+import com.google.zxing.PlanarYUVLuminanceSource;
+import com.google.zxing.ReaderException;
+import com.google.zxing.Result;
+import com.google.zxing.common.HybridBinarizer;
+
+import java.io.ByteArrayOutputStream;
+import java.util.Map;
+
+import com.android.contacts.R;
+
+final class DecodeHandler extends Handler {
+
+    private static final String TAG = DecodeHandler.class.getSimpleName();
+
+    private final CaptureActivity activity;
+    private final MultiFormatReader multiFormatReader;
+    private boolean running = true;
+
+    DecodeHandler(CaptureActivity activity, Map<DecodeHintType, Object> hints) {
+        multiFormatReader = new MultiFormatReader();
+        multiFormatReader.setHints(hints);
+        this.activity = activity;
+    }
+
+    @Override
+    public void handleMessage(Message message) {
+        if (!running) {
+            return;
+        }
+        switch (message.what) {
+            case R.id.decode:
+                decode((byte[]) message.obj, message.arg1, message.arg2);
+                break;
+
+            case R.id.quit:
+                running = false;
+                Looper.myLooper().quit();
+                break;
+        }
+    }
+
+    /**
+     * Decode the data within the viewfinder rectangle, and time how long it took. For efficiency,
+     * reuse the same reader objects from one decode to the next.
+     *
+     * @param data   The YUV preview frame.
+     * @param width  The width of the preview frame.
+     * @param height The height of the preview frame.
+     */
+    private void decode(byte[] data, int width, int height) {
+        long start = System.currentTimeMillis();
+        Result rawResult = null;
+
+        // 构造基于平面的YUV亮度源，即包含二维码区域的数据源
+        PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);
+        if (source != null) {
+            // 构造二值图像比特流，使用HybridBinarizer算法解析数据源
+            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));
+            try {
+                // 采用MultiFormatReader解析图像，可以解析多种数据格式
+                rawResult = multiFormatReader.decodeWithState(bitmap);
+            } catch (ReaderException re) {
+                // continue
+            } finally {
+                multiFormatReader.reset();
+            }
+        }
+
+        // Hanlder处理解析失败或成功的结果
+        Handler handler = activity.getHandler();
+        if (rawResult != null) {
+            // Don't log the barcode contents for security.
+            long end = System.currentTimeMillis();
+            Log.d(TAG, "Found barcode in " + (end - start) + " ms");
+            if (handler != null) {
+                Message message = Message.obtain(handler, R.id.decode_succeeded, rawResult);
+                Bundle bundle = new Bundle();
+                bundleThumbnail(source, bundle);
+                message.setData(bundle);
+                message.sendToTarget();
+            }
+        } else {
+            if (handler != null) {
+                Message message = Message.obtain(handler, R.id.decode_failed);
+                message.sendToTarget();
+            }
+        }
+    }
+
+    private static void bundleThumbnail(PlanarYUVLuminanceSource source, Bundle bundle) {
+        int[] pixels = source.renderThumbnail();
+        int width = source.getThumbnailWidth();
+        int height = source.getThumbnailHeight();
+        Bitmap bitmap = Bitmap.createBitmap(pixels, 0, width, width, height, Bitmap.Config.ARGB_8888);
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        bitmap.compress(Bitmap.CompressFormat.JPEG, 50, out);
+        bundle.putByteArray(DecodeThread.BARCODE_BITMAP, out.toByteArray());
+        bundle.putFloat(DecodeThread.BARCODE_SCALED_FACTOR, (float) width / source.getWidth());
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/DecodeHintManager.java b/src/com/android/contacts/util/barcode/DecodeHintManager.java
new file mode 100644
index 0000000..1f297c6
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/DecodeHintManager.java
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2013 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.google.zxing.DecodeHintType;
+
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Pattern;
+
+/**
+ * @author Lachezar Dobrev
+ */
+final class DecodeHintManager {
+  
+  private static final String TAG = DecodeHintManager.class.getSimpleName();
+
+  // This pattern is used in decoding integer arrays.
+  private static final Pattern COMMA = Pattern.compile(",");
+
+  private DecodeHintManager() {}
+
+  /**
+   * <p>Split a query string into a list of name-value pairs.</p>
+   * 
+   * <p>This is an alternative to the {@link Uri#getQueryParameterNames()} and
+   * {@link Uri#getQueryParameters(String)}, which are quirky and not suitable
+   * for exist-only Uri parameters.</p>
+   * 
+   * <p>This method ignores multiple parameters with the same name and returns the
+   * first one only. This is technically incorrect, but should be acceptable due
+   * to the method of processing Hints: no multiple values for a hint.</p>
+   * 
+   * @param query query to split
+   * @return name-value pairs
+   */
+  private static Map<String,String> splitQuery(String query) {
+    Map<String,String> map = new HashMap<>();
+    int pos = 0;
+    while (pos < query.length()) {
+      if (query.charAt(pos) == '&') {
+        // Skip consecutive ampersand separators.
+        pos ++;
+        continue;
+      }
+      int amp = query.indexOf('&', pos);
+      int equ = query.indexOf('=', pos);
+      if (amp < 0) {
+        // This is the last element in the query, no more ampersand elements.
+        String name;
+        String text;
+        if (equ < 0) {
+          // No equal sign
+          name = query.substring(pos);
+          name = name.replace('+', ' '); // Preemptively decode +
+          name = Uri.decode(name);
+          text = "";
+        } else {
+          // Split name and text.
+          name = query.substring(pos, equ);
+          name = name.replace('+', ' '); // Preemptively decode +
+          name = Uri.decode(name);
+          text = query.substring(equ + 1);
+          text = text.replace('+', ' '); // Preemptively decode +
+          text = Uri.decode(text);
+        }
+        if (!map.containsKey(name)) {
+          map.put(name, text);
+        }
+        break;
+      }
+      if (equ < 0 || equ > amp) {
+        // No equal sign until the &: this is a simple parameter with no value.
+        String name = query.substring(pos, amp);
+        name = name.replace('+', ' '); // Preemptively decode +
+        name = Uri.decode(name);
+        if (!map.containsKey(name)) {
+          map.put(name, "");
+        }
+        pos = amp + 1;
+        continue;
+      }
+      String name = query.substring(pos, equ);
+      name = name.replace('+', ' '); // Preemptively decode +
+      name = Uri.decode(name);
+      String text = query.substring(equ + 1, amp);
+      text = text.replace('+', ' '); // Preemptively decode +
+      text = Uri.decode(text);
+      if (!map.containsKey(name)) {
+        map.put(name, text);
+      }
+      pos = amp + 1;
+    }
+    return map;
+  }
+
+  static Map<DecodeHintType,?> parseDecodeHints(Uri inputUri) {
+    String query = inputUri.getEncodedQuery();
+    if (query == null || query.isEmpty()) {
+      return null;
+    }
+
+    // Extract parameters
+    Map<String, String> parameters = splitQuery(query);
+
+    Map<DecodeHintType, Object> hints = new EnumMap<>(DecodeHintType.class);
+
+    for (DecodeHintType hintType: DecodeHintType.values()) {
+
+      if (hintType == DecodeHintType.CHARACTER_SET ||
+          hintType == DecodeHintType.NEED_RESULT_POINT_CALLBACK ||
+          hintType == DecodeHintType.POSSIBLE_FORMATS) {
+        continue; // This hint is specified in another way
+      }
+
+      String parameterName = hintType.name();
+      String parameterText = parameters.get(parameterName);
+      if (parameterText == null) {
+        continue;
+      }
+      if (hintType.getValueType().equals(Object.class)) {
+        // This is an unspecified type of hint content. Use the value as is.
+        // TODO: Can we make a different assumption on this?
+        hints.put(hintType, parameterText);
+        continue;
+      }
+      if (hintType.getValueType().equals(Void.class)) {
+        // Void hints are just flags: use the constant specified by DecodeHintType
+        hints.put(hintType, Boolean.TRUE);
+        continue;
+      }
+      if (hintType.getValueType().equals(String.class)) {
+        // A string hint: use the decoded value.
+        hints.put(hintType, parameterText);
+        continue;
+      }
+      if (hintType.getValueType().equals(Boolean.class)) {
+        // A boolean hint: a few values for false, everything else is true.
+        // An empty parameter is simply a flag-style parameter, assuming true
+        if (parameterText.isEmpty()) {
+          hints.put(hintType, Boolean.TRUE);
+        } else if ("0".equals(parameterText) || 
+                   "false".equalsIgnoreCase(parameterText) || 
+                   "no".equalsIgnoreCase(parameterText)) {
+          hints.put(hintType, Boolean.FALSE);
+        } else {
+          hints.put(hintType, Boolean.TRUE);
+        }
+
+        continue;
+      }
+      if (hintType.getValueType().equals(int[].class)) {
+        // An integer array. Used to specify valid lengths.
+        // Strip a trailing comma as in Java style array initialisers.
+        if (!parameterText.isEmpty() && parameterText.charAt(parameterText.length() - 1) == ',') {
+          parameterText = parameterText.substring(0, parameterText.length() - 1);
+        }
+        String[] values = COMMA.split(parameterText);
+        int[] array = new int[values.length];
+        for (int i = 0; i < values.length; i++) {
+          try {
+            array[i] = Integer.parseInt(values[i]);
+          } catch (NumberFormatException ignored) {
+            Log.w(TAG, "Skipping array of integers hint " + hintType + " due to invalid numeric value: '" + values[i] + '\'');
+            array = null;
+            break;
+          }
+        }
+        if (array != null) {
+          hints.put(hintType, array);
+        }
+        continue;
+      } 
+      Log.w(TAG, "Unsupported hint type '" + hintType + "' of type " + hintType.getValueType());
+    }
+
+    Log.i(TAG, "Hints from the URI: " + hints);
+    return hints;
+  }
+
+  static Map<DecodeHintType, Object> parseDecodeHints(Intent intent) {
+    Bundle extras = intent.getExtras();
+    if (extras == null || extras.isEmpty()) {
+      return null;
+    }
+    Map<DecodeHintType,Object> hints = new EnumMap<>(DecodeHintType.class);
+
+    for (DecodeHintType hintType: DecodeHintType.values()) {
+
+      if (hintType == DecodeHintType.CHARACTER_SET ||
+          hintType == DecodeHintType.NEED_RESULT_POINT_CALLBACK ||
+          hintType == DecodeHintType.POSSIBLE_FORMATS) {
+        continue; // This hint is specified in another way
+      }
+
+      String hintName = hintType.name();
+      if (extras.containsKey(hintName)) {
+        if (hintType.getValueType().equals(Void.class)) {
+          // Void hints are just flags: use the constant specified by the DecodeHintType
+          hints.put(hintType, Boolean.TRUE);
+        } else {
+          Object hintData = extras.get(hintName);
+          if (hintType.getValueType().isInstance(hintData)) {
+            hints.put(hintType, hintData);
+          } else {
+            Log.w(TAG, "Ignoring hint " + hintType + " because it is not assignable from " + hintData);
+          }
+        }
+      }
+    }
+
+    Log.i(TAG, "Hints from the Intent: " + hints);
+    return hints;
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/DecodeThread.java b/src/com/android/contacts/util/barcode/DecodeThread.java
new file mode 100644
index 0000000..376902f
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/DecodeThread.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.content.SharedPreferences;
+import android.os.Handler;
+import android.os.Looper;
+import android.preference.PreferenceManager;
+import android.util.Log;
+
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.ResultPointCallback;
+
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * This thread does all the heavy lifting of decoding the images.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+final class DecodeThread extends Thread {
+
+    public static final String BARCODE_BITMAP = "barcode_bitmap";
+    public static final String BARCODE_SCALED_FACTOR = "barcode_scaled_factor";
+
+    private final CaptureActivity activity;
+    private final Map<DecodeHintType, Object> hints;
+    private Handler handler;
+    private final CountDownLatch handlerInitLatch;
+
+    DecodeThread(CaptureActivity activity,
+                 Collection<BarcodeFormat> decodeFormats,
+                 Map<DecodeHintType, ?> baseHints,
+                 String characterSet,
+                 ResultPointCallback resultPointCallback) {
+
+        this.activity = activity;
+        handlerInitLatch = new CountDownLatch(1);
+
+        hints = new EnumMap<>(DecodeHintType.class);
+        if (baseHints != null) {
+            hints.putAll(baseHints);
+        }
+
+        // The prefs can't change while the thread is running, so pick them up once here.
+        if (decodeFormats == null || decodeFormats.isEmpty()) {
+            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
+            decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
+
+            // 一维码: 商品
+            decodeFormats.addAll(DecodeFormatManager.PRODUCT_FORMATS);
+
+            // 一维码: 工业
+            decodeFormats.addAll(DecodeFormatManager.INDUSTRIAL_FORMATS);
+
+            // 二维码
+            decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);
+
+            // Data Matrix
+            decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);
+
+            // Aztec
+            decodeFormats.addAll(DecodeFormatManager.AZTEC_FORMATS);
+
+            // PDF417
+            decodeFormats.addAll(DecodeFormatManager.PDF417_FORMATS);
+        }
+        hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
+
+        if (characterSet != null) {
+            hints.put(DecodeHintType.CHARACTER_SET, characterSet);
+        }
+        hints.put(DecodeHintType.NEED_RESULT_POINT_CALLBACK, resultPointCallback);
+        Log.i("DecodeThread", "Hints: " + hints);
+    }
+
+    Handler getHandler() {
+        try {
+            handlerInitLatch.await();
+        } catch (InterruptedException ie) {
+            // continue?
+        }
+        return handler;
+    }
+
+    @Override
+    public void run() {
+        Looper.prepare();
+        handler = new DecodeHandler(activity, hints);
+        handlerInitLatch.countDown();
+        Looper.loop();
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/FinishListener.java b/src/com/android/contacts/util/barcode/FinishListener.java
new file mode 100644
index 0000000..40a9766
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/FinishListener.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.app.Activity;
+import android.content.DialogInterface;
+
+/**
+ * Simple listener used to exit the app in a few cases.
+ *
+ * @author Sean Owen
+ */
+public final class FinishListener implements DialogInterface.OnClickListener, DialogInterface.OnCancelListener {
+
+  private final Activity activityToFinish;
+
+  public FinishListener(Activity activityToFinish) {
+    this.activityToFinish = activityToFinish;
+  }
+
+  @Override
+  public void onCancel(DialogInterface dialogInterface) {
+    run();
+  }
+
+  @Override
+  public void onClick(DialogInterface dialogInterface, int i) {
+    run();
+  }
+
+  private void run() {
+    activityToFinish.finish();
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/Intents.java b/src/com/android/contacts/util/barcode/Intents.java
new file mode 100644
index 0000000..23625de
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/Intents.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+/**
+ * This class provides the constants to use when sending an Intent to Barcode Scanner.
+ * These strings are effectively API and cannot be changed.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class Intents {
+  private Intents() {
+  }
+
+  /**
+   * Constants related to the {@link Scan#ACTION} Intent.
+   */
+  public static final class Scan {
+    /**
+     * Send this intent to open the Barcodes app in scanning mode, find a barcode, and return
+     * the results.
+     */
+    public static final String ACTION = "com.njzhikejia.mabaojia.SCAN";
+
+    /**
+     * By default, sending this will decode all barcodes that we understand. However it
+     * may be useful to limit scanning to certain formats. Use
+     * {@link android.content.Intent#putExtra(String, String)} with one of the values below.
+     *
+     * Setting this is effectively shorthand for setting explicit formats with {@link #FORMATS}.
+     * It is overridden by that setting.
+     */
+    public static final String MODE = "SCAN_MODE";
+
+    /**
+     * Decode only UPC and EAN barcodes. This is the right choice for shopping apps which get
+     * prices, reviews, etc. for products.
+     */
+    public static final String PRODUCT_MODE = "PRODUCT_MODE";
+
+    /**
+     * Decode only 1D barcodes.
+     */
+    public static final String ONE_D_MODE = "ONE_D_MODE";
+
+    /**
+     * Decode only QR codes.
+     */
+    public static final String QR_CODE_MODE = "QR_CODE_MODE";
+
+    /**
+     * Decode only Data Matrix codes.
+     */
+    public static final String DATA_MATRIX_MODE = "DATA_MATRIX_MODE";
+
+    /**
+     * Decode only Aztec.
+     */
+    public static final String AZTEC_MODE = "AZTEC_MODE";
+
+    /**
+     * Decode only PDF417.
+     */
+    public static final String PDF417_MODE = "PDF417_MODE";
+
+    /**
+     * Comma-separated list of formats to scan for. The values must match the names of
+     * {@link com.google.zxing.BarcodeFormat}s, e.g. {@link com.google.zxing.BarcodeFormat#EAN_13}.
+     * Example: "EAN_13,EAN_8,QR_CODE". This overrides {@link #MODE}.
+     */
+    public static final String FORMATS = "SCAN_FORMATS";
+
+    /**
+     * Optional parameter to specify the id of the camera from which to recognize barcodes.
+     * Overrides the default camera that would otherwise would have been selected.
+     * If provided, should be an int.
+     */
+    public static final String CAMERA_ID = "SCAN_CAMERA_ID";
+
+    /**
+     * @see com.google.zxing.DecodeHintType#CHARACTER_SET
+     */
+    public static final String CHARACTER_SET = "CHARACTER_SET";
+
+    /**
+     * Optional parameters to specify the width and height of the scanning rectangle in pixels.
+     * The app will try to honor these, but will clamp them to the size of the preview frame.
+     * You should specify both or neither, and pass the size as an int.
+     */
+    public static final String WIDTH = "SCAN_WIDTH";
+    public static final String HEIGHT = "SCAN_HEIGHT";
+
+    /**
+     * Desired duration in milliseconds for which to pause after a successful scan before
+     * returning to the calling intent. Specified as a long, not an integer!
+     * For example: 1000L, not 1000.
+     */
+    public static final String RESULT_DISPLAY_DURATION_MS = "RESULT_DISPLAY_DURATION_MS";
+
+    /**
+     * Prompt to show on-screen when scanning by intent. Specified as a {@link String}.
+     */
+    public static final String PROMPT_MESSAGE = "PROMPT_MESSAGE";
+
+    /**
+     * If a barcode is found, Barcodes returns {@link android.app.Activity#RESULT_OK} to
+     * {@link android.app.Activity#onActivityResult(int, int, android.content.Intent)}
+     * of the app which requested the scan via
+     * {@link android.app.Activity#startActivityForResult(android.content.Intent, int)}
+     * The barcodes contents can be retrieved with
+     * {@link android.content.Intent#getStringExtra(String)}.
+     * If the user presses Back, the result code will be {@link android.app.Activity#RESULT_CANCELED}.
+     */
+    public static final String RESULT = "SCAN_RESULT";
+
+    /**
+     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_FORMAT}
+     * to determine which barcode format was found.
+     * See {@link com.google.zxing.BarcodeFormat} for possible values.
+     */
+    public static final String RESULT_FORMAT = "SCAN_RESULT_FORMAT";
+
+    /**
+     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_UPC_EAN_EXTENSION}
+     * to return the content of any UPC extension barcode that was also found. Only applicable
+     * to {@link com.google.zxing.BarcodeFormat#UPC_A} and {@link com.google.zxing.BarcodeFormat#EAN_13}
+     * formats.
+     */
+    public static final String RESULT_UPC_EAN_EXTENSION = "SCAN_RESULT_UPC_EAN_EXTENSION";
+
+    /**
+     * Call {@link android.content.Intent#getByteArrayExtra(String)} with {@link #RESULT_BYTES}
+     * to get a {@code byte[]} of raw bytes in the barcode, if available.
+     */
+    public static final String RESULT_BYTES = "SCAN_RESULT_BYTES";
+
+    /**
+     * Key for the value of {@link com.google.zxing.ResultMetadataType#ORIENTATION}, if available.
+     * Call {@link android.content.Intent#getIntArrayExtra(String)} with {@link #RESULT_ORIENTATION}.
+     */
+    public static final String RESULT_ORIENTATION = "SCAN_RESULT_ORIENTATION";
+
+    /**
+     * Key for the value of {@link com.google.zxing.ResultMetadataType#ERROR_CORRECTION_LEVEL}, if available.
+     * Call {@link android.content.Intent#getStringExtra(String)} with {@link #RESULT_ERROR_CORRECTION_LEVEL}.
+     */
+    public static final String RESULT_ERROR_CORRECTION_LEVEL = "SCAN_RESULT_ERROR_CORRECTION_LEVEL";
+
+    /**
+     * Prefix for keys that map to the values of {@link com.google.zxing.ResultMetadataType#BYTE_SEGMENTS},
+     * if available. The actual values will be set under a series of keys formed by adding 0, 1, 2, ...
+     * to this prefix. So the first byte segment is under key "SCAN_RESULT_BYTE_SEGMENTS_0" for example.
+     * Call {@link android.content.Intent#getByteArrayExtra(String)} with these keys.
+     */
+    public static final String RESULT_BYTE_SEGMENTS_PREFIX = "SCAN_RESULT_BYTE_SEGMENTS_";
+
+    /**
+     * Setting this to false will not save scanned codes in the history. Specified as a {@code boolean}.
+     */
+    public static final String SAVE_HISTORY = "SAVE_HISTORY";
+
+    private Scan() {
+    }
+  }
+
+  /**
+   * Constants related to the scan history and retrieving history items.
+   */
+  public static final class History {
+
+    public static final String ITEM_NUMBER = "ITEM_NUMBER";
+
+    private History() {
+    }
+  }
+
+  /**
+   * Constants related to the {@link Encode#ACTION} Intent.
+   */
+  public static final class Encode {
+    /**
+     * Send this intent to encode a piece of data as a QR code and display it full screen, so
+     * that another person can scan the barcode from your screen.
+     */
+    public static final String ACTION = "com.google.zxing.client.android.ENCODE";
+
+    /**
+     * The data to encode. Use {@link android.content.Intent#putExtra(String, String)} or
+     * {@link android.content.Intent#putExtra(String, android.os.Bundle)},
+     * depending on the type and format specified. Non-QR Code formats should
+     * just use a String here. For QR Code, see Contents for details.
+     */
+    public static final String DATA = "ENCODE_DATA";
+
+    /**
+     * The type of data being supplied if the format is QR Code. Use
+     * {@link android.content.Intent#putExtra(String, String)} with one of {@link Contents.Type}.
+     */
+    public static final String TYPE = "ENCODE_TYPE";
+
+    /**
+     * The barcode format to be displayed. If this isn't specified or is blank,
+     * it defaults to QR Code. Use {@link android.content.Intent#putExtra(String, String)}, where
+     * format is one of {@link com.google.zxing.BarcodeFormat}.
+     */
+    public static final String FORMAT = "ENCODE_FORMAT";
+
+    /**
+     * Normally the contents of the barcode are displayed to the user in a TextView. Setting this
+     * boolean to false will hide that TextView, showing only the encode barcode.
+     */
+    public static final String SHOW_CONTENTS = "ENCODE_SHOW_CONTENTS";
+
+    private Encode() {
+    }
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/LocaleManager.java b/src/com/android/contacts/util/barcode/LocaleManager.java
new file mode 100644
index 0000000..085835c
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/LocaleManager.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.content.Context;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * Handles any locale-specific logic for the client.
+ *
+ * @author Sean Owen
+ */
+public final class LocaleManager {
+
+  private static final String DEFAULT_TLD = "com";
+  private static final String DEFAULT_COUNTRY = "US";
+  private static final String DEFAULT_LANGUAGE = "en";
+
+  /**
+   * Locales (well, countries) where Google web search is available.
+   * These should be kept in sync with our translations.
+   */
+  private static final Map<String,String> GOOGLE_COUNTRY_TLD;
+  static {
+    GOOGLE_COUNTRY_TLD = new HashMap<>();
+    GOOGLE_COUNTRY_TLD.put("AR", "com.ar"); // ARGENTINA
+    GOOGLE_COUNTRY_TLD.put("AU", "com.au"); // AUSTRALIA
+    GOOGLE_COUNTRY_TLD.put("BR", "com.br"); // BRAZIL
+    GOOGLE_COUNTRY_TLD.put("BG", "bg"); // BULGARIA
+    GOOGLE_COUNTRY_TLD.put(Locale.CANADA.getCountry(), "ca");
+    GOOGLE_COUNTRY_TLD.put(Locale.CHINA.getCountry(), "cn");
+    GOOGLE_COUNTRY_TLD.put("CZ", "cz"); // CZECH REPUBLIC
+    GOOGLE_COUNTRY_TLD.put("DK", "dk"); // DENMARK
+    GOOGLE_COUNTRY_TLD.put("FI", "fi"); // FINLAND
+    GOOGLE_COUNTRY_TLD.put(Locale.FRANCE.getCountry(), "fr");
+    GOOGLE_COUNTRY_TLD.put(Locale.GERMANY.getCountry(), "de");
+    GOOGLE_COUNTRY_TLD.put("GR", "gr"); // GREECE
+    GOOGLE_COUNTRY_TLD.put("HU", "hu"); // HUNGARY
+    GOOGLE_COUNTRY_TLD.put("ID", "co.id"); // INDONESIA
+    GOOGLE_COUNTRY_TLD.put("IL", "co.il"); // ISRAEL
+    GOOGLE_COUNTRY_TLD.put(Locale.ITALY.getCountry(), "it");
+    GOOGLE_COUNTRY_TLD.put(Locale.JAPAN.getCountry(), "co.jp");
+    GOOGLE_COUNTRY_TLD.put(Locale.KOREA.getCountry(), "co.kr");
+    GOOGLE_COUNTRY_TLD.put("NL", "nl"); // NETHERLANDS
+    GOOGLE_COUNTRY_TLD.put("PL", "pl"); // POLAND
+    GOOGLE_COUNTRY_TLD.put("PT", "pt"); // PORTUGAL
+    GOOGLE_COUNTRY_TLD.put("RO", "ro"); // ROMANIA    
+    GOOGLE_COUNTRY_TLD.put("RU", "ru"); // RUSSIA
+    GOOGLE_COUNTRY_TLD.put("SK", "sk"); // SLOVAK REPUBLIC
+    GOOGLE_COUNTRY_TLD.put("SI", "si"); // SLOVENIA
+    GOOGLE_COUNTRY_TLD.put("ES", "es"); // SPAIN
+    GOOGLE_COUNTRY_TLD.put("SE", "se"); // SWEDEN
+    GOOGLE_COUNTRY_TLD.put("CH", "ch"); // SWITZERLAND    
+    GOOGLE_COUNTRY_TLD.put(Locale.TAIWAN.getCountry(), "tw");
+    GOOGLE_COUNTRY_TLD.put("TR", "com.tr"); // TURKEY
+    GOOGLE_COUNTRY_TLD.put("UA", "com.ua"); // UKRAINE
+    GOOGLE_COUNTRY_TLD.put(Locale.UK.getCountry(), "co.uk");
+    GOOGLE_COUNTRY_TLD.put(Locale.US.getCountry(), "com");
+  }
+
+  /**
+   * Google Product Search for mobile is available in fewer countries than web search. See here:
+   * http://support.google.com/merchants/bin/answer.py?hl=en-GB&answer=160619
+   */
+  private static final Map<String,String> GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD;
+  static {
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD = new HashMap<>();
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("AU", "com.au"); // AUSTRALIA
+    //GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.CHINA.getCountry(), "cn");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.FRANCE.getCountry(), "fr");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.GERMANY.getCountry(), "de");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.ITALY.getCountry(), "it");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.JAPAN.getCountry(), "co.jp");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("NL", "nl"); // NETHERLANDS
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("ES", "es"); // SPAIN
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put("CH", "ch"); // SWITZERLAND
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.UK.getCountry(), "co.uk");
+    GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD.put(Locale.US.getCountry(), "com");
+  }
+
+  /**
+   * Book search is offered everywhere that web search is available.
+   */
+  private static final Map<String,String> GOOGLE_BOOK_SEARCH_COUNTRY_TLD = GOOGLE_COUNTRY_TLD;
+
+  private static final Collection<String> TRANSLATED_HELP_ASSET_LANGUAGES =
+      Arrays.asList("de", "en", "es", "fr", "it", "ja", "ko", "nl", "pt", "ru", "uk", "zh-rCN", "zh-rTW", "zh-rHK");
+
+  private LocaleManager() {}
+
+  /**
+   * @param context application's {@link Context}
+   * @return country-specific TLD suffix appropriate for the current default locale
+   *  (e.g. "co.uk" for the United Kingdom)
+   */
+  public static String getCountryTLD(Context context) {
+    return doGetTLD(GOOGLE_COUNTRY_TLD, context);
+  }
+
+  /**
+   * The same as above, but specifically for Google Product Search.
+   *
+   * @param context application's {@link Context}
+   * @return The top-level domain to use.
+   */
+  public static String getProductSearchCountryTLD(Context context) {
+    return doGetTLD(GOOGLE_PRODUCT_SEARCH_COUNTRY_TLD, context);
+  }
+
+  /**
+   * The same as above, but specifically for Google Book Search.
+   *
+   * @param context application's {@link Context}
+   * @return The top-level domain to use.
+   */
+  public static String getBookSearchCountryTLD(Context context) {
+    return doGetTLD(GOOGLE_BOOK_SEARCH_COUNTRY_TLD, context);
+  }
+
+  /**
+   * Does a given URL point to Google Book Search, regardless of domain.
+   *
+   * @param url The address to check.
+   * @return True if this is a Book Search URL.
+   */
+  public static boolean isBookSearchUrl(String url) {
+    return url.startsWith("http://google.com/books") || url.startsWith("http://books.google.");
+  }
+
+  private static String getSystemCountry() {
+    Locale locale = Locale.getDefault();
+    return locale == null ? DEFAULT_COUNTRY : locale.getCountry();
+  }
+
+  private static String getSystemLanguage() {
+    Locale locale = Locale.getDefault();
+    if (locale == null) {
+      return DEFAULT_LANGUAGE;
+    }
+    String language = locale.getLanguage();
+    // Special case Chinese
+    if (Locale.SIMPLIFIED_CHINESE.getLanguage().equals(language)) {
+      return language + "-r" + getSystemCountry();
+    }
+    return language;
+  }
+
+  static String getTranslatedAssetLanguage() {
+    String language = getSystemLanguage();
+    return TRANSLATED_HELP_ASSET_LANGUAGES.contains(language) ? language : DEFAULT_LANGUAGE;
+  }
+
+  private static String doGetTLD(Map<String,String> map, Context context) {
+    String tld = map.get(getCountry(context));
+    return tld == null ? DEFAULT_TLD : tld;
+  }
+
+  private static String getCountry(Context context) {
+    String countryOverride = "-";
+    if (!countryOverride.isEmpty() && !"-".equals(countryOverride)) {
+      return countryOverride;
+    }
+    return getSystemCountry();
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/ViewfinderResultPointCallback.java b/src/com/android/contacts/util/barcode/ViewfinderResultPointCallback.java
new file mode 100644
index 0000000..ec77bc4
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/ViewfinderResultPointCallback.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2009 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import com.google.zxing.ResultPoint;
+import com.google.zxing.ResultPointCallback;
+
+final class ViewfinderResultPointCallback implements ResultPointCallback {
+
+    private final ViewfinderView viewfinderView;
+
+    ViewfinderResultPointCallback(ViewfinderView viewfinderView) {
+        this.viewfinderView = viewfinderView;
+    }
+
+    @Override
+    public void foundPossibleResultPoint(ResultPoint point) {
+        viewfinderView.addPossibleResultPoint(point);
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/ViewfinderView.java b/src/com/android/contacts/util/barcode/ViewfinderView.java
new file mode 100644
index 0000000..33680b6
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/ViewfinderView.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.util.AttributeSet;
+import android.view.View;
+
+import com.android.contacts.util.barcode.camera.CameraManager;
+import com.google.zxing.ResultPoint;
+
+import java.util.Collection;
+import java.util.HashSet;
+
+import com.android.contacts.R;
+
+
+/**
+ * This view is overlaid on top of the camera preview. It adds the viewfinder rectangle and partial
+ * transparency outside it, as well as the laser scanner animation and result points.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ViewfinderView extends View {
+    private CameraManager cameraManager;
+
+    private static final long ANIMATION_DELAY = 10L;
+    private static final int OPAQUE = 0xFF;
+
+    private int ScreenRate;
+    private static final int CORNER_WIDTH = 10;
+    private static final int MIDDLE_LINE_WIDTH = 4;
+    private static final int MIDDLE_LINE_PADDING = 5;
+    private static final int SPEEN_DISTANCE = 5;
+    private static float density;
+
+    private Paint paint;
+    private int slideTop;
+    private int slideBottom;
+
+    private Bitmap resultBitmap;
+    private final int maskColor;
+    private final int resultColor;
+
+    private final int resultPointColor;
+    private Collection<ResultPoint> possibleResultPoints;
+    private Collection<ResultPoint> lastPossibleResultPoints;
+
+    boolean isFirst;
+
+    public ViewfinderView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        density = context.getResources().getDisplayMetrics().density;
+        ScreenRate = (int)(20 * density);
+
+        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        Resources resources = getResources();
+        maskColor = resources.getColor(R.color.viewfinder_mask);
+        resultColor = resources.getColor(R.color.result_view);
+
+        resultPointColor = resources.getColor(R.color.possible_result_points);
+        possibleResultPoints = new HashSet<ResultPoint>(5);
+    }
+
+    public void setCameraManager(CameraManager cameraManager) {
+        this.cameraManager = cameraManager;
+    }
+
+    @SuppressLint("DrawAllocation")
+    @Override
+    public void onDraw(Canvas canvas) {
+        if (cameraManager == null) {
+            return; // not ready yet, early draw before done configuring
+        }
+        Rect frame = cameraManager.getFramingRect();
+        if (frame == null) {
+            return;
+        }
+
+        if(!isFirst){
+            isFirst = true;
+            slideTop = frame.top;
+            slideBottom = frame.bottom;
+        }
+
+        int width = canvas.getWidth();
+        int height = canvas.getHeight();
+
+        paint.setColor(resultBitmap != null ? resultColor : maskColor);
+
+        canvas.drawRect(0, 0, width, frame.top, paint);
+        canvas.drawRect(0, frame.top, frame.left, frame.bottom + 1, paint);
+        canvas.drawRect(frame.right + 1, frame.top, width, frame.bottom + 1,
+                paint);
+        canvas.drawRect(0, frame.bottom + 1, width, height, paint);
+
+        if (resultBitmap == null) {
+            paint.setColor(getResources().getColor(R.color.colorAccent));
+            canvas.drawRect(frame.left, frame.top, frame.left + ScreenRate,
+                    frame.top + CORNER_WIDTH, paint);
+            canvas.drawRect(frame.left, frame.top, frame.left + CORNER_WIDTH, frame.top
+                    + ScreenRate, paint);
+            canvas.drawRect(frame.right - ScreenRate, frame.top, frame.right,
+                    frame.top + CORNER_WIDTH, paint);
+            canvas.drawRect(frame.right - CORNER_WIDTH, frame.top, frame.right, frame.top
+                    + ScreenRate, paint);
+            canvas.drawRect(frame.left, frame.bottom - CORNER_WIDTH, frame.left
+                    + ScreenRate, frame.bottom, paint);
+            canvas.drawRect(frame.left, frame.bottom - ScreenRate,
+                    frame.left + CORNER_WIDTH, frame.bottom, paint);
+            canvas.drawRect(frame.right - ScreenRate, frame.bottom - CORNER_WIDTH,
+                    frame.right, frame.bottom, paint);
+            canvas.drawRect(frame.right - CORNER_WIDTH, frame.bottom - ScreenRate,
+                    frame.right, frame.bottom, paint);
+
+            slideTop += SPEEN_DISTANCE;
+            if(slideTop >= frame.bottom){
+                slideTop = frame.top;
+            }
+            Paint linePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            linePaint.setColor(getResources().getColor(R.color.colorAccent));
+            canvas.drawRect(frame.left + MIDDLE_LINE_PADDING, slideTop - MIDDLE_LINE_WIDTH/2, frame.right - MIDDLE_LINE_PADDING,slideTop + MIDDLE_LINE_WIDTH/2, linePaint);
+
+            Collection<ResultPoint> currentPossible = possibleResultPoints;
+            Collection<ResultPoint> currentLast = lastPossibleResultPoints;
+            if (currentPossible.isEmpty()) {
+                lastPossibleResultPoints = null;
+            } else {
+                possibleResultPoints = new HashSet<ResultPoint>(5);
+                lastPossibleResultPoints = currentPossible;
+                paint.setAlpha(OPAQUE);
+                paint.setColor(resultPointColor);
+                for (ResultPoint point : currentPossible) {
+                    canvas.drawCircle(frame.left + point.getX(), frame.top
+                            + point.getY(), 6.0f, paint);
+                }
+            }
+            if (currentLast != null) {
+                paint.setAlpha(OPAQUE / 2);
+                paint.setColor(resultPointColor);
+                for (ResultPoint point : currentLast) {
+                    canvas.drawCircle(frame.left + point.getX(), frame.top
+                            + point.getY(), 3.0f, paint);
+                }
+            }
+
+            postInvalidateDelayed(ANIMATION_DELAY, frame.left, frame.top,
+                    frame.right, frame.bottom);
+        }
+    }
+
+    public void drawViewfinder() {
+        resultBitmap = null;
+        invalidate();
+    }
+
+    /**
+     * Draw a bitmap with the result points highlighted instead of the live scanning display.
+     *
+     * @param barcode An image of the decoded barcode.
+     */
+    public void drawResultBitmap(Bitmap barcode) {
+        resultBitmap = barcode;
+        invalidate();
+    }
+
+    public void addPossibleResultPoint(ResultPoint point) {
+        possibleResultPoints.add(point);
+    }
+}
diff --git a/src/com/android/contacts/util/barcode/camera/AutoFocusManager.java b/src/com/android/contacts/util/barcode/camera/AutoFocusManager.java
new file mode 100644
index 0000000..594cf43
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/camera/AutoFocusManager.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2012 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.hardware.Camera;
+import android.os.AsyncTask;
+import android.preference.PreferenceManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.concurrent.RejectedExecutionException;
+
+
+final class AutoFocusManager implements Camera.AutoFocusCallback {
+
+    private static final String TAG = AutoFocusManager.class.getSimpleName();
+
+    private static final long AUTO_FOCUS_INTERVAL_MS = 1000L;
+    private static final Collection<String> FOCUS_MODES_CALLING_AF;
+
+    static {
+        FOCUS_MODES_CALLING_AF = new ArrayList<>(2);
+        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_AUTO);
+        FOCUS_MODES_CALLING_AF.add(Camera.Parameters.FOCUS_MODE_MACRO);
+    }
+
+    private boolean stopped;
+    private boolean focusing;
+    private final boolean useAutoFocus;
+    private final Camera camera;
+    private AsyncTask<?, ?, ?> outstandingTask;
+
+    AutoFocusManager(Context context, Camera camera) {
+        this.camera = camera;
+        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(context);
+        String currentFocusMode = camera.getParameters().getFocusMode();
+        useAutoFocus = FOCUS_MODES_CALLING_AF.contains(currentFocusMode);
+        Log.i(TAG, "Current focus mode '" + currentFocusMode + "'; use auto focus? " + useAutoFocus);
+        start();
+    }
+
+    @Override
+    public synchronized void onAutoFocus(boolean success, Camera theCamera) {
+        focusing = false;
+        autoFocusAgainLater();
+    }
+
+    private synchronized void autoFocusAgainLater() {
+        if (!stopped && outstandingTask == null) {
+            AutoFocusTask newTask = new AutoFocusTask();
+            try {
+                newTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+                outstandingTask = newTask;
+            } catch (RejectedExecutionException ree) {
+                Log.w(TAG, "Could not request auto focus", ree);
+            }
+        }
+    }
+
+    synchronized void start() {
+        if (useAutoFocus) {
+            outstandingTask = null;
+            if (!stopped && !focusing) {
+                try {
+                    camera.autoFocus(this);
+                    focusing = true;
+                } catch (RuntimeException re) {
+                    // Have heard RuntimeException reported in Android 4.0.x+; continue?
+                    Log.w(TAG, "Unexpected exception while focusing", re);
+                    // Try again later to keep cycle going
+                    autoFocusAgainLater();
+                }
+            }
+        }
+    }
+
+    private synchronized void cancelOutstandingTask() {
+        if (outstandingTask != null) {
+            if (outstandingTask.getStatus() != AsyncTask.Status.FINISHED) {
+                outstandingTask.cancel(true);
+            }
+            outstandingTask = null;
+        }
+    }
+
+    synchronized void stop() {
+        stopped = true;
+        if (useAutoFocus) {
+            cancelOutstandingTask();
+            // Doesn't hurt to call this even if not focusing
+            try {
+                camera.cancelAutoFocus();
+            } catch (RuntimeException re) {
+                // Have heard RuntimeException reported in Android 4.0.x+; continue?
+                Log.w(TAG, "Unexpected exception while cancelling focusing", re);
+            }
+        }
+    }
+
+    private final class AutoFocusTask extends AsyncTask<Object, Object, Object> {
+        @Override
+        protected Object doInBackground(Object... voids) {
+            try {
+                Thread.sleep(AUTO_FOCUS_INTERVAL_MS);
+            } catch (InterruptedException e) {
+                // continue
+            }
+            start();
+            return null;
+        }
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/CameraConfigurationManager.java b/src/com/android/contacts/util/barcode/camera/CameraConfigurationManager.java
new file mode 100644
index 0000000..8f0a8ec
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/camera/CameraConfigurationManager.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.hardware.Camera;
+import android.util.Log;
+import android.view.Display;
+import android.view.Surface;
+import android.view.WindowManager;
+
+import com.android.contacts.util.barcode.camera.open.CameraFacing;
+import com.android.contacts.util.barcode.camera.open.OpenCamera;
+
+
+/**
+ * A class which deals with reading, parsing, and setting the camera parameters which are used to
+ * configure the camera hardware.
+ */
+final class CameraConfigurationManager {
+
+    private static final String TAG = "CameraConfiguration";
+
+    private final Context context;
+    private int cwNeededRotation;
+    private int cwRotationFromDisplayToCamera;
+    private Point screenResolution;
+    private Point cameraResolution;
+    private Point bestPreviewSize;
+    private Point previewSizeOnScreen;
+
+    CameraConfigurationManager(Context context) {
+        this.context = context;
+    }
+
+    /**
+     * Reads, one time, values from the camera that are needed by the app.
+     */
+    void initFromCameraParameters(OpenCamera camera) {
+        Camera.Parameters parameters = camera.getCamera().getParameters();
+        WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = manager.getDefaultDisplay();
+
+        // 判断屏幕方向，是否有需要从自然角度旋转到显示器角度
+        int displayRotation = display.getRotation();
+        int cwRotationFromNaturalToDisplay;
+        switch (displayRotation) {
+            case Surface.ROTATION_0:
+                cwRotationFromNaturalToDisplay = 0;
+                break;
+            case Surface.ROTATION_90:
+                cwRotationFromNaturalToDisplay = 90;
+                break;
+            case Surface.ROTATION_180:
+                cwRotationFromNaturalToDisplay = 180;
+                break;
+            case Surface.ROTATION_270:
+                cwRotationFromNaturalToDisplay = 270;
+                break;
+            default:
+                // Have seen this return incorrect values like -90
+                if (displayRotation % 90 == 0) {
+                    cwRotationFromNaturalToDisplay = (360 + displayRotation) % 360;
+                } else {
+                    throw new IllegalArgumentException("Bad rotation: " + displayRotation);
+                }
+        }
+        Log.i(TAG, "Display at: " + cwRotationFromNaturalToDisplay);
+
+        // 判断相机的方向，根据前后摄像机判断是否有需要旋转
+        int cwRotationFromNaturalToCamera = camera.getOrientation();
+        Log.i(TAG, "Camera at: " + cwRotationFromNaturalToCamera);
+
+        // Still not 100% sure about this. But acts like we need to flip this:
+        if (camera.getFacing() == CameraFacing.FRONT) {
+            cwRotationFromNaturalToCamera = (360 - cwRotationFromNaturalToCamera) % 360;
+            Log.i(TAG, "Front camera overriden to: " + cwRotationFromNaturalToCamera);
+        }
+
+        // 根据屏幕方向和相机方向判断是否有需要进行旋转
+        cwRotationFromDisplayToCamera =
+                (360 + cwRotationFromNaturalToCamera - cwRotationFromNaturalToDisplay) % 360;
+        Log.i(TAG, "Final display orientation: " + cwRotationFromDisplayToCamera);
+        if (camera.getFacing() == CameraFacing.FRONT) {
+            Log.i(TAG, "Compensating rotation for front camera");
+            cwNeededRotation = (360 - cwRotationFromDisplayToCamera) % 360;
+        } else {
+            cwNeededRotation = cwRotationFromDisplayToCamera;
+        }
+        Log.i(TAG, "Clockwise rotation from display to camera: " + cwNeededRotation);
+
+        Point theScreenResolution = new Point();
+        display.getSize(theScreenResolution);
+        screenResolution = theScreenResolution;
+        Log.i(TAG, "Screen resolution in current orientation: " + screenResolution);
+
+        // 寻找最佳的预览宽高值
+        cameraResolution = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);
+        Log.i(TAG, "Camera resolution: " + cameraResolution);
+        bestPreviewSize = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);
+        Log.i(TAG, "Best available preview size: " + bestPreviewSize);
+
+        boolean isScreenPortrait = screenResolution.x < screenResolution.y;
+        boolean isPreviewSizePortrait = bestPreviewSize.x < bestPreviewSize.y;
+
+        if (isScreenPortrait == isPreviewSizePortrait) {
+            previewSizeOnScreen = bestPreviewSize;
+        } else {
+            previewSizeOnScreen = new Point(bestPreviewSize.y, bestPreviewSize.x);
+        }
+        Log.i(TAG, "Preview size on screen: " + previewSizeOnScreen);
+    }
+
+    void setDesiredCameraParameters(OpenCamera camera, boolean safeMode) {
+
+        Camera theCamera = camera.getCamera();
+        Camera.Parameters parameters = theCamera.getParameters();
+
+        if (parameters == null) {
+            Log.w(TAG, "Device error: no camera parameters are available. Proceeding without configuration.");
+            return;
+        }
+
+        Log.i(TAG, "Initial camera parameters: " + parameters.flatten());
+
+        if (safeMode) {
+            Log.w(TAG, "In camera config safe mode -- most settings will not be honored");
+        }
+
+        initializeTorch(parameters);
+
+        // 设置对焦功能
+        CameraConfigurationUtils.setFocus(parameters, true, true, safeMode);
+
+        if (!safeMode) {
+            // 不需要进行条形码场景匹配
+            CameraConfigurationUtils.setBarcodeSceneMode(parameters);
+
+            // 不使用距离测量
+            CameraConfigurationUtils.setVideoStabilization(parameters);
+            CameraConfigurationUtils.setFocusArea(parameters);
+            CameraConfigurationUtils.setMetering(parameters);
+        }
+
+        //parameters.setPreviewSize(bestPreviewSize.x, bestPreviewSize.y);
+
+        //theCamera.setParameters(parameters);
+
+        theCamera.setDisplayOrientation(cwRotationFromDisplayToCamera);
+
+        Camera.Parameters afterParameters = theCamera.getParameters();
+        Camera.Size afterSize = afterParameters.getPreviewSize();
+        if (afterSize != null && (bestPreviewSize.x != afterSize.width || bestPreviewSize.y != afterSize.height)) {
+            Log.w(TAG, "Camera said it supported preview size " + bestPreviewSize.x + 'x' + bestPreviewSize.y +
+                    ", but after setting it, preview size is " + afterSize.width + 'x' + afterSize.height);
+            bestPreviewSize.x = afterSize.width;
+            bestPreviewSize.y = afterSize.height;
+        }
+    }
+
+    Point getBestPreviewSize() {
+        return bestPreviewSize;
+    }
+
+    Point getPreviewSizeOnScreen() {
+        return previewSizeOnScreen;
+    }
+
+    Point getCameraResolution() {
+        return cameraResolution;
+    }
+
+    Point getScreenResolution() {
+        return screenResolution;
+    }
+
+    int getCWNeededRotation() {
+        return cwNeededRotation;
+    }
+
+    boolean getTorchState(Camera camera) {
+        if (camera != null) {
+            Camera.Parameters parameters = camera.getParameters();
+            if (parameters != null) {
+                String flashMode = parameters.getFlashMode();
+                return flashMode != null &&
+                        (Camera.Parameters.FLASH_MODE_ON.equals(flashMode) ||
+                                Camera.Parameters.FLASH_MODE_TORCH.equals(flashMode));
+            }
+        }
+        return false;
+    }
+
+    void setTorch(Camera camera, boolean newSetting) {
+        Camera.Parameters parameters = camera.getParameters();
+        doSetTorch(parameters, newSetting);
+        camera.setParameters(parameters);
+    }
+
+    private void initializeTorch(Camera.Parameters parameters) {
+        doSetTorch(parameters, false);
+    }
+
+    private void doSetTorch(Camera.Parameters parameters, boolean newSetting) {
+        CameraConfigurationUtils.setTorch(parameters, newSetting);
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/CameraConfigurationUtils.java b/src/com/android/contacts/util/barcode/camera/CameraConfigurationUtils.java
new file mode 100644
index 0000000..c7f6132
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/camera/CameraConfigurationUtils.java
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2014 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera;
+
+import android.annotation.TargetApi;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.hardware.Camera;
+import android.os.Build;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.regex.Pattern;
+
+/**
+ * Utility methods for configuring the Android camera.
+ *
+ * @author Sean Owen
+ */
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+public final class CameraConfigurationUtils {
+
+    private static final String TAG = "CameraConfiguration";
+
+    private static final Pattern SEMICOLON = Pattern.compile(";");
+
+    private static final int MIN_PREVIEW_PIXELS = 480 * 320; // normal screen
+    private static final float MAX_EXPOSURE_COMPENSATION = 1.5f;
+    private static final float MIN_EXPOSURE_COMPENSATION = 0.0f;
+    private static final double MAX_ASPECT_DISTORTION = 0.15;
+    private static final int MIN_FPS = 10;
+    private static final int MAX_FPS = 20;
+    private static final int AREA_PER_1000 = 400;
+
+    private CameraConfigurationUtils() {
+    }
+
+    public static void setFocus(Camera.Parameters parameters,
+                                boolean autoFocus,
+                                boolean disableContinuous,
+                                boolean safeMode) {
+        List<String> supportedFocusModes = parameters.getSupportedFocusModes();
+        String focusMode = null;
+        if (autoFocus) {
+            if (safeMode || disableContinuous) {
+                focusMode = findSettableValue("focus mode",
+                        supportedFocusModes,
+                        Camera.Parameters.FOCUS_MODE_AUTO);
+            } else {
+                focusMode = findSettableValue("focus mode",
+                        supportedFocusModes,
+                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,
+                        Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO,
+                        Camera.Parameters.FOCUS_MODE_AUTO);
+            }
+        }
+        // Maybe selected auto-focus but not available, so fall through here:
+        if (!safeMode && focusMode == null) {
+            focusMode = findSettableValue("focus mode",
+                    supportedFocusModes,
+                    Camera.Parameters.FOCUS_MODE_MACRO,
+                    Camera.Parameters.FOCUS_MODE_EDOF);
+        }
+        if (focusMode != null) {
+            if (focusMode.equals(parameters.getFocusMode())) {
+                Log.i(TAG, "Focus mode already set to " + focusMode);
+            } else {
+                parameters.setFocusMode(focusMode);
+            }
+        }
+    }
+
+    public static void setTorch(Camera.Parameters parameters, boolean on) {
+        List<String> supportedFlashModes = parameters.getSupportedFlashModes();
+        String flashMode;
+        if (on) {
+            flashMode = findSettableValue("flash mode",
+                    supportedFlashModes,
+                    Camera.Parameters.FLASH_MODE_TORCH,
+                    Camera.Parameters.FLASH_MODE_ON);
+        } else {
+            flashMode = findSettableValue("flash mode",
+                    supportedFlashModes,
+                    Camera.Parameters.FLASH_MODE_OFF);
+        }
+        if (flashMode != null) {
+            if (flashMode.equals(parameters.getFlashMode())) {
+                Log.i(TAG, "Flash mode already set to " + flashMode);
+            } else {
+                Log.i(TAG, "Setting flash mode to " + flashMode);
+                parameters.setFlashMode(flashMode);
+            }
+        }
+    }
+
+    public static void setBestExposure(Camera.Parameters parameters, boolean lightOn) {
+        int minExposure = parameters.getMinExposureCompensation();
+        int maxExposure = parameters.getMaxExposureCompensation();
+        float step = parameters.getExposureCompensationStep();
+        if ((minExposure != 0 || maxExposure != 0) && step > 0.0f) {
+            // Set low when light is on
+            float targetCompensation = lightOn ? MIN_EXPOSURE_COMPENSATION : MAX_EXPOSURE_COMPENSATION;
+            int compensationSteps = Math.round(targetCompensation / step);
+            float actualCompensation = step * compensationSteps;
+            // Clamp value:
+            compensationSteps = Math.max(Math.min(compensationSteps, maxExposure), minExposure);
+            if (parameters.getExposureCompensation() == compensationSteps) {
+                Log.i(TAG, "Exposure compensation already set to " + compensationSteps + " / " + actualCompensation);
+            } else {
+                Log.i(TAG, "Setting exposure compensation to " + compensationSteps + " / " + actualCompensation);
+                parameters.setExposureCompensation(compensationSteps);
+            }
+        } else {
+            Log.i(TAG, "Camera does not support exposure compensation");
+        }
+    }
+
+    public static void setBestPreviewFPS(Camera.Parameters parameters) {
+        setBestPreviewFPS(parameters, MIN_FPS, MAX_FPS);
+    }
+
+    public static void setBestPreviewFPS(Camera.Parameters parameters, int minFPS, int maxFPS) {
+        List<int[]> supportedPreviewFpsRanges = parameters.getSupportedPreviewFpsRange();
+        Log.i(TAG, "Supported FPS ranges: " + toString(supportedPreviewFpsRanges));
+        if (supportedPreviewFpsRanges != null && !supportedPreviewFpsRanges.isEmpty()) {
+            int[] suitableFPSRange = null;
+            for (int[] fpsRange : supportedPreviewFpsRanges) {
+                int thisMin = fpsRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX];
+                int thisMax = fpsRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX];
+                if (thisMin >= minFPS * 1000 && thisMax <= maxFPS * 1000) {
+                    suitableFPSRange = fpsRange;
+                    break;
+                }
+            }
+            if (suitableFPSRange == null) {
+                Log.i(TAG, "No suitable FPS range?");
+            } else {
+                int[] currentFpsRange = new int[2];
+                parameters.getPreviewFpsRange(currentFpsRange);
+                if (Arrays.equals(currentFpsRange, suitableFPSRange)) {
+                    Log.i(TAG, "FPS range already set to " + Arrays.toString(suitableFPSRange));
+                } else {
+                    Log.i(TAG, "Setting FPS range to " + Arrays.toString(suitableFPSRange));
+                    parameters.setPreviewFpsRange(suitableFPSRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX],
+                            suitableFPSRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]);
+                }
+            }
+        }
+    }
+
+    public static void setFocusArea(Camera.Parameters parameters) {
+        if (parameters.getMaxNumFocusAreas() > 0) {
+            Log.i(TAG, "Old focus areas: " + toString(parameters.getFocusAreas()));
+            List<Camera.Area> middleArea = buildMiddleArea(AREA_PER_1000);
+            Log.i(TAG, "Setting focus area to : " + toString(middleArea));
+            parameters.setFocusAreas(middleArea);
+        } else {
+            Log.i(TAG, "Device does not support focus areas");
+        }
+    }
+
+    public static void setMetering(Camera.Parameters parameters) {
+        if (parameters.getMaxNumMeteringAreas() > 0) {
+            Log.i(TAG, "Old metering areas: " + parameters.getMeteringAreas());
+            List<Camera.Area> middleArea = buildMiddleArea(AREA_PER_1000);
+            Log.i(TAG, "Setting metering area to : " + toString(middleArea));
+            parameters.setMeteringAreas(middleArea);
+        } else {
+            Log.i(TAG, "Device does not support metering areas");
+        }
+    }
+
+    private static List<Camera.Area> buildMiddleArea(int areaPer1000) {
+        return Collections.singletonList(
+                new Camera.Area(new Rect(-areaPer1000, -areaPer1000, areaPer1000, areaPer1000), 1));
+    }
+
+    public static void setVideoStabilization(Camera.Parameters parameters) {
+        if (parameters.isVideoStabilizationSupported()) {
+            if (parameters.getVideoStabilization()) {
+                Log.i(TAG, "Video stabilization already enabled");
+            } else {
+                Log.i(TAG, "Enabling video stabilization...");
+                parameters.setVideoStabilization(true);
+            }
+        } else {
+            Log.i(TAG, "This device does not support video stabilization");
+        }
+    }
+
+    public static void setBarcodeSceneMode(Camera.Parameters parameters) {
+        if (Camera.Parameters.SCENE_MODE_BARCODE.equals(parameters.getSceneMode())) {
+            Log.i(TAG, "Barcode scene mode already set");
+            return;
+        }
+        String sceneMode = findSettableValue("scene mode",
+                parameters.getSupportedSceneModes(),
+                Camera.Parameters.SCENE_MODE_BARCODE);
+        if (sceneMode != null) {
+            parameters.setSceneMode(sceneMode);
+        }
+    }
+
+    public static void setZoom(Camera.Parameters parameters, double targetZoomRatio) {
+        if (parameters.isZoomSupported()) {
+            Integer zoom = indexOfClosestZoom(parameters, targetZoomRatio);
+            if (zoom == null) {
+                return;
+            }
+            if (parameters.getZoom() == zoom) {
+                Log.i(TAG, "Zoom is already set to " + zoom);
+            } else {
+                Log.i(TAG, "Setting zoom to " + zoom);
+                parameters.setZoom(zoom);
+            }
+        } else {
+            Log.i(TAG, "Zoom is not supported");
+        }
+    }
+
+    private static Integer indexOfClosestZoom(Camera.Parameters parameters, double targetZoomRatio) {
+        List<Integer> ratios = parameters.getZoomRatios();
+        Log.i(TAG, "Zoom ratios: " + ratios);
+        int maxZoom = parameters.getMaxZoom();
+        if (ratios == null || ratios.isEmpty() || ratios.size() != maxZoom + 1) {
+            Log.w(TAG, "Invalid zoom ratios!");
+            return null;
+        }
+        double target100 = 100.0 * targetZoomRatio;
+        double smallestDiff = Double.POSITIVE_INFINITY;
+        int closestIndex = 0;
+        for (int i = 0; i < ratios.size(); i++) {
+            double diff = Math.abs(ratios.get(i) - target100);
+            if (diff < smallestDiff) {
+                smallestDiff = diff;
+                closestIndex = i;
+            }
+        }
+        Log.i(TAG, "Chose zoom ratio of " + (ratios.get(closestIndex) / 100.0));
+        return closestIndex;
+    }
+
+    public static void setInvertColor(Camera.Parameters parameters) {
+        if (Camera.Parameters.EFFECT_NEGATIVE.equals(parameters.getColorEffect())) {
+            Log.i(TAG, "Negative effect already set");
+            return;
+        }
+        String colorMode = findSettableValue("color effect",
+                parameters.getSupportedColorEffects(),
+                Camera.Parameters.EFFECT_NEGATIVE);
+        if (colorMode != null) {
+            parameters.setColorEffect(colorMode);
+        }
+    }
+
+    public static Point findBestPreviewSizeValue(Camera.Parameters parameters, Point screenResolution) {
+
+        // 获取当前手机支持的屏幕预览尺寸
+        List<Camera.Size> rawSupportedSizes = parameters.getSupportedPreviewSizes();
+        if (rawSupportedSizes == null) {
+            Log.w(TAG, "Device returned no supported preview sizes; using default");
+            Camera.Size defaultSize = parameters.getPreviewSize();
+            if (defaultSize == null) {
+                throw new IllegalStateException("Parameters contained no preview size!");
+            }
+            return new Point(defaultSize.width, defaultSize.height);
+        }
+
+        // Sort by size, descending
+        // 对这些尺寸根据像素值（即宽乘高的值）进行从小到大排序
+        List<Camera.Size> supportedPreviewSizes = new ArrayList<>(rawSupportedSizes);
+        Collections.sort(supportedPreviewSizes, new Comparator<Camera.Size>() {
+            @Override
+            public int compare(Camera.Size a, Camera.Size b) {
+                int aPixels = a.height * a.width;
+                int bPixels = b.height * b.width;
+                if (bPixels < aPixels) {
+                    return -1;
+                }
+                if (bPixels > aPixels) {
+                    return 1;
+                }
+                return 0;
+            }
+        });
+
+        if (Log.isLoggable(TAG, Log.INFO)) {
+            StringBuilder previewSizesString = new StringBuilder();
+            for (Camera.Size supportedPreviewSize : supportedPreviewSizes) {
+                previewSizesString.append(supportedPreviewSize.width).append('x')
+                        .append(supportedPreviewSize.height).append(' ');
+            }
+            Log.i(TAG, "Supported preview sizes: " + previewSizesString);
+        }
+
+        double screenAspectRatio = screenResolution.x / (double) screenResolution.y;
+
+        // Remove sizes that are unsuitable
+        Iterator<Camera.Size> it = supportedPreviewSizes.iterator();
+        while (it.hasNext()) {
+            Camera.Size supportedPreviewSize = it.next();
+            int realWidth = supportedPreviewSize.width;
+            int realHeight = supportedPreviewSize.height;
+
+            // 首先把不符合最小预览像素值的尺寸排除
+            if (realWidth * realHeight < MIN_PREVIEW_PIXELS) {
+                it.remove();
+                continue;
+            }
+
+            boolean isCandidatePortrait = realWidth < realHeight;
+            int maybeFlippedWidth = isCandidatePortrait ? realHeight : realWidth;
+            int maybeFlippedHeight = isCandidatePortrait ? realWidth : realHeight;
+            double aspectRatio = maybeFlippedWidth / (double) maybeFlippedHeight;
+            double distortion = Math.abs(aspectRatio - screenAspectRatio);
+
+            // 根据宽高比判断是否满足最大误差要求（默认最大值为0.15，即宽高比默认不能超过给定比例的15%）
+            if (distortion > MAX_ASPECT_DISTORTION) {
+                it.remove();
+                continue;
+            }
+
+            if (maybeFlippedWidth == screenResolution.x && maybeFlippedHeight == screenResolution.y) {
+                Point exactPoint = new Point(realWidth, realHeight);
+                Log.i(TAG, "Found preview size exactly matching screen size: " + exactPoint);
+                return exactPoint;
+            }
+        }
+
+        // If no exact match, use largest preview size. This was not a great idea on older devices because
+        // of the additional computation needed. We're likely to get here on newer Android 4+ devices, where
+        // the CPU is much more powerful.
+        // 如果没有精确匹配到合适的尺寸，则使用最大的尺寸，这样设置便是预览图像可能产生拉伸的根本原因
+        if (!supportedPreviewSizes.isEmpty()) {
+            Camera.Size largestPreview = supportedPreviewSizes.get(0);
+            Point largestSize = new Point(largestPreview.width, largestPreview.height);
+            Log.i(TAG, "Using largest suitable preview size: " + largestSize);
+            return largestSize;
+        }
+
+        // If there is nothing at all suitable, return current preview size
+        // 如果没有找到合适的尺寸，就返回默认设定的尺寸
+        Camera.Size defaultPreview = parameters.getPreviewSize();
+        if (defaultPreview == null) {
+            throw new IllegalStateException("Parameters contained no preview size!");
+        }
+        Point defaultSize = new Point(defaultPreview.width, defaultPreview.height);
+        Log.i(TAG, "No suitable preview sizes, using default: " + defaultSize);
+        return defaultSize;
+    }
+
+    private static String findSettableValue(String name,
+                                            Collection<String> supportedValues,
+                                            String... desiredValues) {
+        Log.i(TAG, "Requesting " + name + " value from among: " + Arrays.toString(desiredValues));
+        Log.i(TAG, "Supported " + name + " values: " + supportedValues);
+        if (supportedValues != null) {
+            for (String desiredValue : desiredValues) {
+                if (supportedValues.contains(desiredValue)) {
+                    Log.i(TAG, "Can set " + name + " to: " + desiredValue);
+                    return desiredValue;
+                }
+            }
+        }
+        Log.i(TAG, "No supported values match");
+        return null;
+    }
+
+    private static String toString(Collection<int[]> arrays) {
+        if (arrays == null || arrays.isEmpty()) {
+            return "[]";
+        }
+        StringBuilder buffer = new StringBuilder();
+        buffer.append('[');
+        Iterator<int[]> it = arrays.iterator();
+        while (it.hasNext()) {
+            buffer.append(Arrays.toString(it.next()));
+            if (it.hasNext()) {
+                buffer.append(", ");
+            }
+        }
+        buffer.append(']');
+        return buffer.toString();
+    }
+
+    private static String toString(Iterable<Camera.Area> areas) {
+        if (areas == null) {
+            return null;
+        }
+        StringBuilder result = new StringBuilder();
+        for (Camera.Area area : areas) {
+            result.append(area.rect).append(':').append(area.weight).append(' ');
+        }
+        return result.toString();
+    }
+
+    public static String collectStats(Camera.Parameters parameters) {
+        return collectStats(parameters.flatten());
+    }
+
+    public static String collectStats(CharSequence flattenedParams) {
+        StringBuilder result = new StringBuilder(1000);
+
+        result.append("BOARD=").append(Build.BOARD).append('\n');
+        result.append("BRAND=").append(Build.BRAND).append('\n');
+        result.append("CPU_ABI=").append(Build.CPU_ABI).append('\n');
+        result.append("DEVICE=").append(Build.DEVICE).append('\n');
+        result.append("DISPLAY=").append(Build.DISPLAY).append('\n');
+        result.append("FINGERPRINT=").append(Build.FINGERPRINT).append('\n');
+        result.append("HOST=").append(Build.HOST).append('\n');
+        result.append("ID=").append(Build.ID).append('\n');
+        result.append("MANUFACTURER=").append(Build.MANUFACTURER).append('\n');
+        result.append("MODEL=").append(Build.MODEL).append('\n');
+        result.append("PRODUCT=").append(Build.PRODUCT).append('\n');
+        result.append("TAGS=").append(Build.TAGS).append('\n');
+        result.append("TIME=").append(Build.TIME).append('\n');
+        result.append("TYPE=").append(Build.TYPE).append('\n');
+        result.append("USER=").append(Build.USER).append('\n');
+        result.append("VERSION.CODENAME=").append(Build.VERSION.CODENAME).append('\n');
+        result.append("VERSION.INCREMENTAL=").append(Build.VERSION.INCREMENTAL).append('\n');
+        result.append("VERSION.RELEASE=").append(Build.VERSION.RELEASE).append('\n');
+        result.append("VERSION.SDK_INT=").append(Build.VERSION.SDK_INT).append('\n');
+
+        if (flattenedParams != null) {
+            String[] params = SEMICOLON.split(flattenedParams);
+            Arrays.sort(params);
+            for (String param : params) {
+                result.append(param).append('\n');
+            }
+        }
+
+        return result.toString();
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/CameraManager.java b/src/com/android/contacts/util/barcode/camera/CameraManager.java
new file mode 100644
index 0000000..669165d
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/camera/CameraManager.java
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.hardware.Camera;
+import android.os.Handler;
+import android.util.Log;
+import android.view.SurfaceHolder;
+
+import com.android.contacts.util.barcode.camera.open.OpenCamera;
+import com.android.contacts.util.barcode.camera.open.OpenCameraInterface;
+import com.google.zxing.PlanarYUVLuminanceSource;
+
+import java.io.IOException;
+
+
+/**
+ * This object wraps the Camera service object and expects to be the only one talking to it. The
+ * implementation encapsulates the steps needed to take preview-sized images, which are used for
+ * both preview and decoding.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class CameraManager {
+
+    private static final String TAG = CameraManager.class.getSimpleName();
+
+    private static final int MIN_FRAME_WIDTH = 240;
+    public static final int MIN_FRAME_HEIGHT = 240;
+    private static final int MAX_FRAME_WIDTH = 1200; // = 5/8 * 1920
+    public static final int MAX_FRAME_HEIGHT = 675; // = 5/8 * 1080
+
+    private final Context context;
+    private final CameraConfigurationManager configManager;
+    private OpenCamera camera;
+    private AutoFocusManager autoFocusManager;
+    private Rect framingRect;
+    private Rect framingRectInPreview;
+    private boolean initialized;
+    private boolean previewing;
+    private int requestedCameraId = OpenCameraInterface.NO_REQUESTED_CAMERA;
+    private int requestedFramingRectWidth;
+    private int requestedFramingRectHeight;
+    /**
+     * Preview frames are delivered here, which we pass on to the registered handler. Make sure to
+     * clear the handler so it will only receive one message.
+     */
+    private final PreviewCallback previewCallback;
+
+    public CameraManager(Context context) {
+        this.context = context;
+        this.configManager = new CameraConfigurationManager(context);
+        previewCallback = new PreviewCallback(configManager);
+    }
+
+    /**
+     * Opens the camera driver and initializes the hardware parameters.
+     *
+     * @param holder The surface object which the camera will draw preview frames into.
+     * @throws IOException Indicates the camera driver failed to open.
+     */
+    public synchronized void openDriver(SurfaceHolder holder) throws IOException {
+        OpenCamera theCamera = camera;
+        if (theCamera == null) {
+            theCamera = OpenCameraInterface.open(requestedCameraId);
+            if (theCamera == null) {
+                throw new IOException("Camera.open() failed to return object from driver");
+            }
+            camera = theCamera;
+        }
+
+        if (!initialized) {
+            initialized = true;
+            configManager.initFromCameraParameters(theCamera);
+            if (requestedFramingRectWidth > 0 && requestedFramingRectHeight > 0) {
+                setManualFramingRect(requestedFramingRectWidth, requestedFramingRectHeight);
+                requestedFramingRectWidth = 0;
+                requestedFramingRectHeight = 0;
+            }
+        }
+
+        Camera cameraObject = theCamera.getCamera();
+        Camera.Parameters parameters = cameraObject.getParameters();
+        String parametersFlattened = parameters == null ? null : parameters.flatten(); // Save these, temporarily
+        try {
+            configManager.setDesiredCameraParameters(theCamera, false);
+        } catch (RuntimeException re) {
+            // Driver failed
+            Log.w(TAG, "Camera rejected parameters. Setting only minimal safe-mode parameters");
+            Log.i(TAG, "Resetting to saved camera params: " + parametersFlattened);
+            // Reset:
+            if (parametersFlattened != null) {
+                parameters = cameraObject.getParameters();
+                parameters.unflatten(parametersFlattened);
+                try {
+                    cameraObject.setParameters(parameters);
+                    configManager.setDesiredCameraParameters(theCamera, true);
+                } catch (RuntimeException re2) {
+                    // Well, darn. Give up
+                    Log.w(TAG, "Camera rejected even safe-mode parameters! No configuration");
+                }
+            }
+        }
+        cameraObject.setPreviewDisplay(holder);
+
+    }
+
+    public synchronized boolean isOpen() {
+        return camera != null;
+    }
+
+    /**
+     * Closes the camera driver if still in use.
+     */
+    public synchronized void closeDriver() {
+        if (camera != null) {
+            camera.getCamera().release();
+            camera = null;
+            // Make sure to clear these each time we close the camera, so that any scanning rect
+            // requested by intent is forgotten.
+            framingRect = null;
+            framingRectInPreview = null;
+        }
+    }
+
+    /**
+     * Asks the camera hardware to begin drawing preview frames to the screen.
+     */
+    public synchronized void startPreview() {
+        OpenCamera theCamera = camera;
+        if (theCamera != null && !previewing) {
+            theCamera.getCamera().startPreview();
+            previewing = true;
+            autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());
+        }
+    }
+
+    /**
+     * Tells the camera to stop drawing preview frames.
+     */
+    public synchronized void stopPreview() {
+        if (autoFocusManager != null) {
+            autoFocusManager.stop();
+            autoFocusManager = null;
+        }
+        if (camera != null && previewing) {
+            camera.getCamera().stopPreview();
+            previewCallback.setHandler(null, 0);
+            previewing = false;
+        }
+    }
+
+    /**
+     * Convenience method for CaptureActivity
+     *
+     * @param newSetting if {@code true}, light should be turned on if currently off. And vice versa.
+     */
+    public synchronized void setTorch(boolean newSetting) {
+        OpenCamera theCamera = camera;
+        if (theCamera != null) {
+            if (newSetting != configManager.getTorchState(theCamera.getCamera())) {
+                boolean wasAutoFocusManager = autoFocusManager != null;
+                if (wasAutoFocusManager) {
+                    autoFocusManager.stop();
+                    autoFocusManager = null;
+                }
+                configManager.setTorch(theCamera.getCamera(), newSetting);
+                if (wasAutoFocusManager) {
+                    autoFocusManager = new AutoFocusManager(context, theCamera.getCamera());
+                    autoFocusManager.start();
+                }
+            }
+        }
+    }
+
+    public synchronized boolean getTorch() {
+        OpenCamera theCamera = camera;
+        return theCamera != null && configManager.getTorchState(theCamera.getCamera());
+    }
+
+    /**
+     * A single preview frame will be returned to the handler supplied. The data will arrive as byte[]
+     * in the message.obj field, with width and height encoded as message.arg1 and message.arg2,
+     * respectively.
+     *
+     * @param handler The handler to send the message to.
+     * @param message The what field of the message to be sent.
+     */
+    public synchronized void requestPreviewFrame(Handler handler, int message) {
+        OpenCamera theCamera = camera;
+        if (theCamera != null && previewing) {
+            previewCallback.setHandler(handler, message);
+            theCamera.getCamera().setOneShotPreviewCallback(previewCallback);
+        }
+    }
+
+    /**
+     * Calculates the framing rect which the UI should draw to show the user where to place the
+     * barcode. This target helps with alignment as well as forces the user to hold the device
+     * far enough away to ensure the image will be in focus.
+     *
+     * @return The rectangle to draw on screen in window coordinates.
+     */
+    public synchronized Rect getFramingRect() {
+        if (framingRect == null) {
+            if (camera == null) {
+                return null;
+            }
+
+            // 获取屏幕的尺寸像素
+            Point screenResolution = configManager.getScreenResolution();
+            if (screenResolution == null) {
+                // Called early, before init even finished
+                return null;
+            }
+
+            int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);
+            //int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
+            int height = width;
+            int leftOffset = (screenResolution.x - width) / 2;
+            int topOffset = (screenResolution.y - height) / 3;
+            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);
+            Log.d(TAG, "Calculated framing rect: " + framingRect);
+        }
+        return framingRect;
+    }
+
+    public static int findDesiredDimensionInRange(int resolution, int hardMin, int hardMax) {
+        int dim = 5 * resolution / 8; // Target 5/8 of each dimension
+        if (dim < hardMin) {
+            return hardMin;
+        }
+        if (dim > hardMax) {
+            return hardMax;
+        }
+        return dim;
+    }
+
+    /**
+     * Like {@link #getFramingRect} but coordinates are in terms of the preview frame,
+     * not UI / screen.
+     *
+     * @return {@link Rect} expressing barcode scan area in terms of the preview size
+     */
+    public synchronized Rect getFramingRectInPreview() {
+        if (framingRectInPreview == null) {
+            Rect framingRect = getFramingRect();
+            if (framingRect == null) {
+                return null;
+            }
+
+            // 获取相机分辨率和屏幕分辨率
+            Rect rect = new Rect(framingRect);
+            Point cameraResolution = configManager.getCameraResolution();
+            Point screenResolution = configManager.getScreenResolution();
+            if (cameraResolution == null || screenResolution == null) {
+                // Called early, before init even finished
+                return null;
+            }
+
+            // 根据相机分辨率和屏幕分辨率的比例对屏幕中央聚焦框进行调整
+            rect.left = rect.left * cameraResolution.x / screenResolution.x;
+            rect.right = rect.right * cameraResolution.x / screenResolution.x;
+            rect.top = rect.top * cameraResolution.y / screenResolution.y;
+            rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;
+            framingRectInPreview = rect;
+        }
+        return framingRectInPreview;
+    }
+
+
+    /**
+     * Allows third party apps to specify the camera ID, rather than determine
+     * it automatically based on available cameras and their orientation.
+     *
+     * @param cameraId camera ID of the camera to use. A negative value means "no preference".
+     */
+    public synchronized void setManualCameraId(int cameraId) {
+        requestedCameraId = cameraId;
+    }
+
+    /**
+     * Allows third party apps to specify the scanning rectangle dimensions, rather than determine
+     * them automatically based on screen resolution.
+     *
+     * @param width  The width in pixels to scan.
+     * @param height The height in pixels to scan.
+     */
+    public synchronized void setManualFramingRect(int width, int height) {
+        if (initialized) {
+            Point screenResolution = configManager.getScreenResolution();
+            if (width > screenResolution.x) {
+                width = screenResolution.x;
+            }
+            if (height > screenResolution.y) {
+                height = screenResolution.y;
+            }
+            int leftOffset = (screenResolution.x - width) / 2;
+            int topOffset = (screenResolution.y - height) / 2;
+            framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);
+            Log.d(TAG, "Calculated manual framing rect: " + framingRect);
+            framingRectInPreview = null;
+        } else {
+            requestedFramingRectWidth = width;
+            requestedFramingRectHeight = height;
+        }
+    }
+
+    /**
+     * A factory method to build the appropriate LuminanceSource object based on the format
+     * of the preview buffers, as described by Camera.Parameters.
+     *
+     * @param data   A preview frame.
+     * @param width  The width of the image.
+     * @param height The height of the image.
+     * @return A PlanarYUVLuminanceSource instance.
+     */
+    public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int height) {
+        // 取得预览框内的矩形
+//        Rect rect = getFramingRectInPreview();
+//        if (rect == null) {
+//            return null;
+//        }
+//
+//        // Go ahead and assume it's YUV rather than die.
+//        return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top,
+//                rect.width(), rect.height(), false);
+
+        // 直接返回整幅图像的数据，而不计算聚焦框大小。
+        return new PlanarYUVLuminanceSource(data, width, height, 0, 0, width, height, false);
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/PreviewCallback.java b/src/com/android/contacts/util/barcode/camera/PreviewCallback.java
new file mode 100644
index 0000000..2c33d5b
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/camera/PreviewCallback.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2010 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera;
+
+import android.graphics.Point;
+import android.hardware.Camera;
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+
+final class PreviewCallback implements Camera.PreviewCallback {
+
+    private static final String TAG = PreviewCallback.class.getSimpleName();
+
+    private final CameraConfigurationManager configManager;
+    private Handler previewHandler;
+    private int previewMessage;
+
+    PreviewCallback(CameraConfigurationManager configManager) {
+        this.configManager = configManager;
+    }
+
+    void setHandler(Handler previewHandler, int previewMessage) {
+        this.previewHandler = previewHandler;
+        this.previewMessage = previewMessage;
+    }
+
+    @Override
+    public void onPreviewFrame(byte[] data, Camera camera) {
+        Point cameraResolution = configManager.getCameraResolution();
+        Handler thePreviewHandler = previewHandler;
+        if (cameraResolution != null && thePreviewHandler != null) {
+            Message message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.x,
+                    cameraResolution.y, data);
+            message.sendToTarget();
+            previewHandler = null;
+        } else {
+            Log.d(TAG, "Got preview callback, but no handler or resolution available");
+        }
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/open/CameraFacing.java b/src/com/android/contacts/util/barcode/camera/open/CameraFacing.java
new file mode 100644
index 0000000..3c34e75
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/camera/open/CameraFacing.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera.open;
+
+/**
+ * Enumeration of directions a camera may face: front or back.
+ */
+public enum CameraFacing {
+  BACK,  // must be value 0!
+  FRONT, // must be value 1!
+}
diff --git a/src/com/android/contacts/util/barcode/camera/open/OpenCamera.java b/src/com/android/contacts/util/barcode/camera/open/OpenCamera.java
new file mode 100644
index 0000000..c61bbef
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/camera/open/OpenCamera.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera.open;
+
+import android.hardware.Camera;
+
+/**
+ * Represents an open Camera and its metadata, like facing direction and orientation.
+ */
+public final class OpenCamera {
+  
+  private final int index;
+  private final Camera camera;
+  private final CameraFacing facing;
+  private final int orientation;
+  
+  public OpenCamera(int index, Camera camera, CameraFacing facing, int orientation) {
+    this.index = index;
+    this.camera = camera;
+    this.facing = facing;
+    this.orientation = orientation;
+  }
+
+  public Camera getCamera() {
+    return camera;
+  }
+
+  public CameraFacing getFacing() {
+    return facing;
+  }
+
+  public int getOrientation() {
+    return orientation;
+  }
+
+  @Override
+  public String toString() {
+    return "Camera #" + index + " : " + facing + ',' + orientation;
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/camera/open/OpenCameraInterface.java b/src/com/android/contacts/util/barcode/camera/open/OpenCameraInterface.java
new file mode 100644
index 0000000..c926747
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/camera/open/OpenCameraInterface.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2012 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.camera.open;
+
+import android.hardware.Camera;
+import android.util.Log;
+
+/**
+ * Abstraction over the Camera API that helps open them and return their metadata.
+ */
+public final class OpenCameraInterface {
+
+  private static final String TAG = OpenCameraInterface.class.getName();
+
+  private OpenCameraInterface() {
+  }
+
+  /** For {@link #open(int)}, means no preference for which camera to open. */
+  public static final int NO_REQUESTED_CAMERA = -1;
+
+  /**
+   * Opens the requested camera with {@link Camera#open(int)}, if one exists.
+   *
+   * @param cameraId camera ID of the camera to use. A negative value
+   *  or {@link #NO_REQUESTED_CAMERA} means "no preference", in which case a rear-facing
+   *  camera is returned if possible or else any camera
+   * @return handle to {@link OpenCamera} that was opened
+   */
+  public static OpenCamera open(int cameraId) {
+
+    int numCameras = Camera.getNumberOfCameras();
+    if (numCameras == 0) {
+      Log.w(TAG, "No cameras!");
+      return null;
+    }
+
+    boolean explicitRequest = cameraId >= 0;
+
+    Camera.CameraInfo selectedCameraInfo = null;
+    int index;
+    if (explicitRequest) {
+      index = cameraId;
+      selectedCameraInfo = new Camera.CameraInfo();
+      Camera.getCameraInfo(index, selectedCameraInfo);
+    } else {
+      index = 0;
+      while (index < numCameras) {
+        Camera.CameraInfo cameraInfo = new Camera.CameraInfo();
+        Camera.getCameraInfo(index, cameraInfo);
+        CameraFacing reportedFacing = CameraFacing.values()[cameraInfo.facing];
+        if (reportedFacing == CameraFacing.BACK) {
+          selectedCameraInfo = cameraInfo;
+          break;
+        }
+        index++;
+      }
+    }
+
+    Camera camera;
+    if (index < numCameras) {
+      Log.i(TAG, "Opening camera #" + index);
+      camera = Camera.open(index);
+    } else {
+      if (explicitRequest) {
+        Log.w(TAG, "Requested camera does not exist: " + cameraId);
+        camera = null;
+      } else {
+        Log.i(TAG, "No camera facing " + CameraFacing.BACK + "; returning camera #0");
+        camera = Camera.open(0);
+        selectedCameraInfo = new Camera.CameraInfo();
+        Camera.getCameraInfo(0, selectedCameraInfo);
+      }
+    }
+
+    if (camera == null) {
+      return null;
+    }
+    return new OpenCamera(index,
+                          camera,
+                          CameraFacing.values()[selectedCameraInfo.facing],
+                          selectedCameraInfo.orientation);
+  }
+
+}
diff --git a/src/com/android/contacts/util/barcode/result/AddressBookResultHandler.java b/src/com/android/contacts/util/barcode/result/AddressBookResultHandler.java
new file mode 100644
index 0000000..90c1588
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/AddressBookResultHandler.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+import android.graphics.Typeface;
+import android.telephony.PhoneNumberUtils;
+import android.text.Spannable;
+import android.text.SpannableString;
+import android.text.style.StyleSpan;
+
+import com.google.zxing.client.result.AddressBookParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+import com.android.contacts.R;
+
+
+/**
+ * Handles address book entries.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class AddressBookResultHandler extends ResultHandler {
+
+  private static final DateFormat[] DATE_FORMATS = {
+    new SimpleDateFormat("yyyyMMdd", Locale.ENGLISH),
+    new SimpleDateFormat("yyyyMMdd'T'HHmmss", Locale.ENGLISH),
+    new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH),
+    new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.ENGLISH),
+  };
+  static {
+    for (DateFormat format : DATE_FORMATS) {
+      format.setLenient(false);
+    }
+  }
+
+  private static final int[] BUTTON_TEXTS = {
+    R.string.button_add_contact,
+    R.string.button_show_map,
+    R.string.button_dial,
+    R.string.button_email,
+  };
+
+  private final boolean[] fields;
+  private int buttonCount;
+
+  // This takes all the work out of figuring out which buttons/actions should be in which
+  // positions, based on which fields are present in this barcode.
+  private int mapIndexToAction(int index) {
+    if (index < buttonCount) {
+      int count = -1;
+      for (int x = 0; x < MAX_BUTTON_COUNT; x++) {
+        if (fields[x]) {
+          count++;
+        }
+        if (count == index) {
+          return x;
+        }
+      }
+    }
+    return -1;
+  }
+
+  public AddressBookResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+    AddressBookParsedResult addressResult = (AddressBookParsedResult) result;
+    String[] addresses = addressResult.getAddresses();
+    String[] phoneNumbers = addressResult.getPhoneNumbers();
+    String[] emails = addressResult.getEmails();
+
+    fields = new boolean[MAX_BUTTON_COUNT];
+    fields[0] = true; // Add contact is always available
+    fields[1] = addresses != null && addresses.length > 0 && addresses[0] != null && !addresses[0].isEmpty();
+    fields[2] = phoneNumbers != null && phoneNumbers.length > 0;
+    fields[3] = emails != null && emails.length > 0;
+
+    buttonCount = 0;
+    for (int x = 0; x < MAX_BUTTON_COUNT; x++) {
+      if (fields[x]) {
+        buttonCount++;
+      }
+    }
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttonCount;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return BUTTON_TEXTS[mapIndexToAction(index)];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    AddressBookParsedResult addressResult = (AddressBookParsedResult) getResult();
+    String[] addresses = addressResult.getAddresses();
+    String address1 = addresses == null || addresses.length < 1 ? null : addresses[0];
+    String[] addressTypes = addressResult.getAddressTypes();
+    String address1Type = addressTypes == null || addressTypes.length < 1 ? null : addressTypes[0];
+    int action = mapIndexToAction(index);
+    switch (action) {
+      case 0:
+        addContact(addressResult.getNames(),
+                   addressResult.getNicknames(),
+                   addressResult.getPronunciation(),
+                   addressResult.getPhoneNumbers(),
+                   addressResult.getPhoneTypes(),
+                   addressResult.getEmails(),
+                   addressResult.getEmailTypes(),
+                   addressResult.getNote(),
+                   addressResult.getInstantMessenger(),
+                   address1,
+                   address1Type,
+                   addressResult.getOrg(),
+                   addressResult.getTitle(),
+                   addressResult.getURLs(),
+                   addressResult.getBirthday(),
+                   addressResult.getGeo());
+        break;
+      case 1:
+        searchMap(address1);
+        break;
+      case 2:
+        dialPhone(addressResult.getPhoneNumbers()[0]);
+        break;
+      case 3:
+        sendEmail(addressResult.getEmails(), null, null, null, null);
+        break;
+      default:
+        break;
+    }
+  }
+
+  private static Date parseDate(String s) {
+    for (DateFormat currentFormat : DATE_FORMATS) {
+      try {
+        return currentFormat.parse(s);
+      } catch (ParseException e) {
+        // continue
+      }
+    }
+    return null;
+  }
+
+  // Overriden so we can hyphenate phone numbers, format birthdays, and bold the name.
+  @Override
+  public CharSequence getDisplayContents() {
+    AddressBookParsedResult result = (AddressBookParsedResult) getResult();
+    StringBuilder contents = new StringBuilder(100);
+    ParsedResult.maybeAppend(result.getNames(), contents);
+    int namesLength = contents.length();
+
+    String pronunciation = result.getPronunciation();
+    if (pronunciation != null && !pronunciation.isEmpty()) {
+      contents.append("\n(");
+      contents.append(pronunciation);
+      contents.append(')');
+    }
+
+    ParsedResult.maybeAppend(result.getTitle(), contents);
+    ParsedResult.maybeAppend(result.getOrg(), contents);
+    ParsedResult.maybeAppend(result.getAddresses(), contents);
+    String[] numbers = result.getPhoneNumbers();
+    if (numbers != null) {
+      for (String number : numbers) {
+        if (number != null) {
+          ParsedResult.maybeAppend(PhoneNumberUtils.formatNumber(number), contents);
+        }
+      }
+    }
+    ParsedResult.maybeAppend(result.getEmails(), contents);
+    ParsedResult.maybeAppend(result.getURLs(), contents);
+
+    String birthday = result.getBirthday();
+    if (birthday != null && !birthday.isEmpty()) {
+      Date date = parseDate(birthday);
+      if (date != null) {
+        ParsedResult.maybeAppend(DateFormat.getDateInstance(DateFormat.MEDIUM).format(date.getTime()), contents);
+      }
+    }
+    ParsedResult.maybeAppend(result.getNote(), contents);
+
+    if (namesLength > 0) {
+      // Bold the full name to make it stand out a bit.
+      Spannable styled = new SpannableString(contents.toString());
+      styled.setSpan(new StyleSpan(Typeface.BOLD), 0, namesLength, 0);
+      return styled;
+    } else {
+      return contents.toString();
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_address_book;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/CalendarResultHandler.java b/src/com/android/contacts/util/barcode/result/CalendarResultHandler.java
new file mode 100644
index 0000000..fd4f49a
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/CalendarResultHandler.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.util.Log;
+
+import com.google.zxing.client.result.CalendarParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import java.text.DateFormat;
+import java.util.Date;
+
+import com.android.contacts.R;
+
+
+/**
+ * Handles calendar entries encoded in QR Codes.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ * @author Sean Owen
+ */
+public final class CalendarResultHandler extends ResultHandler {
+
+  private static final String TAG = CalendarResultHandler.class.getSimpleName();
+
+  private static final int[] buttons = {
+      R.string.button_add_calendar
+  };
+
+  public CalendarResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    if (index == 0) {
+      CalendarParsedResult calendarResult = (CalendarParsedResult) getResult();
+
+      String description = calendarResult.getDescription();
+      String organizer = calendarResult.getOrganizer();
+      if (organizer != null) { // No separate Intent key, put in description
+        if (description == null) {
+          description = organizer;
+        } else {
+          description = description + '\n' + organizer;
+        }
+      }
+
+      addCalendarEvent(calendarResult.getSummary(),
+                       calendarResult.getStart(),
+                       calendarResult.isStartAllDay(),
+                       calendarResult.getEnd(),
+                       calendarResult.getLocation(),
+                       description,
+                       calendarResult.getAttendees());
+    }
+  }
+
+  /**
+   * Sends an intent to create a new calendar event by prepopulating the Add Event UI. Older
+   * versions of the system have a bug where the event title will not be filled out.
+   *
+   * @param summary A description of the event
+   * @param start   The start time
+   * @param allDay  if true, event is considered to be all day starting from start time
+   * @param end     The end time (optional)
+   * @param location a text description of the event location
+   * @param description a text description of the event itself
+   * @param attendees attendees to invite
+   */
+  private void addCalendarEvent(String summary,
+                                Date start,
+                                boolean allDay,
+                                Date end,
+                                String location,
+                                String description,
+                                String[] attendees) {
+    Intent intent = new Intent(Intent.ACTION_INSERT);
+    intent.setType("vnd.android.cursor.item/event");
+    long startMilliseconds = start.getTime();
+    intent.putExtra("beginTime", startMilliseconds);
+    if (allDay) {
+      intent.putExtra("allDay", true);
+    }
+    long endMilliseconds;
+    if (end == null) {
+      if (allDay) {
+        // + 1 day
+        endMilliseconds = startMilliseconds + 24 * 60 * 60 * 1000;
+      } else {
+        endMilliseconds = startMilliseconds;
+      }
+    } else {
+      endMilliseconds = end.getTime();
+    }
+    intent.putExtra("endTime", endMilliseconds);
+    intent.putExtra("title", summary);
+    intent.putExtra("eventLocation", location);
+    intent.putExtra("description", description);
+    if (attendees != null) {
+      intent.putExtra(Intent.EXTRA_EMAIL, attendees);
+      // Documentation says this is either a String[] or comma-separated String, which is right?
+    }
+
+    try {
+      // Do this manually at first
+      rawLaunchIntent(intent);
+    } catch (ActivityNotFoundException anfe) {
+      Log.w(TAG, "No calendar app available that responds to " + Intent.ACTION_INSERT);
+      // For calendar apps that don't like "INSERT":
+      intent.setAction(Intent.ACTION_EDIT);
+      launchIntent(intent); // Fail here for real if nothing can handle it
+    }
+  }
+
+
+  @Override
+  public CharSequence getDisplayContents() {
+
+    CalendarParsedResult calResult = (CalendarParsedResult) getResult();
+    StringBuilder result = new StringBuilder(100);
+
+    ParsedResult.maybeAppend(calResult.getSummary(), result);
+
+    Date start = calResult.getStart();
+    ParsedResult.maybeAppend(format(calResult.isStartAllDay(), start), result);
+
+    Date end = calResult.getEnd();
+    if (end != null) {
+      if (calResult.isEndAllDay() && !start.equals(end)) {
+        // Show only year/month/day
+        // if it's all-day and this is the end date, it's exclusive, so show the user
+        // that it ends on the day before to make more intuitive sense.
+        // But don't do it if the event already (incorrectly?) specifies the same start/end
+        end = new Date(end.getTime() - 24 * 60 * 60 * 1000);
+      }
+      ParsedResult.maybeAppend(format(calResult.isEndAllDay(), end), result);
+    }
+
+    ParsedResult.maybeAppend(calResult.getLocation(), result);
+    ParsedResult.maybeAppend(calResult.getOrganizer(), result);
+    ParsedResult.maybeAppend(calResult.getAttendees(), result);
+    ParsedResult.maybeAppend(calResult.getDescription(), result);
+    return result.toString();
+  }
+
+  private static String format(boolean allDay, Date date) {
+    if (date == null) {
+      return null;
+    }
+    DateFormat format = allDay
+        ? DateFormat.getDateInstance(DateFormat.MEDIUM)
+        : DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);
+    return format.format(date);
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_calendar;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/EmailAddressResultHandler.java b/src/com/android/contacts/util/barcode/result/EmailAddressResultHandler.java
new file mode 100644
index 0000000..11a2b75
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/EmailAddressResultHandler.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.client.result.EmailAddressParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.contacts.R;
+
+/**
+ * Handles email addresses.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class EmailAddressResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_email,
+      R.string.button_add_contact
+  };
+
+  public EmailAddressResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    EmailAddressParsedResult emailResult = (EmailAddressParsedResult) getResult();
+    switch (index) {
+      case 0:
+        sendEmail(emailResult.getTos(),
+                  emailResult.getCCs(),
+                  emailResult.getBCCs(),
+                  emailResult.getSubject(),
+                  emailResult.getBody());
+        break;
+      case 1:
+        addEmailOnlyContact(emailResult.getTos(), null);
+        break;
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_email_address;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/GeoResultHandler.java b/src/com/android/contacts/util/barcode/result/GeoResultHandler.java
new file mode 100644
index 0000000..d838714
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/GeoResultHandler.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.client.result.GeoParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.contacts.R;
+
+
+/**
+ * Handles geographic coordinates (typically encoded as geo: URLs).
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class GeoResultHandler extends ResultHandler {
+    private static final int[] buttons = {
+            R.string.button_show_map,
+            R.string.button_get_directions
+    };
+
+    public GeoResultHandler(Activity activity, ParsedResult result) {
+        super(activity, result);
+    }
+
+    @Override
+    public int getButtonCount() {
+        return buttons.length;
+    }
+
+    @Override
+    public int getButtonText(int index) {
+        return buttons[index];
+    }
+
+    @Override
+    public void handleButtonPress(int index) {
+        GeoParsedResult geoResult = (GeoParsedResult) getResult();
+        switch (index) {
+            case 0:
+                openMap(geoResult.getGeoURI());
+                break;
+            case 1:
+                getDirections(geoResult.getLatitude(), geoResult.getLongitude());
+                break;
+        }
+    }
+
+    @Override
+    public int getDisplayTitle() {
+        return R.string.result_geo;
+    }
+}
diff --git a/src/com/android/contacts/util/barcode/result/ISBNResultHandler.java b/src/com/android/contacts/util/barcode/result/ISBNResultHandler.java
new file mode 100644
index 0000000..6271622
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/ISBNResultHandler.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ISBNParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.contacts.R;
+
+/**
+ * Handles books encoded by their ISBN values.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ISBNResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_product_search,
+      R.string.button_book_search,
+      R.string.button_search_book_contents,
+      R.string.button_custom_product_search
+  };
+
+  public ISBNResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+    super(activity, result, rawResult);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    ISBNParsedResult isbnResult = (ISBNParsedResult) getResult();
+    switch (index) {
+      case 0:
+        openProductSearch(isbnResult.getISBN());
+        break;
+      case 1:
+        openBookSearch(isbnResult.getISBN());
+        break;
+      case 3:
+        openURL(fillInCustomSearchURL(isbnResult.getISBN()));
+        break;
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_isbn;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/ProductResultHandler.java b/src/com/android/contacts/util/barcode/result/ProductResultHandler.java
new file mode 100644
index 0000000..a648339
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/ProductResultHandler.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ExpandedProductParsedResult;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.ProductParsedResult;
+
+import com.android.contacts.R;
+
+
+/**
+ * Handles generic products which are not books.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ProductResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_product_search,
+      R.string.button_web_search,
+      R.string.button_custom_product_search
+  };
+
+  public ProductResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+    super(activity, result, rawResult);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    String productID = getProductIDFromResult(getResult());
+    switch (index) {
+      case 0:
+        openProductSearch(productID);
+        break;
+      case 1:
+        webSearch(productID);
+        break;
+      case 2:
+        openURL(fillInCustomSearchURL(productID));
+        break;
+    }
+  }
+
+  private static String getProductIDFromResult(ParsedResult rawResult) {
+    if (rawResult instanceof ProductParsedResult) {
+      return ((ProductParsedResult) rawResult).getNormalizedProductID();
+    }
+    if (rawResult instanceof ExpandedProductParsedResult) {
+      return ((ExpandedProductParsedResult) rawResult).getRawText();
+    }
+    throw new IllegalArgumentException(rawResult.getClass().toString());
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_product;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/ResultHandler.java b/src/com/android/contacts/util/barcode/result/ResultHandler.java
new file mode 100644
index 0000000..3e7bd95
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/ResultHandler.java
@@ -0,0 +1,497 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ActivityNotFoundException;
+import android.content.ContentValues;
+import android.content.Intent;
+import android.net.Uri;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+import com.android.contacts.util.barcode.Contents;
+import com.android.contacts.util.barcode.LocaleManager;
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.ParsedResultType;
+import com.google.zxing.client.result.ResultParser;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.Locale;
+
+import com.android.contacts.R;
+
+
+/**
+ * A base class for the Android-specific barcode handlers. These allow the app to polymorphically
+ * suggest the appropriate actions for each data type.
+ * <p>
+ * This class also contains a bunch of utility methods to take common actions like opening a URL.
+ * They could easily be moved into a helper object, but it can't be static because the Activity
+ * instance is needed to launch an intent.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ * @author Sean Owen
+ */
+public abstract class ResultHandler {
+
+    private static final String TAG = ResultHandler.class.getSimpleName();
+
+    private static final String[] EMAIL_TYPE_STRINGS = {"home", "work", "mobile"};
+    private static final String[] PHONE_TYPE_STRINGS = {"home", "work", "mobile", "fax", "pager", "main"};
+    private static final String[] ADDRESS_TYPE_STRINGS = {"home", "work"};
+    private static final int[] EMAIL_TYPE_VALUES = {
+            ContactsContract.CommonDataKinds.Email.TYPE_HOME,
+            ContactsContract.CommonDataKinds.Email.TYPE_WORK,
+            ContactsContract.CommonDataKinds.Email.TYPE_MOBILE,
+    };
+    private static final int[] PHONE_TYPE_VALUES = {
+            ContactsContract.CommonDataKinds.Phone.TYPE_HOME,
+            ContactsContract.CommonDataKinds.Phone.TYPE_WORK,
+            ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE,
+            ContactsContract.CommonDataKinds.Phone.TYPE_FAX_WORK,
+            ContactsContract.CommonDataKinds.Phone.TYPE_PAGER,
+            ContactsContract.CommonDataKinds.Phone.TYPE_MAIN,
+    };
+    private static final int[] ADDRESS_TYPE_VALUES = {
+            ContactsContract.CommonDataKinds.StructuredPostal.TYPE_HOME,
+            ContactsContract.CommonDataKinds.StructuredPostal.TYPE_WORK,
+    };
+    private static final int NO_TYPE = -1;
+
+    public static final int MAX_BUTTON_COUNT = 4;
+
+    private final ParsedResult result;
+    private final Activity activity;
+    private final Result rawResult;
+    private final String customProductSearch;
+
+    ResultHandler(Activity activity, ParsedResult result) {
+        this(activity, result, null);
+    }
+
+    ResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+        this.result = result;
+        this.activity = activity;
+        this.rawResult = rawResult;
+        this.customProductSearch = parseCustomSearchURL();
+    }
+
+    public final ParsedResult getResult() {
+        return result;
+    }
+
+    final boolean hasCustomProductSearch() {
+        return customProductSearch != null;
+    }
+
+    final Activity getActivity() {
+        return activity;
+    }
+
+    /**
+     * Indicates how many buttons the derived class wants shown.
+     *
+     * @return The integer button count.
+     */
+    public abstract int getButtonCount();
+
+    /**
+     * The text of the nth action button.
+     *
+     * @param index From 0 to getButtonCount() - 1
+     * @return The button text as a resource ID
+     */
+    public abstract int getButtonText(int index);
+
+    public Integer getDefaultButtonID() {
+        return null;
+    }
+
+    /**
+     * Execute the action which corresponds to the nth button.
+     *
+     * @param index The button that was clicked.
+     */
+    public abstract void handleButtonPress(int index);
+
+    /**
+     * Some barcode contents are considered secure, and should not be saved to history, copied to
+     * the clipboard, or otherwise persisted.
+     *
+     * @return If true, do not create any permanent record of these contents.
+     */
+    public boolean areContentsSecure() {
+        return false;
+    }
+
+    /**
+     * Create a possibly styled string for the contents of the current barcode.
+     *
+     * @return The text to be displayed.
+     */
+    public CharSequence getDisplayContents() {
+        String contents = result.getDisplayResult();
+        return contents.replace("\r", "");
+    }
+
+    /**
+     * A string describing the kind of barcode that was found, e.g. "Found contact info".
+     *
+     * @return The resource ID of the string.
+     */
+    public abstract int getDisplayTitle();
+
+    /**
+     * A convenience method to get the parsed type. Should not be overridden.
+     *
+     * @return The parsed type, e.g. URI or ISBN
+     */
+    public final ParsedResultType getType() {
+        return result.getType();
+    }
+
+    final void addPhoneOnlyContact(String[] phoneNumbers, String[] phoneTypes) {
+        addContact(null, null, null, phoneNumbers, phoneTypes, null, null, null, null, null, null, null, null, null, null, null);
+    }
+
+    final void addEmailOnlyContact(String[] emails, String[] emailTypes) {
+        addContact(null, null, null, null, null, emails, emailTypes, null, null, null, null, null, null, null, null, null);
+    }
+
+    final void addContact(String[] names,
+                          String[] nicknames,
+                          String pronunciation,
+                          String[] phoneNumbers,
+                          String[] phoneTypes,
+                          String[] emails,
+                          String[] emailTypes,
+                          String note,
+                          String instantMessenger,
+                          String address,
+                          String addressType,
+                          String org,
+                          String title,
+                          String[] urls,
+                          String birthday,
+                          String[] geo) {
+
+        // Only use the first name in the array, if present.
+        Intent intent = new Intent(Intent.ACTION_INSERT_OR_EDIT, ContactsContract.Contacts.CONTENT_URI);
+        intent.setType(ContactsContract.Contacts.CONTENT_ITEM_TYPE);
+        putExtra(intent, ContactsContract.Intents.Insert.NAME, names != null ? names[0] : null);
+
+        putExtra(intent, ContactsContract.Intents.Insert.PHONETIC_NAME, pronunciation);
+
+        int phoneCount = Math.min(phoneNumbers != null ? phoneNumbers.length : 0, Contents.PHONE_KEYS.length);
+        for (int x = 0; x < phoneCount; x++) {
+            putExtra(intent, Contents.PHONE_KEYS[x], phoneNumbers[x]);
+            if (phoneTypes != null && x < phoneTypes.length) {
+                int type = toPhoneContractType(phoneTypes[x]);
+                if (type >= 0) {
+                    intent.putExtra(Contents.PHONE_TYPE_KEYS[x], type);
+                }
+            }
+        }
+
+        int emailCount = Math.min(emails != null ? emails.length : 0, Contents.EMAIL_KEYS.length);
+        for (int x = 0; x < emailCount; x++) {
+            putExtra(intent, Contents.EMAIL_KEYS[x], emails[x]);
+            if (emailTypes != null && x < emailTypes.length) {
+                int type = toEmailContractType(emailTypes[x]);
+                if (type >= 0) {
+                    intent.putExtra(Contents.EMAIL_TYPE_KEYS[x], type);
+                }
+            }
+        }
+
+        ArrayList<ContentValues> data = new ArrayList<>();
+        if (urls != null) {
+            for (String url : urls) {
+                if (url != null && !url.isEmpty()) {
+                    ContentValues row = new ContentValues(2);
+                    row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Website.CONTENT_ITEM_TYPE);
+                    row.put(ContactsContract.CommonDataKinds.Website.URL, url);
+                    data.add(row);
+                    break;
+                }
+            }
+        }
+
+        if (birthday != null) {
+            ContentValues row = new ContentValues(3);
+            row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
+            row.put(ContactsContract.CommonDataKinds.Event.TYPE, ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY);
+            row.put(ContactsContract.CommonDataKinds.Event.START_DATE, birthday);
+            data.add(row);
+        }
+
+        if (nicknames != null) {
+            for (String nickname : nicknames) {
+                if (nickname != null && !nickname.isEmpty()) {
+                    ContentValues row = new ContentValues(3);
+                    row.put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Nickname.CONTENT_ITEM_TYPE);
+                    row.put(ContactsContract.CommonDataKinds.Nickname.TYPE,
+                            ContactsContract.CommonDataKinds.Nickname.TYPE_DEFAULT);
+                    row.put(ContactsContract.CommonDataKinds.Nickname.NAME, nickname);
+                    data.add(row);
+                    break;
+                }
+            }
+        }
+
+        if (!data.isEmpty()) {
+            intent.putParcelableArrayListExtra(ContactsContract.Intents.Insert.DATA, data);
+        }
+
+        StringBuilder aggregatedNotes = new StringBuilder();
+        if (note != null) {
+            aggregatedNotes.append('\n').append(note);
+        }
+        if (geo != null) {
+            aggregatedNotes.append('\n').append(geo[0]).append(',').append(geo[1]);
+        }
+
+        if (aggregatedNotes.length() > 0) {
+            // Remove extra leading '\n'
+            putExtra(intent, ContactsContract.Intents.Insert.NOTES, aggregatedNotes.substring(1));
+        }
+
+        putExtra(intent, ContactsContract.Intents.Insert.IM_HANDLE, instantMessenger);
+        putExtra(intent, ContactsContract.Intents.Insert.POSTAL, address);
+        if (addressType != null) {
+            int type = toAddressContractType(addressType);
+            if (type >= 0) {
+                intent.putExtra(ContactsContract.Intents.Insert.POSTAL_TYPE, type);
+            }
+        }
+        putExtra(intent, ContactsContract.Intents.Insert.COMPANY, org);
+        putExtra(intent, ContactsContract.Intents.Insert.JOB_TITLE, title);
+        launchIntent(intent);
+    }
+
+    private static int toEmailContractType(String typeString) {
+        return doToContractType(typeString, EMAIL_TYPE_STRINGS, EMAIL_TYPE_VALUES);
+    }
+
+    private static int toPhoneContractType(String typeString) {
+        return doToContractType(typeString, PHONE_TYPE_STRINGS, PHONE_TYPE_VALUES);
+    }
+
+    private static int toAddressContractType(String typeString) {
+        return doToContractType(typeString, ADDRESS_TYPE_STRINGS, ADDRESS_TYPE_VALUES);
+    }
+
+    private static int doToContractType(String typeString, String[] types, int[] values) {
+        if (typeString == null) {
+            return NO_TYPE;
+        }
+        for (int i = 0; i < types.length; i++) {
+            String type = types[i];
+            if (typeString.startsWith(type) || typeString.startsWith(type.toUpperCase(Locale.ENGLISH))) {
+                return values[i];
+            }
+        }
+        return NO_TYPE;
+    }
+
+    final void shareByEmail(String contents) {
+        sendEmail(null, null, null, null, contents);
+    }
+
+    final void sendEmail(String[] to,
+                         String[] cc,
+                         String[] bcc,
+                         String subject,
+                         String body) {
+        Intent intent = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
+        if (to != null && to.length != 0) {
+            intent.putExtra(Intent.EXTRA_EMAIL, to);
+        }
+        if (cc != null && cc.length != 0) {
+            intent.putExtra(Intent.EXTRA_CC, cc);
+        }
+        if (bcc != null && bcc.length != 0) {
+            intent.putExtra(Intent.EXTRA_BCC, bcc);
+        }
+        putExtra(intent, Intent.EXTRA_SUBJECT, subject);
+        putExtra(intent, Intent.EXTRA_TEXT, body);
+        intent.setType("text/plain");
+        launchIntent(intent);
+    }
+
+    final void shareBySMS(String contents) {
+        sendSMSFromUri("smsto:", contents);
+    }
+
+    final void sendSMS(String phoneNumber, String body) {
+        sendSMSFromUri("smsto:" + phoneNumber, body);
+    }
+
+    private void sendSMSFromUri(String uri, String body) {
+        Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));
+        putExtra(intent, "sms_body", body);
+        // Exit the app once the SMS is sent
+        intent.putExtra("compose_mode", true);
+        launchIntent(intent);
+    }
+
+    final void sendMMS(String phoneNumber, String subject, String body) {
+        sendMMSFromUri("mmsto:" + phoneNumber, subject, body);
+    }
+
+    private void sendMMSFromUri(String uri, String subject, String body) {
+        Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));
+        // The Messaging app needs to see a valid subject or else it will treat this an an SMS.
+        if (subject == null || subject.isEmpty()) {
+            putExtra(intent, "subject", activity.getString(R.string.msg_default_mms_subject));
+        } else {
+            putExtra(intent, "subject", subject);
+        }
+        putExtra(intent, "sms_body", body);
+        intent.putExtra("compose_mode", true);
+        launchIntent(intent);
+    }
+
+    final void dialPhone(String phoneNumber) {
+        launchIntent(new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + phoneNumber)));
+    }
+
+    final void dialPhoneFromUri(String uri) {
+        launchIntent(new Intent(Intent.ACTION_DIAL, Uri.parse(uri)));
+    }
+
+    final void openMap(String geoURI) {
+        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(geoURI)));
+    }
+
+    /**
+     * Do a geo search using the address as the query.
+     *
+     * @param address The address to find
+     */
+    final void searchMap(String address) {
+        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse("geo:0,0?q=" + Uri.encode(address))));
+    }
+
+    final void getDirections(double latitude, double longitude) {
+        launchIntent(new Intent(Intent.ACTION_VIEW, Uri.parse("http://maps.google." +
+                LocaleManager.getCountryTLD(activity) + "/maps?f=d&daddr=" + latitude + ',' + longitude)));
+    }
+
+    // Uses the mobile-specific version of Product Search, which is formatted for small screens.
+    final void openProductSearch(String upc) {
+        Uri uri = Uri.parse("http://www.google." + LocaleManager.getProductSearchCountryTLD(activity) +
+                "/m/products?q=" + upc + "&source=zxing");
+        launchIntent(new Intent(Intent.ACTION_VIEW, uri));
+    }
+
+    final void openBookSearch(String isbn) {
+        Uri uri = Uri.parse("http://books.google." + LocaleManager.getBookSearchCountryTLD(activity) +
+                "/books?vid=isbn" + isbn);
+        launchIntent(new Intent(Intent.ACTION_VIEW, uri));
+    }
+
+    final void openURL(String url) {
+        // Strangely, some Android browsers don't seem to register to handle HTTP:// or HTTPS://.
+        // Lower-case these as it should always be OK to lower-case these schemes.
+        if (url.startsWith("HTTP://")) {
+            url = "http" + url.substring(4);
+        } else if (url.startsWith("HTTPS://")) {
+            url = "https" + url.substring(5);
+        }
+        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+        try {
+            launchIntent(intent);
+        } catch (ActivityNotFoundException ignored) {
+            Log.w(TAG, "Nothing available to handle " + intent);
+        }
+    }
+
+    final void webSearch(String query) {
+        Intent intent = new Intent(Intent.ACTION_WEB_SEARCH);
+        intent.putExtra("query", query);
+        launchIntent(intent);
+    }
+
+    /**
+     * Like {@link #launchIntent(Intent)} but will tell you if it is not handle-able
+     * via {@link ActivityNotFoundException}.
+     *
+     * @throws ActivityNotFoundException if Intent can't be handled
+     */
+    final void rawLaunchIntent(Intent intent) {
+        if (intent != null) {
+            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+            Log.d(TAG, "Launching intent: " + intent + " with extras: " + intent.getExtras());
+            activity.startActivity(intent);
+        }
+    }
+
+    /**
+     * Like {@link #rawLaunchIntent(Intent)} but will show a user dialog if nothing is available to handle.
+     */
+    final void launchIntent(Intent intent) {
+        try {
+            rawLaunchIntent(intent);
+        } catch (ActivityNotFoundException ignored) {
+            AlertDialog.Builder builder = new AlertDialog.Builder(activity);
+            builder.setTitle(R.string.applicationLabel);
+            builder.setMessage(R.string.msg_intent_failed);
+            builder.setPositiveButton(android.R.string.ok, null);
+            builder.show();
+        }
+    }
+
+    private static void putExtra(Intent intent, String key, String value) {
+        if (value != null && !value.isEmpty()) {
+            intent.putExtra(key, value);
+        }
+    }
+
+    private String parseCustomSearchURL() {
+        return null;
+    }
+
+    final String fillInCustomSearchURL(String text) {
+        if (customProductSearch == null) {
+            return text; // ?
+        }
+        try {
+            text = URLEncoder.encode(text, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            // can't happen; UTF-8 is always supported. Continue, I guess, without encoding
+        }
+        String url = customProductSearch;
+        if (rawResult != null) {
+            // Replace %f but only if it doesn't seem to be a hex escape sequence. This remains
+            // problematic but avoids the more surprising problem of breaking escapes
+            url = url.replaceFirst("%f(?![0-9a-f])", rawResult.getBarcodeFormat().toString());
+            if (url.contains("%t")) {
+                ParsedResult parsedResultAgain = ResultParser.parseResult(rawResult);
+                url = url.replace("%t", parsedResultAgain.getType().toString());
+            }
+        }
+        // Replace %s last as it might contain itself %f or %t
+        return url.replace("%s", text);
+    }
+
+}
diff --git a/src/com/android/contacts/util/barcode/result/ResultHandlerFactory.java b/src/com/android/contacts/util/barcode/result/ResultHandlerFactory.java
new file mode 100644
index 0000000..ff946ae
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/ResultHandlerFactory.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import com.android.contacts.util.barcode.CaptureActivity;
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.ResultParser;
+
+
+/**
+ * Manufactures Android-specific handlers based on the barcode content's type.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class ResultHandlerFactory {
+  private ResultHandlerFactory() {
+  }
+
+  public static ResultHandler makeResultHandler(CaptureActivity activity, Result rawResult) {
+    ParsedResult result = parseResult(rawResult);
+    switch (result.getType()) {
+      case ADDRESSBOOK:
+        return new AddressBookResultHandler(activity, result);
+      case EMAIL_ADDRESS:
+        return new EmailAddressResultHandler(activity, result);
+      case PRODUCT:
+        return new ProductResultHandler(activity, result, rawResult);
+      case URI:
+        return new URIResultHandler(activity, result);
+      case GEO:
+        return new GeoResultHandler(activity, result);
+      case TEL:
+        return new TelResultHandler(activity, result);
+      case SMS:
+        return new SMSResultHandler(activity, result);
+      case CALENDAR:
+        return new CalendarResultHandler(activity, result);
+      case ISBN:
+        return new ISBNResultHandler(activity, result, rawResult);
+      default:
+        return new TextResultHandler(activity, result, rawResult);
+    }
+  }
+
+  private static ParsedResult parseResult(Result rawResult) {
+    return ResultParser.parseResult(rawResult);
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/SMSResultHandler.java b/src/com/android/contacts/util/barcode/result/SMSResultHandler.java
new file mode 100644
index 0000000..a663172
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/SMSResultHandler.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+import android.telephony.PhoneNumberUtils;
+
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.SMSParsedResult;
+
+import com.android.contacts.R;
+
+/**
+ * Handles SMS addresses, offering a choice of composing a new SMS or MMS message.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class SMSResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_sms,
+      R.string.button_mms
+  };
+
+  public SMSResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    SMSParsedResult smsResult = (SMSParsedResult) getResult();
+    String number = smsResult.getNumbers()[0];
+    switch (index) {
+      case 0:
+        // Don't know of a way yet to express a SENDTO intent with multiple recipients
+        sendSMS(number, smsResult.getBody());
+        break;
+      case 1:
+        sendMMS(number, smsResult.getSubject(), smsResult.getBody());
+        break;
+    }
+  }
+
+  @Override
+  public CharSequence getDisplayContents() {
+    SMSParsedResult smsResult = (SMSParsedResult) getResult();
+    String[] rawNumbers = smsResult.getNumbers();
+    String[] formattedNumbers = new String[rawNumbers.length];
+    for (int i = 0; i < rawNumbers.length; i++) {
+      formattedNumbers[i] = PhoneNumberUtils.formatNumber(rawNumbers[i]);
+    }
+    StringBuilder contents = new StringBuilder(50);
+    ParsedResult.maybeAppend(formattedNumbers, contents);
+    ParsedResult.maybeAppend(smsResult.getSubject(), contents);
+    ParsedResult.maybeAppend(smsResult.getBody(), contents);
+    return contents.toString();
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_sms;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/TelResultHandler.java b/src/com/android/contacts/util/barcode/result/TelResultHandler.java
new file mode 100644
index 0000000..c9fcdac
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/TelResultHandler.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+import android.telephony.PhoneNumberUtils;
+
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.TelParsedResult;
+
+import com.android.contacts.R;
+
+
+/**
+ * Offers relevant actions for telephone numbers.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class TelResultHandler extends ResultHandler {
+  private static final int[] buttons = {
+      R.string.button_dial,
+      R.string.button_add_contact
+  };
+
+  public TelResultHandler(Activity activity, ParsedResult result) {
+    super(activity, result);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return buttons.length;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    TelParsedResult telResult = (TelParsedResult) getResult();
+    switch (index) {
+      case 0:
+        dialPhoneFromUri(telResult.getTelURI());
+        // When dialer comes up, it allows underlying display activity to continue or something,
+        // but app can't get camera in this state. Avoid issues by just quitting, only in the
+        // case of a phone number
+        getActivity().finish();
+        break;
+      case 1:
+        String[] numbers = new String[1];
+        numbers[0] = telResult.getNumber();
+        addPhoneOnlyContact(numbers, null);
+        break;
+    }
+  }
+
+  // Overriden so we can take advantage of Android's phone number hyphenation routines.
+  @Override
+  public CharSequence getDisplayContents() {
+    String contents = getResult().getDisplayResult();
+    contents = contents.replace("\r", "");
+    return PhoneNumberUtils.formatNumber(contents);
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_tel;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/TextResultHandler.java b/src/com/android/contacts/util/barcode/result/TextResultHandler.java
new file mode 100644
index 0000000..1307c99
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/TextResultHandler.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.google.zxing.Result;
+import com.google.zxing.client.result.ParsedResult;
+
+import com.android.contacts.R;
+
+
+/**
+ * This class handles TextParsedResult as well as unknown formats. It's the fallback handler.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class TextResultHandler extends ResultHandler {
+
+  private static final int[] buttons = {
+      R.string.button_web_search,
+      R.string.button_share_by_email,
+      R.string.button_share_by_sms,
+      R.string.button_custom_product_search,
+  };
+
+  public TextResultHandler(Activity activity, ParsedResult result, Result rawResult) {
+    super(activity, result, rawResult);
+  }
+
+  @Override
+  public int getButtonCount() {
+    return hasCustomProductSearch() ? buttons.length : buttons.length - 1;
+  }
+
+  @Override
+  public int getButtonText(int index) {
+    return buttons[index];
+  }
+
+  @Override
+  public void handleButtonPress(int index) {
+    String text = getResult().getDisplayResult();
+    switch (index) {
+      case 0:
+        webSearch(text);
+        break;
+      case 1:
+        shareByEmail(text);
+        break;
+      case 2:
+        shareBySMS(text);
+        break;
+      case 3:
+        openURL(fillInCustomSearchURL(text));
+        break;
+    }
+  }
+
+  @Override
+  public int getDisplayTitle() {
+    return R.string.result_text;
+  }
+}
diff --git a/src/com/android/contacts/util/barcode/result/URIResultHandler.java b/src/com/android/contacts/util/barcode/result/URIResultHandler.java
new file mode 100644
index 0000000..a4c2bd0
--- /dev/null
+++ b/src/com/android/contacts/util/barcode/result/URIResultHandler.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2008 ZXing authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.contacts.util.barcode.result;
+
+import android.app.Activity;
+
+import com.android.contacts.util.barcode.LocaleManager;
+import com.google.zxing.client.result.ParsedResult;
+import com.google.zxing.client.result.URIParsedResult;
+
+import java.util.Locale;
+
+import com.android.contacts.R;
+
+
+/**
+ * Offers appropriate actions for URLS.
+ *
+ * @author dswitkin@google.com (Daniel Switkin)
+ */
+public final class URIResultHandler extends ResultHandler {
+    // URIs beginning with entries in this array will not be saved to history or copied to the
+    // clipboard for security.
+    private static final String[] SECURE_PROTOCOLS = {
+            "otpauth:"
+    };
+
+    private static final int[] buttons = {
+            R.string.button_open_browser,
+            R.string.button_share_by_email,
+            R.string.button_share_by_sms,
+            R.string.button_search_book_contents,
+    };
+
+    public URIResultHandler(Activity activity, ParsedResult result) {
+        super(activity, result);
+    }
+
+    @Override
+    public int getButtonCount() {
+        if (LocaleManager.isBookSearchUrl(((URIParsedResult) getResult()).getURI())) {
+            return buttons.length;
+        }
+        return buttons.length - 1;
+    }
+
+    @Override
+    public int getButtonText(int index) {
+        return buttons[index];
+    }
+
+    @Override
+    public Integer getDefaultButtonID() {
+        return 0;
+    }
+
+    @Override
+    public void handleButtonPress(int index) {
+        URIParsedResult uriResult = (URIParsedResult) getResult();
+        String uri = uriResult.getURI();
+        switch (index) {
+            case 0:
+                openURL(uri);
+                break;
+            case 1:
+                shareByEmail(uri);
+                break;
+            case 2:
+                shareBySMS(uri);
+                break;
+        }
+    }
+
+    @Override
+    public int getDisplayTitle() {
+        return R.string.result_uri;
+    }
+
+    @Override
+    public boolean areContentsSecure() {
+        URIParsedResult uriResult = (URIParsedResult) getResult();
+        String uri = uriResult.getURI().toLowerCase(Locale.ENGLISH);
+        for (String secure : SECURE_PROTOCOLS) {
+            if (uri.startsWith(secure)) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
-- 
2.7.4

